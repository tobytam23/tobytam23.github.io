<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>First Post!!</title>
    <link href="/2024/12/03/helloworld/"/>
    <url>/2024/12/03/helloworld/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-for-your-coming"><a href="#Welcome-for-your-coming" class="headerlink" title="Welcome for your coming"></a>Welcome for your coming</h1><p>你好，我是TAM CHEOK HANG，欢迎来到我的博客呀。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><h2 id="第一章-操作系统导论"><a href="#第一章-操作系统导论" class="headerlink" title="第一章 操作系统导论"></a>第一章 操作系统导论</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>操作系统位于<strong>计算机用户和计算机硬件之间</strong>，主要目的是<strong>提供环境</strong>来方便帮助用户执行程序。简单来说，操作系统就是<strong>管理硬件资源</strong>和<strong>控制程序执行</strong>的<strong>系统软件</strong>。</p><h3 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h3><p>由<strong>用户</strong>、<strong>应用</strong>、<strong>操作系统</strong>、<strong>硬件</strong>组成。（从上往下看）<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626201011862.png" alt="image-20240626201011862" style="zoom:67%;" /></p><h3 id="计算系统"><a href="#计算系统" class="headerlink" title="计算系统"></a>计算系统</h3><p>基本元素为：<strong>CPU</strong>、<strong>主存</strong>、<strong>IO</strong>、<strong>系统总线</strong>…</p><ol><li>CPU：中央处理器，负责计算机的计算。</li><li>主存：你知我知。<strong>断电后内容会消失</strong>。</li><li>IO：在计算机和外部环境之间移动数据。</li><li>系统总线：提供CPU、主存与I&#x2F;O模块之间的通信通道。</li></ol><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断就是打断当前执行的进程，<strong>立即处理比较紧急</strong>的进程，然后再返回当前进程继续执行。</p><blockquote><p>中断机制的出现是为了协调处理器与外部设备速度不一致的问题，以提高处理器的利用率。<br>试想我们打开了文本编辑器，处理器就不干活了，等着键盘输入，这会浪费多少处理器计算资源？<br>另一种方式是处理器忙自己的，等有输入时再通知处理器。</p></blockquote><ol><li>中断机制的主要原因是<strong>提高性能</strong>。（因为cpu计算的时间和IO的时间差距很大）</li><li>中断分类：分为<strong>硬件中断</strong>和<strong>软件中断</strong>。<ul><li>硬件中断：通常我们说的中断都是硬件中断。例子：<strong>敲击键盘</strong>、<strong>移动鼠标</strong>、<strong>timer</strong>。完成硬件中断后会返回一个<strong>signal</strong>提醒处理器。</li><li>软件中断：<strong>异常</strong>和<strong>系统调用(system call)<strong>。例子：</strong>system call函数</strong>或者<strong>除以0</strong>。</li></ul></li><li>中断实现：<ul><li>中断向量表：中断向量表存储了每种可能的<strong>中断类型</strong>对应的<strong>中断处理程序的起始地址</strong>。</li></ul></li></ol><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>按照<strong>层次</strong>分类。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626203649171.png" alt="image-20240626203649171" style="zoom: 50%;" /></p><p>磁盘可以<strong>随机读取</strong>，可是<strong>磁带只能顺序读取</strong>。</p><h3 id="IO结构"><a href="#IO结构" class="headerlink" title="IO结构"></a>IO结构</h3><ol><li>简单理解成要数据要传输了。</li><li>通用计算机都由CPU和多个设备控制器组成，通过总线连接，每个设备管理某一特定类型的设备。</li><li>通过中断来执行IO：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626204437935.png" alt="image-20240626204437935" style="zoom: 50%;" />、</li></ol><p>这个设计使得cpu和io设备可以<strong>并行执行</strong>。</p><h3 id="操作系统执行"><a href="#操作系统执行" class="headerlink" title="操作系统执行"></a>操作系统执行</h3><ol><li>引导程序，找到操作系统的代码，并加载简单的内核代码（在硬件层面）。</li><li>加载内核。</li><li>启动系统服务</li><li>用户登录</li><li>用户执行程序</li></ol><h3 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h3><p>计算机要处理的一个计算问题称为<strong>作业</strong>。</p><p>就是一次处理多个作业，把多个作业加载到内存，所以CPU总是有一个作业要执行。</p><p>在作业执行时，用户<strong>不能直接干预</strong>。</p><p><strong>效率快</strong>，因为减少了调作业进内存的时间（一次调一批作业）而且cpu比较少时间空闲。</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626204946402.png" alt="image-20240626204946402" style="zoom:50%;" /><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>有点类似RR算法，就是频繁切换作业，每个用户的作业跑一个<strong>时间片</strong>被换出。</p><p>所以多个用户们可以<strong>交互</strong>。</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>实时操作系统通常用于需要对<strong>任务执行时间</strong>有严格要求的应用领域。</p><p><strong>响应时间保证</strong>：实时操作系统能够保证任务在其要求的时间内完成或响应。</p><p><strong>任务调度机制</strong>：实时操作系统使用特殊的任务调度算法，如<strong>优先级调度</strong>和<strong>周期性调度</strong>，以确保高优先级任务能够及时执行，而不会被低优先级任务阻塞。</p><p>应用于<strong>飞行控制系统</strong>等等。</p><h3 id="双重模式"><a href="#双重模式" class="headerlink" title="双重模式"></a><strong>双重模式</strong></h3><p>包括<strong>内核模式</strong>和<strong>用户模式</strong>。</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626205303231.png" alt="image-20240626205303231" style="zoom:50%;" /><ul><li>硬件会提供一个模式位(bit)来判断当前是内核还是用户。</li><li>当用户<strong>调用系统函数</strong>或<strong>中断</strong>时，会自动<strong>变成内核模式</strong>，返回后<strong>改回用户模式</strong>。</li><li>有些函数<strong>只有内核态</strong>才能调用。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626205754059.png" alt="image-20240626205754059" style="zoom:50%;" /></li></ul><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>书本题目1.8：中断和陷阱的区别，用户程序能否有意产生陷阱，如果能，为什么？</p><p>答：陷阱是<strong>用户程序产生</strong>的软件中断，所以它是<strong>同步</strong>的；中断是由<strong>硬件</strong>发出的信号，接收到信号后需要<strong>异步</strong>的停止当前进程，然后执行对应中断的程序；用户程序能产生陷阱，例如像屏幕输出就是用户程序产生陷阱。</p><blockquote><p>陷阱是由用户程序发出的信号，指示操作系统立即执行某些功能。相反，中断是由硬件发出的给CPU的信号，表示需要立即处理的事件。</p></blockquote><ol start="2"><li>cpu只能读取<strong>主存</strong>和cpu内的<strong>寄存器</strong>。</li></ol><h2 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="headerlink" title="第二章 操作系统结构"></a>第二章 操作系统结构</h2><h3 id="操作系统提供的服务"><a href="#操作系统提供的服务" class="headerlink" title="操作系统提供的服务"></a>操作系统提供的服务</h3><ol><li>程序执行的环境</li><li>提供用户服务：<ul><li>用户界面<ul><li>用户界面、图形用户界面(GUI)</li></ul></li><li>程序执行<ul><li>系统必须把<strong>程序加载到内存并执行</strong></li></ul></li><li>IO操作</li><li>文件系统操作</li><li>通信<ul><li>进程在同一台计算机上交换信息</li></ul></li><li>资源分配</li></ul></li></ol><h3 id="操作系统如何提供服务"><a href="#操作系统如何提供服务" class="headerlink" title="操作系统如何提供服务"></a>操作系统如何提供服务</h3><p>操作系统通过**系统调用(system call)**来向用户提供服务。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626215521162.png" alt="image-20240626215521162" style="zoom: 80%;" /></p><p>系统调用是一种<strong>中断</strong>。</p><h3 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h3><p>将操作系统像洋葱一样分成多层，第0层为硬件(<strong>最底层</strong>)，第N层为用户(<strong>最高层</strong>)。</p><p>每一层<strong>仅使用</strong>更低一层的功能和服务。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626221509216.png" alt="image-20240626221509216" style="zoom: 67%;" /></p><p>操作系统分层：<strong>设备</strong>管理、<strong>文件</strong>管理、<strong>处理器</strong>管理、<strong>存储</strong>管理、<strong>作业</strong>管理。</p><h3 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h3><ul><li><p>宏内核</p><p>宏内核是大而全的管理者。</p><p>宏内核，也被称为单体内核，是一种把所有的<strong>服务都集中在一起</strong>的内核设计。</p><p>它的优点是<strong>性能高</strong>，因为所有服务都在内核中运行，调用过程简单，效率高。</p><p>这种设计也有缺点，如果内核中的一个服务<strong>出现问题</strong>，可能会<strong>影响到整个系统的稳定性</strong>。</p><p>操作系统代表：<strong>Linux</strong>、<strong>Unix</strong>。</p><blockquote><p>就像一个城市的交通系统，所有的道路、桥梁、交通信号灯都是由一个中央指挥系统控制。这种方式的优点是效率高，因为所有的交通运输都在同一个系统内部进行调度，所以调度速度快，交通流畅。然而，缺点也很明显，如果中央指挥系统出现问题，那么整个城市的交通都可能会受到影响，导致严重的交通拥堵。</p></blockquote></li><li><p>微内核</p><p>微内核是小而美的服务商。</p><p>微内核，只<strong>提供最基本的服务</strong>，如进程调度、内存管理等。</p><p>设计优点是<strong>结构简单</strong>，容易理解和修改，如果一个服务出现问题，也<strong>不会影响</strong>到其他服务。</p><p>设计缺点是<strong>性能较低</strong>，因为服务之间的调用需要在内核和用户空间之间进行切换，效率较低。</p><p>微内核提供了一种<strong>消息传递</strong>机制，让<strong>系统程序</strong>和<strong>用户程序</strong>进行交互。</p><blockquote><p>就像一个城市的交通系统中，只有最基本的道路和桥梁是由中央指挥系统控制，其他的如公交、出租车等都是由各自的调度系统进行管理。这种方式的优点是稳定性好，因为即使一个服务出现问题，也不会影响到其他的服务。然而，缺点是效率较低，因为服务之间的调度需要在内核和用户空间之间进行切换，这就像各个调度系统之间需要进行协调，导致交通运输的效率降低。</p></blockquote></li></ul><p>​操作系统代表：<strong>Mach</strong>、<strong>鸿蒙</strong>。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240626221142031.png" alt="image-20240626221142031" style="zoom: 80%;" /></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ol><li>在现代操作系统中，最里层是硬件，最外层是用户，中间是<strong>软件系统（不是操作系统）</strong></li><li>操作系统执行完中断后，会<strong>采取调度算法</strong>从就绪队列中选择下一个进程（<strong>不是被打断的进程</strong>）</li><li>在操作系统的分层管理中，<strong>处理器管理</strong>是在<strong>最内层</strong>，<strong>作业管理</strong>是<strong>最外层</strong>。</li><li>在层次结构中，<strong>外层依赖于内层</strong>。</li></ol><h2 id="补充-中断和异常"><a href="#补充-中断和异常" class="headerlink" title="补充 中断和异常"></a>补充 中断和异常</h2><p>中断分成<strong>硬件中断</strong>和<strong>软件中断</strong>。</p><ul><li>硬件中断：就是平时讲的中断。</li><li>软件中断：分成异常和系统调用(system call)。</li></ul><p>前面介绍的<strong>陷阱是异常的一种</strong>。</p><p>区别：</p><ul><li>来源：<ol><li>中断：外设</li><li>异常：用户的程序</li><li>系统调用：用户的程序</li></ol></li><li>响应方式：<ol><li>中断：异步</li><li>异常：同步</li><li>系统调用：同步</li></ol></li><li>当前指令：<ol><li>中断：与当前指令无关</li><li>软件中断：与当前指令有关</li></ol></li></ul><p>cpu每执行完一条指令就去查看有没有中断信号。</p><p>内核态 to 用户态：执行完特权指令后操作系统主动让出cpu资源</p><p>用户态 to 内核态：只能依靠中断，任意三种中断都可以转换成内核态</p><p>中断是计算机<strong>实现并发</strong>的原因。</p><p><a href="https://blog.csdn.net/qq_26553393/article/details/122239406">1.1.5 中断的概念和作用、内部中断、外部中断、中断机制的基本原理_中断的定义-CSDN博客</a></p><h2 id="第三章-进程"><a href="#第三章-进程" class="headerlink" title="第三章 进程"></a>第三章 进程</h2><h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><p>进程是<strong>执行的程序</strong>。</p><p>一个进程由 <strong>程序</strong>、<strong>数据集合</strong>、<strong>PCB</strong>组成。</p><p>我们强调，程序本身不是进程。程序是<strong>被动实体</strong>（可执行文件），进程是<strong>活动体</strong>。</p><blockquote><p>当一个可执行文件加载到内存时，程序变成进程。</p></blockquote><p>进程是cpu<strong>分配资源</strong>的最小单位。</p><p>一个程序可以是<strong>多个进程</strong>。</p><ul><li><p><strong>进程的组成</strong></p><p>由<strong>栈</strong>、<strong>堆</strong>、<strong>数据段</strong>、<strong>文本段</strong>、<strong>PC</strong>等等组成。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627130158500.png" alt="image-20240627130158500"></p></li><li><p><strong>进程的状态</strong></p><ol><li>新建：进程在被创建。</li><li>运行：进程在被执行中。</li><li>等待：进程在等待发生某个事件（如IO完成）。</li><li>就绪：等待被调度。</li><li>结束：进程已经完成。</li></ol><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627131031378.png" alt="image-20240627131031378"></p><p>图上的中断(interrpt)应该是<strong>硬件中断</strong>，例如像**时间片(timer)**到了，进程就会到就绪队列。</p><p>当一个进程申请了IO，这个进程就会<strong>到等待队列</strong>，等待IO完成再回到就绪队列等待调度。(可以和第一章笔记的IO结构对应着看)</p><p><em><strong>需要掌握：在什么情况下进程的状态会发生什么变化。</strong></em></p></li><li><p><strong>挂起进程</strong></p><p>简单来说，就是<strong>暂时被淘汰出内存</strong>的进程；被操作系统<strong>调出主存到磁盘</strong>里，当主存内存空间<strong>足够</strong>再调用回主存。</p></li><li><p><strong>PCB(进程控制块)</strong></p><p>是<strong>进程的表示</strong>，PCB<strong>存于内核内存</strong>中。</p><p>由以下部分组成：</p><ol><li><strong>进程状态</strong>：当前进程的状态是什么。</li><li>**进程编号(PID)**：进程对应的一个唯一的编号。</li><li><strong>PC</strong>：表示当前进程执行到哪一条指令。(如果是<strong>多线程可能有多个PC</strong>)</li><li><strong>CPU寄存器</strong></li><li><strong>CPU调度信息</strong>：例如像当前进程的优先级。</li><li>…<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627133213907.png" alt="image-20240627133213907" style="zoom: 67%;" /></li></ol><p><strong>getpid()的原理</strong>：用户调用getpid()函数 – 操作系统转到内核态 – 访问当前进程PCB的PID – 转回用户态并返回PID。</p></li></ul><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>因为每个进程可以有多个PC(多线程)，所以每个进程可以执行多个线程。</p><p>每个线程<strong>共享</strong>进程的<strong>堆</strong>、<strong>文本段</strong>、<strong>数据段</strong>。</p><p>每个进程<strong>独立</strong>的有<strong>PC</strong>、<strong>栈</strong>、<strong>寄存器</strong>。</p><p>之后会详细介绍。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627134128488.png" alt="image-20240627134128488"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>选择<strong>下一个</strong>在CPU上运行的进程。</p><p>目标：<strong>最大化CPU的利用率</strong>。</p><p>调度队列：分为<strong>就绪队列</strong>和<strong>等待队列</strong>。</p><ol><li><p>就绪队列：里面存放着等待被调度的进程。</p></li><li><p>等待队列：等待某件事情(IO)发生的进程。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627135342369.png" alt="image-20240627135342369"></p></li></ol><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>中断机制会<strong>导致CPU从执行当前的任务变成执行系统内核的任务</strong>，所以当中断发生时，我们要<strong>保存好</strong>当前执行的任务，以便在处理中断之后能够复原当前的任务。</p><p>把进程的<strong>PCB</strong>称为进程的<strong>上下文</strong>。</p><p><strong>上下文切换步骤</strong>：</p><ol><li><strong>保存</strong>当前的上下文(PCB)。</li><li><strong>加载</strong>新的要执行的进程上下文。</li></ol><p>上下文切换是一个<strong>单纯的开销</strong>。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627142142920.png" alt="image-20240627142142920"></p><ul><li><p>模式切换 VS 上下文切换</p><p>模式切换不一定会上下文切换：例如当发生中断之后，模式切换成内核态，可是当前进程没变。</p><p>模式切换开销比上下文切换小。</p></li></ul><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><p>利用<strong>PID</strong>来标识进程。</p><p>父进程的PID<strong>小于</strong>子进程的PID。</p><ul><li><p><strong>进程创建</strong></p><p>使用fork()函数来创建新进程。并且父进程的fork()返回值为<strong>子进程的PID</strong>。子进程的fork()返回值为<strong>0</strong>。并且子进程拥有和父进程一样的资源。</p></li><li><p><strong>进程执行</strong></p><p>可以父进程和子进程<strong>并发执行</strong>或者父进程<strong>使用wait()等待子进程执行完</strong>再执行。</p><p>值得一提的是，如果子进程<strong>调用</strong>了exec()的函数，那么会<strong>新创一个program</strong>，把exec()下的代码全部<strong>覆盖</strong>了。</p></li><li><p><strong>进程终止</strong></p><p>使用wait()或者exit()。像下图的例子，父进程使用wait()阻塞自己，等待子进程完成执行后调用exit()像父进程发出一个signal，然后父进程再执行。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627144014620.png" alt="image-20240627144014620"></p></li></ul><p>进程创建的小题目：<a href="https://blog.csdn.net/donaldsy/article/details/108622940">当fork遇上for循环的问题分析 &amp; fork函数_循环中使用forok-CSDN博客</a> 要记得，fork()之后子进程连buffer内的数据也复制了。</p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>父进程<strong>没有调用</strong>wait()就终止了，导致子进程的系统资源无法回收。成孤儿了。</p><p>解决方法：操作系统的根进程会<strong>定期调用wait()<strong>函数，</strong>回收</strong>孤儿进程的资源。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>当子进程终止可是父进程**还未调用wait()**函数回收资源。</p><p>通常所有进程终止的瞬间都会过渡到僵尸进程，但是一般只是短暂的存在，当父进程调用wait()就会回收资源了。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程根据与其他进程之间的关系分成<strong>独立</strong>和<strong>协作</strong>的。</p><ul><li>独立进程：不与其他进程共享数据的进程。</li><li>协作进程：可以被其他进程影响或者影响其他进程的进程。</li></ul><p>协作进程之间的通信分为 <strong>共享内存</strong>和<strong>消息传递</strong>。</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627192901128.png" alt="image-20240627192901128" style="zoom:80%;" /><ul><li><p>共享内存</p><p>希望通信的进程之间共享的内存区域，通信双方需要同时映射共享内存到自己的进程内。</p><p>通信是由用户自己控制的，不是由操作系统控制。</p><ul><li><p><strong>生产者-消费者问题</strong></p><p>生产者和消费者进程共享一个buffer(循环数组)和两个逻辑指针in(指向buffer的下一个空位)和out(指向buffer的第一个满位)。</p><ul><li>生产者进程代码：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627193530453.png" alt="image-20240627193530453"></li><li>消费者进程代码：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627193556549.png" alt="image-20240627193556549"></li></ul></li><li><p>Posix系统中常用的共享内存的函数：</p><ul><li>shm_open：创建一个共享的内存区域对象。</li><li>ftruncate：给这个对象分配内存。</li><li>mmap：在自己的代码内对这个共享内存区域对象进行映射。</li></ul></li></ul></li><li><p><strong>消息传递</strong></p><p>基本操作为<strong>send</strong>(发送消息)和<strong>receive</strong>(接收消息)。</p><ul><li><p><strong>直接通信</strong></p><p>进程之间必须<strong>明确</strong>命名： </p><ul><li>发送（P，消息）–向进程P发送消息 </li><li>接收（Q，消息）–从流程Q接收消息</li></ul></li><li><p><strong>间接通信</strong></p><p>通过<strong>邮箱</strong>或者端口来发送和to接收消息 </p><ul><li><p>每个邮箱都有一个唯一的id </p></li><li><p>发送（A，消息）–将消息发送到邮箱A</p></li><li><p>接收（A，消息）–从邮箱A接收消息</p></li></ul></li></ul></li><li><p><strong>同步</strong></p><p>消息传递可以是<strong>阻塞</strong>或者是<strong>非阻塞</strong>的。</p><ul><li><p>阻塞发送：在接收进程或者邮箱收到消息之前，发送进程阻塞。</p></li><li><p>阻塞接收：在消息可用之前，接收进程将被阻塞。</p></li><li><p><strong>交会</strong>：若发送和接收两个操作都是阻塞的，则双方进程会产生一个交会。</p></li><li><p>非阻塞操作是<strong>异步</strong>的。</p></li></ul></li><li><p><strong>管道</strong></p><p>把一个进程连接到另一个进程的一个数据流称为一个“管道”，<strong>通常是用作把一个进程的输出通过管道连接到另一个进程的输入</strong>。</p><p>管道内的<strong>接收</strong>和<strong>发送</strong>信息操作都是<strong>阻塞</strong>的。</p><ul><li><p><strong>普通管道</strong></p><p>无法从创建它的进程<strong>外部访问</strong>。通常是父进程用普通管道和子进程进行沟通。<strong>只能用于血缘关系的进程</strong>。</p><p>普通管道数据的流向是<strong>单向</strong>的。要么父进程写，子进程读；要么父进程读，子进程写。</p><p>使用<strong>pipe()函数</strong>创建管道。</p><p><strong>注意：父、子进程哪个功能不用就关闭。</strong>例如：<strong>父进程关闭fd[0]（读端）,子进程关闭fd[1]（写端）</strong></p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627201459408.png" alt="image-20240627201459408" style="zoom:67%;" /></li><li><p><strong>命名管道</strong></p><p>命名管道比普通管道功能更强大。</p><p>通信是<strong>双向</strong>的。</p><p>通信进程之间不需要父子关系。</p><p>使用**mkfifo()**创建一个文件来交换数据。</p></li></ul></li><li><p><strong>套接字</strong></p><p>每个套接字都由<strong>IP地址</strong>和<strong>端口号</strong>组成。</p><p>套接字161.25.19.8:1625：IP：161.25.19.8，端口：1625。</p></li></ul><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ol><li><p>共享内存和消息传递的区别</p><p>效率：共享内存更好</p><p>安全：消息传递更好</p><p>传输数据大小：共享内存更大</p><p>实现难度：共享内存更难实现</p></li><li><p>互相举命名管道和普通管道更好的例子</p><p><strong>普通管道更好</strong>：父子进程间通信的时候，可以不用调用mkfifo去创建文件。</p><p><strong>命名管道更好</strong>：当两个无关系的进程需要通信时，很明显命名管道更好。</p></li><li><p>shell中的’|’是普通管道还是命名管道</p><p>普通管道</p></li><li><p>fork()之后，父进程和子进程有什么是共享的，什么是不共享的。</p><p>答：共享的有代码段和已经打开的文件；不共享的有内存空间(写时复制)。</p></li></ol><h2 id="第四章-多线程编程"><a href="#第四章-多线程编程" class="headerlink" title="第四章 多线程编程"></a>第四章 多线程编程</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是<strong>CPU调度</strong>和<strong>上下文切换</strong>的基本单位。</p><p>进程 &#x3D; <strong>共享内存</strong> + <strong>多个线程</strong>。</p><p>进程是相互独立的，而线程是不独立的(共享数据)。</p><p>线程和线程间关系</p><ul><li>独立：CPU寄存器、栈、PC、TID。</li><li>共享：进程的数据段、堆、文本段、文件。</li></ul><p>线程对比进程更加<strong>经济</strong>。</p><p>多线程：操作系统在单个进程内支持多个线程并发执行的能力。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627204511454.png" alt="image-20240627204511454"></p><p><strong>简单来说，就是把一个应用程序(进程)的任务拆分了多个小任务，变成一个线程执行一个小任务。</strong></p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li><p><strong>并发</strong>：在单核上多个线程<strong>交互</strong>的执行。制造并行的假像。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627205151645.png" alt="image-20240627205151645"></p></li><li><p><strong>并行</strong>：在多核上<strong>同时执行</strong>多个线程。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627205226462.png" alt="image-20240627205226462" style="zoom:150%;" /></p></li><li><p>区别：可以看出，<strong>单核是不能并行</strong>的。并行一定是并发的，但并发不一定是并行的。</p></li><li><p>Amdahl定律：并行下计算效率提升多少。<br>$$<br>speedup &#x3D; \frac{1}{S + \frac{1 - S}{N}}<br>$$<br>S是串行执行的部分，1 - S是并行执行的部分，N为核数。</p></li><li><p>数据并行：将相同的数据的子集分布在多个核上，并在核上执行相同操作。**(每个核数据不一样，任务一样)**</p><p>例子：考虑对内存大小为N的数组进行求和</p><p>假设对于双核系统，在核A上计算下标为0到N&#x2F;2的和，在核B上计算下标为N&#x2F;2 + 1到N的和。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627210817105.png" alt="image-20240627210817105"></p></li><li><p>任务并行：将任务而不是数据分配到多个计算核心，每个线程执行唯一的操作，不同线程可以操作相同的数据，也可以操作不同的数据。**(每个核数据一样，任务变了)**<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627210839397.png" alt="image-20240627210839397"></p></li></ul><h3 id="线程控制块-TCB"><a href="#线程控制块-TCB" class="headerlink" title="线程控制块(TCB)"></a>线程控制块(TCB)</h3><p>由<strong>TID</strong>、<strong>线程状态</strong>、<strong>PC</strong>、<strong>CPU寄存器</strong>、<strong>指向父进程的指针</strong>组成。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627211127882.png" alt="image-20240627211127882"></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>线程分成<strong>用户级线程</strong>和<strong>内核级线程</strong>。</p><ul><li><p>用户级线程</p><p>所有的线程管理工作都由<strong>应用程序</strong>负责 (包括进程切换)。</p></li><li><p>内核级线程</p><p>线程管理工作由<strong>内核</strong>负责。</p></li><li><p>用户级线程通过<strong>调用内核级线程</strong>使用硬件资源。</p></li><li><p><strong>多对一模型</strong></p><ul><li><p>多个用户级线程（ULTs）映射到一个内核级线程（KLT）。</p></li><li><p>在该模型中，线程的切换可以在<strong>用户态</strong>下完成，无需操作系统的干预。</p></li><li><p><strong>操作系统感受不到用户级线程的存在。</strong></p></li><li><p>如果用户级线程被阻塞，那么<strong>整个进程都会被阻塞</strong>。这是因为从操作系统来看，只有内核一个进程，所以如果这个线程被阻塞，内核会把整个进程都阻塞。</p></li><li><p>无法利用多核处理器的并行性，因为从操作系统来看只有一个线程。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627214628856.png" alt="image-20240627214628856"></p></li></ul></li><li><p><strong>一对一模型</strong></p><ul><li><p>每个用户级线程（ULT）映射到一个独立的内核级线程（KLT）。</p></li><li><p>线程创建、管理和调度都由内核负责。</p></li><li><p>一个线程阻塞不会影响其他线程，真正并行执行。</p></li><li><p>线程创建和切换开销较大，因为涉及内核操作。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627214741776.png" alt="image-20240627214741776"></p></li></ul></li><li><p><strong>多对多模型(结合上面两个的优点)</strong></p><ul><li>多个用户级线程（ULTs）映射到多个内核级线程（KLTs）。</li><li>线程调度可以在用户空间和内核空间之间共享，提供更高的灵活性和效率。</li><li>用户级线程的创建和管理灵活，同时可以利用多处理器并行能力。</li><li>一个用户级线程阻塞时，其他线程可以继续执行。</li></ul></li></ul><h3 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h3><p>两种实现：</p><ol><li>在用户空间提供一个没有system call的库。（这意味着创造线程只是调用一个函数）</li><li>实现操作系统支持的内核级的库。</li></ol><p><strong>Pthreads库</strong></p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627215446976.png" alt="image-20240627215446976"></p><p>fork()<strong>全局变量不共享</strong>，pthread_create()<strong>全局变量共享</strong>。</p><p>就是线程内改了主线程的变量，主线程也会一起改动，因为数据是共享的。</p><p>通常在主线程调用pthread_join()类似父进程调用wait()。</p><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><ul><li><p>线程调用fork()函数：有两种情况，第一种<strong>复制所有线程</strong>；第二种<strong>只复制调用fork()的线程</strong>。</p></li><li><p>线程调用exec()函数：除了调用exec()的线程之外，其他所有线程都将立即消失。并且直接执行exec()函数。</p></li><li><p>信号处理：</p><ul><li>信号用于通知进程某个特定事件已经发生。</li><li>信号传送给进程<ul><li>使用kill(pid, signal)来传递信号</li></ul></li><li>在多线程的进程内，信号传递有三个选项：<strong>传给所有线程</strong>、<strong>传给某些线程</strong>、<strong>传给某个线程</strong>。<ul><li>线程传递信号使用pthread_kill(tid, signal)信号</li></ul></li></ul></li><li><p>线程撤销：在线程结束之前终止它。调用pthread_cancel(tid)这个函数终止线程。</p></li></ul><h3 id="隐式多线程"><a href="#隐式多线程" class="headerlink" title="隐式多线程"></a>隐式多线程</h3><p>随着线程数量的增加，程序的正确性变得越来越困难。</p><p>所以希望线程的创建和管理<strong>不是由程序员</strong>自己控制，而是交由<strong>编译器</strong>自动处理。</p><p>以下是几个方法：</p><ul><li><p>线程池：</p><p>主要思想：在进程开始的时候创建一定数量的线程，并加到池里等待工作。</p><p>使用现有线程处理请求通常比创建新线程快一点；允许将应用程序中的线程数限制到池的大小。</p></li></ul><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ol><li><p>什么时候多线程编程性能比单线程低</p><p>答：当要处理的数据比较小时，多线程编程会因为频繁的上下文切换而导致性能比单线程差。</p></li><li><p>在什么情况下，采用多核多线程方法比单处理器系统的单线程提供更好的性能？</p><p>答：当任务可以被分成多个子任务时，很明显多线程性能更好；当碰到IO密集型的任务，单线程只能进行阻塞，可是多线程可以一个线程阻塞跑去执行另一个线程先。</p><p><a href="https://blog.csdn.net/weixin_44556968/article/details/108810650">多线程就一定比单线程快吗？_多线程一定比-CSDN博客</a></p></li><li><p>有可能并发但却无并行吗？</p><p>答：可能，例如时间片轮转算法，就是单核中不停切换，在单核中实现多任务并发，可是却没有并行。</p></li><li><p>什么是多道程序设计系统？</p><p>答：一次性把一批计算问题同时装入主存并行执行的系统，就叫做多道程序设计系统。</p></li><li><p>多道程序设计提高了系统的吞吐量．但可能会<strong>延长</strong>某些程序的执行时间。</p></li></ol><h2 id="第五章-进程调度"><a href="#第五章-进程调度" class="headerlink" title="第五章 进程调度"></a>第五章 进程调度</h2><h3 id="什么是进程调度？"><a href="#什么是进程调度？" class="headerlink" title="什么是进程调度？"></a>什么是进程调度？</h3><p>从进程的角度观看：进程总是在CPU执行和IO请求中来回切换。</p><p>进程调度：通过多道程序设计获得最大CPU利用率。</p><blockquote><p>简单来说，就是如果有个进程申请IO(等待)时，操作系统就调度一个进程接管CPU，使得CPU一直都是有活干的。</p></blockquote><h3 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h3><p>分成长程调度、中程调度、短程调度。</p><p>调度的频率：长程 &lt; 中程 &lt; 短程。</p><p>主要介绍**短程调度程序(分派程序)**：</p><ul><li>短程调度是指从<strong>就绪队列</strong>中选择一个或多个进程，将处理器分配给它们，以便立即执行。</li><li>分派程序包括：切换上下文、切换到用户模式(<strong>模式切换</strong>)、跳转到用户程序合适的位置，以便重启程序。</li><li>这个程序要尽可能的快，因为每次切换进程都要使用；分派程序停止一个进程而启动另一个可用线程的时间叫分派延迟(调度延迟)。</li></ul><h3 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h3><p>需要进行CPU调度的四种情况：</p><ol><li>运行态–阻塞态(发生IO请求)</li><li>运行态–就绪态(时间片轮转)</li><li>阻塞态–就绪态(IO完成)</li><li>进程终止</li></ol><p>如果调度只发生在第一和第四种情况的话，该CPU调度就是<strong>不可抢占式</strong>的；否则，称为<strong>可抢占式</strong>的。</p><p>在<strong>非抢占式调度</strong>下，一旦CPU分配给进程，进程<strong>将保持CPU</strong>， 直到<strong>终止</strong>或<strong>切换到等待状态释放CPU</strong>为止；</p><h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul><li><strong>CPU利用率</strong>：要让CPU尽可能的忙碌起来。</li><li><strong>吞吐量</strong>：在一个时间单元内，进程<strong>完成的数量</strong>。</li><li><strong>周转时间</strong>：从进程<strong>提交</strong>到<strong>完成</strong>的时间。</li><li><strong>等待时间</strong>：进程在就绪队列中等待被调度的时间之和。</li><li><strong>响应时间</strong>：对于交互系统，周转时间并不是最优准则；响应时间是系统提交请求到产生第一次响应的时间。</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><strong>要会画甘特图</strong></p><h4 id="先到先服务-FCFS"><a href="#先到先服务-FCFS" class="headerlink" title="先到先服务(FCFS)"></a>先到先服务(FCFS)</h4><ul><li><p><strong>非抢占</strong>的</p></li><li><p>使用<strong>FIFO队列</strong>实现</p></li><li><p>例子：turnaround time是<strong>周转时间</strong>，例如像P3是时刻2来到的，可是时刻30才完成，所以周转时间为28。</p></li></ul><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628112653761.png" alt="image-20240628112653761" style="zoom: 50%;" /><ul><li>例子：可以发现，<strong>不同的到达顺序</strong>结果会有很大的<strong>差异</strong>。</li></ul><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628112946884.png" alt="image-20240628112946884" style="zoom:50%;" /><h4 id="最短作业优先-SJF"><a href="#最短作业优先-SJF" class="headerlink" title="最短作业优先(SJF)"></a>最短作业优先(SJF)</h4><ul><li>可以是<strong>抢占</strong>的或者<strong>非抢占</strong>的</li><li><strong>最优的算法</strong></li><li>例子：<strong>非抢占</strong>的<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628113756942.png" alt="image-20240628113756942" style="zoom: 50%;" /></li><li>例子：<strong>抢占</strong>的 注意！等待时间是进程在就绪对列等待的时间(<strong>看P1等待时间</strong>)<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628115320441.png" alt="image-20240628115320441" style="zoom:50%;" /></li><li>观察到可抢占式的<strong>平均等待时间</strong>和<strong>平均周转时间</strong>都比非抢占式<strong>低</strong>，可是抢占式需要<strong>频繁上下文切换</strong>，会有不同的<strong>开销</strong>。</li></ul><h4 id="轮转调度-RR"><a href="#轮转调度-RR" class="headerlink" title="轮转调度(RR)"></a>轮转调度(RR)</h4><ul><li>为<strong>分时系统</strong>所设计的</li><li><strong>RR</strong> &#x3D; <strong>FCFS</strong> + <strong>抢占式</strong></li><li>每个进程给定一个较小的时间单位成为<strong>时间片</strong>，时间片用完后， CPU选择另外一个进程调度执行</li><li>如果进程的执行时间少于时间片，进程执行完直接释放CPU。</li><li>假设有n个进程，时间片长度为q，则每个进程等待获得下个CPU时间片的时间不会超过(n-1)*q时间。</li><li>假设有5个进程，时间片长度为20ms，则每个进程每100ms就会获得不超过20ms的CPU使用时间。</li><li>例子：            <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628121446945.png" alt="image-20240628121446945" style="zoom:50%;" /></li><li>RR和SJF对比，虽然RR表现不好，可是它可以实现并发，就是让每个作业都感觉自己被分配了CPU。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628121548619.png" alt="image-20240628121548619" style="zoom:67%;" /></li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>分成<strong>抢占式</strong>和<strong>非抢占式</strong>的。</li><li>CPU优先分配资源给具有最高优先级的进程。</li><li>SJF是一个特殊的优先级调度。</li><li>问题：可能会<strong>饥饿</strong>，就是某个进程优先级太低导致一直分配不到资源。</li><li>例子：           <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628163911802.png" alt="image-20240628163911802" style="zoom:50%;" /></li></ul><h4 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h4><ul><li><p>是<strong>优先级调度</strong>(队列间)与<strong>RR</strong>(队列内)结合。</p></li><li><p>通常**前台进程(与用户交互的进程)**会比后台进程优先级更高。</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628164530777.png" alt="image-20240628164530777" style="zoom:67%;" /></li></ul><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628164720837.png" alt="image-20240628164720837"></p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul><li>在支持线程的操作系统中，内核线程才是<strong>操作系统</strong>所调度的。</li><li>用户线程是由<strong>线程库</strong>管理的，内核并不知道。</li><li>用户线程 – 内核线程 – 硬件资源</li></ul><h4 id="用户线程调度"><a href="#用户线程调度" class="headerlink" title="用户线程调度"></a><strong>用户线程调度</strong></h4><p>采用<strong>进程竞争范围</strong>(PCS)：因为通常用户线程的竞争都是发生在<strong>同个进程</strong>内的。</p><h4 id="内核线程调度"><a href="#内核线程调度" class="headerlink" title="内核线程调度"></a>内核线程调度</h4><p>采用系统竞争范围(SCS)：与所有的线程(<strong>整个系统</strong>)竞争。</p><ul><li>API允许创建线程的时候选择哪种竞争范围：</li><li>PTHREAD_SCOPE_PROCESS：使用<strong>PCS</strong>调度来调度线程；</li><li>PTHREAD_SCOPE_SYSTEM：使用<strong>SCS</strong>调度来调度线程；</li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><ul><li><p>刚刚的讨论都是基于一个处理器的。</p></li><li><p><strong>非对称多处理</strong></p><ul><li>让其中一个处理器<strong>处理所有</strong>的调度决定、IO处理。</li><li>这样这个处理器会压力很大。</li></ul></li><li><p><strong>对称多处理(SMP)</strong></p><ul><li>每个处理器自我调度</li><li>所有进程可能处在一个<strong>共同的就绪队列</strong>或者<strong>每个处理器有自己的就绪队列</strong>。</li></ul></li><li><p>处理器亲和性</p><ul><li>尽量让进程一直运行<strong>在同一个处理器</strong>上。</li></ul></li></ul><h3 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h3><p>调度算法必须满足<strong>抢占式</strong>和<strong>优先级</strong>。</p><p>因为该系统要求<strong>高安全性</strong>和<strong>立马响应</strong>。</p><p>目标是最小化<strong>中断延迟</strong>和<strong>调度延迟</strong>。</p><ul><li><strong>中断延迟</strong>：是从CPU收到中断到中断处理程序开始的时间。</li><li><strong>调度延迟</strong>：调度程序从停止一个进程到开启一个新进程的时间</li></ul><p>实时系统分成软和硬。</p><ul><li><strong>软实时系统</strong><ul><li>保证<strong>关键进程比非关键进程先跑</strong></li><li>不保证在ddl内跑完</li></ul></li><li><strong>硬实时系统</strong><ul><li>保证一定在<strong>ddl内跑完</strong></li></ul></li></ul><p>实时系统的进程一般是具有<strong>周期性</strong>的。周期为<strong>p</strong>，截至时间是<strong>d</strong>。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628172910826.png" alt="image-20240628172910826"></p><p><strong>准入调度</strong>：保证进程完成，就承认进程；不能保证进程在ddl前完成，拒绝进程。</p><h4 id="单调速率调度"><a href="#单调速率调度" class="headerlink" title="单调速率调度"></a>单调速率调度</h4><ul><li><strong>抢占式</strong> + <strong>静态优先级</strong></li><li>进程的优先级为周期的倒数；即周期短的进程总是被优先执行。</li><li>由上一点可知，该调度是<strong>最优</strong>的。</li><li>例子：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628174047888.png" alt="image-20240628174047888"></li></ul><h4 id="最早截至期限优先调度"><a href="#最早截至期限优先调度" class="headerlink" title="最早截至期限优先调度"></a>最早截至期限优先调度</h4><ul><li><strong>抢占式</strong> + <strong>动态优先级</strong></li><li>进程的优先级为截止期限；即截至期限越近的进程总是被优先执行。</li><li>例子：   <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628174456118.png" alt="image-20240628174456118"></li></ul><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><ol><li><p>为什么区分io密集型进程和cpu密集型进程对调度程序是重要的？</p><p>答：可以资源利用率更大化，因为io密集型进程主要都是在执行IO，会执行比较少的计算；cpu密集型也一样。与此同时，io密集型进程(前台)主要都是与用户交互，所以需要优先去处理，才能给用户更好的体验，cpu密集型进程主要是后台进程。</p></li><li><p>什么是饥饿？</p><p>在优先级调度算法中，高优先级的进程总是优先执行。如果系统中不断有高优先级的进程到达，那么低优先级的进程可能永远无法获得CPU时间片，从而陷入饥饿状态。</p></li><li><p>下面哪种算法会导致饥饿：a. fcfs b.sjf c.rr d.priority schedule</p><p>答：最短作业和优先级会导致饥饿。</p></li><li><p>题目：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628185403693.png" alt="image-20240628185403693"></p><p>![f5eaa1eb0ca210a2da9c9ad41fe1bbe](C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\f5eaa1eb0ca210a2da9c9ad41fe1bbe.jpg)</p></li><li><p>题目：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628191710831.png" alt="image-20240628191710831"></p></li></ol><h2 id="第六章-同步"><a href="#第六章-同步" class="headerlink" title="第六章 同步"></a>第六章 同步</h2><h3 id="什么是同步"><a href="#什么是同步" class="headerlink" title="什么是同步?"></a>什么是同步?</h3><p>进程同步的主要任务是希望并发的进程们可以有效的<strong>共享资源</strong>和<strong>合作</strong>。</p><h3 id="什么是竞争条件？"><a href="#什么是竞争条件？" class="headerlink" title="什么是竞争条件？"></a>什么是竞争条件？</h3><p>多个进程<strong>并发</strong>且访问同一个<strong>共享数据</strong>，并且该共享数据的值<strong>与进程访问顺序有关</strong>。</p><p>甚至连两个线程并发执行count++指令都会出现竞争：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628194029709.png" alt="image-20240628194029709"></p><h3 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h3><p>每个进程都有一段代码，称为<strong>临界区</strong>。</p><p>临界区是并发进程中与共享资源有关的程序。</p><p>重要的是，<strong>当一个进程在它的临界区执行时，其他进程不能在他们的临界区执行</strong>。</p><p>临界区解决方案要包括以下三个要求：</p><ol><li><strong>互斥</strong>：如果进程P在临界区内执行，其他进程都不能在其临界区内执行。</li><li><strong>进步</strong>(无死锁)：要保证在临界区内的进程P有干活，就是<strong>临界区内的进程一定要有进展</strong>。这样等待的进程们不会无休止的等待。也可以理解成，如果没有进程在临界区内，需要选择一个进程进入临界区，并且这种选择不能无限推迟。</li><li><strong>有限等待</strong>：当一个进程提交了进临界区的请求，在该进程前进入临界区的进程存在上界。</li></ol><h4 id="Peterson解决方案-软件解决"><a href="#Peterson解决方案-软件解决" class="headerlink" title="Peterson解决方案(软件解决)"></a>Peterson解决方案(软件解决)</h4><ul><li><p>数据结构(共享)</p><ol><li>bool flag[2]：一个布尔类型数组，表示线程是否想进入临界区。</li><li>int turn：一个整型变量，表示哪个线程可以进入临界区。</li></ol></li><li><p>简单思想</p><p>就是把自己的flag设置为1，然后把turn设置为对方，让对方先进入临界区。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628200249825.png" alt="image-20240628200249825"></p></li></ul><h4 id="硬件解决方案"><a href="#硬件解决方案" class="headerlink" title="硬件解决方案"></a>硬件解决方案</h4><p>主要利用<strong>原子性</strong>(不可中断的指令)来实现。</p><p>以下两个是例子：</p><ul><li><p>test_and_set()  （函数实现是<strong>原子</strong>的）                 <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628205829894.png" alt="image-20240628205829894" style="zoom:67%;" /></p></li><li><p>compare_and_swap()（函数实现是<strong>原子</strong>的）                 <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628205933905.png" alt="image-20240628205933905" style="zoom:67%;" /></p></li></ul><h4 id="互斥-自旋-锁"><a href="#互斥-自旋-锁" class="headerlink" title="互斥(自旋)锁"></a>互斥(自旋)锁</h4><p>最<strong>简单解决临界区问题</strong>的工具。</p><p>要求一个进程进入临界区前要aquire()获得锁；退出临界区要release()释放锁。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628202411825.png" alt="image-20240628202411825" style="zoom:50%;" /></p><p>aquire()和release()操作必须是原子性的。</p><ul><li><p>aquire()                                                                                                                           <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628202236154.png" alt="image-20240628202236154" style="zoom:50%;" /></p></li><li><p>release()                                                                                                                       <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628202313057.png" alt="image-20240628202313057" style="zoom:50%;" /></p></li></ul><p>这种实现方法称为<strong>自旋锁</strong>。</p><p>可能会<strong>浪费CPU资源</strong>，可是自旋时<strong>没有上下文切换</strong>；如果等待锁的时间<strong>比较短</strong>，互斥锁还是很<strong>有用</strong>的。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>广义上的互斥锁。</p><p>信号量S定义为整数变量。</p><p>信号量分成**二进制信号量(0,1)<strong>和</strong>计数信号量(&gt;&#x3D;0)**。</p><p>只能通过**wait()(P)<strong>和</strong>signal()(V)**两个原子操作访问。</p><ul><li><p>wait()定义                                                                                                                                           <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628202939968.png" alt="image-20240628202939968" style="zoom:50%;" /></p></li><li><p>signal() 定义                                                                                                                                                    <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628203012713.png" alt="image-20240628203012713"></p></li></ul><p>可以发现这样的信号量实现也是<strong>自旋</strong>的。</p><p>为了避免自旋，我们可以创建一个跟信号量相关的等待队列，把发生阻塞的进程添加至这个队列(并把状态设置为阻塞)，然后让出CPU资源。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>是一种<strong>资源管理模块</strong>。</p><p>管程是一种高级语言的数据结构，跟信号量差不多，但是更好管理和控制。</p><p>管程内是共享数据和对这些数据进行操作。</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628211207864.png" alt="image-20240628211207864" style="zoom:67%;" /><p><strong>管程提供的功能</strong></p><ol><li>互斥访问：管程确保多个线程对共享变量的访问互斥，即同一时间只有一个线程可以访问共享资源，以避免竞态条件和数据不一致性问题。</li><li>条件等待和通知：管程提供了等待线程满足特定条件的机制，线程可以通过<strong>条件变量</strong>等待某个条件满足后再继续执行，或者通过条件变量通知其他线程某个条件已经满足。</li></ol><blockquote><p>可以将管程理解为一个房间，这个房间里有一些共享的资源，比如变量、队列等。同时，房间里有一个门，只有一把钥匙。多个线程或进程需要访问房间内的资源时，它们需要先获得这把钥匙，一次只能有一个线程或进程持有钥匙，进入房间并访问资源。其他线程或进程必须等待，直到当前持有钥匙的线程或进程释放钥匙，才能获得钥匙进入房间。</p><p>此外，管程还提供了条件变量，类似于房间内的提示牌。线程在进入房间后，如果发现某个条件不满足（比如队列为空），它可以通过条件变量来知道自己需要等待，暂时离开房间，并将钥匙交给下一个等待的线程。当其他线程满足了等待的条件（比如向队列中添加了元素），它可以通过条件变量通知告诉正在等待的线程，使其重新获得钥匙进入房间，并继续执行。</p></blockquote><p><strong>条件变量操作</strong></p><p>假设定义了condition x;</p><ol><li><p>wait()</p><p>调用x.wait()后会把调用操作的进程<strong>挂起</strong>。</p></li><li><p>signal()</p><p>调用x.signal()会<strong>恢复</strong>一个挂起进程。</p></li></ol><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628212233396.png" alt="image-20240628212233396" style="zoom:67%;" /><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><ul><li>数据结构(信号量)<ol><li>mutex 互斥锁</li><li>empty 缓冲区中空位数量</li><li>full 缓冲区中内容数量</li></ol></li><li>生产者代码                                                                                       <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628213812765.png" alt="image-20240628213812765"></li><li>消费者                                                                                            <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628213832802.png" alt="image-20240628213832802"></li></ul><h4 id="读者作者问题"><a href="#读者作者问题" class="headerlink" title="读者作者问题"></a>读者作者问题</h4><p>一个数据集在多个并发进程之间共享。</p><ul><li>Readers—仅读取数据集；它们不执行任何更新 </li><li>Writer — 既能读又能写</li></ul><p>问题–允许多个读者同时读取</p><ul><li>只有一个写者程序可以同时访问共享数据; </li><li>写者在访问数据时，不允许读者访问数据；</li></ul><p>主要考虑<strong>第一读者-作者问题</strong>(即读者优先)</p><ul><li><p>数据结构</p><ol><li>信号量 wsem &#x3D; 1(作者的锁)</li><li>信号量 x &#x3D; 1(用来更改readcount的锁)</li><li>整型 readcount &#x3D; 0</li></ol></li><li><p>作者代码                                                                                <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628214946284.png" alt="image-20240628214946284"></p></li><li><p>读者代码<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628215046422.png" alt="image-20240628215046422"></p><p>读者先看看有多少个读者进程，然后把读者进程数加加；如果是第一个读者进程，则申请作者的锁，如果作者还在写，第一个读者进程就阻塞；与此同时其他的读者进程(如果有的话)会被阻塞在x这个锁上；如果没有作者在写，则读者拿了作者的锁，作者就写不了了。</p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>哲学家坐在圆桌旁，中间放着一碗米饭。吃饭需要拿到左右2根筷子才能吃饭，然后在完成后释放。</p><p>对于5位哲学家，一碗饭（数据集）；信号量筷子[5]初始化为1；</p><p>代码如下：</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628215552486.png" alt="image-20240628215552486" style="zoom:67%;" /><p>很明显，上述代码可能会产生死锁，如果五个哲学家同时拿起自己左边的筷子，就会死锁；</p><ul><li>解决方案：只有当chop[i]和chop[i+1%N]为正时，才拿起自己左边的筷子(chop[i])。</li></ul><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><ol><li><p>信号量和互斥锁的区别</p><p>答：互斥锁是用在<strong>多线程互斥</strong>上的，主要是避免多个线程同时访问某个共享变量，即我访问了你就不能访问；信号量是用在<strong>多线程同步</strong>上的，它是多个进程互相告诉其他线程，我干了什么事情，让其他线程再执行某些动作。互斥锁是单个线程获取锁和释放锁，信号量是多个线程wait和signal。</p></li><li><p>互斥和同步的区别</p><p>答：同步侧重于协调线程的执行顺序，而互斥侧重于保护共享资源的安全访问。</p></li><li><p>进程间的互斥与同步分别表示了各个进程间的 (<strong>竞争与协作</strong> )。</p></li><li><p>记得是<strong>不同的信息</strong><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629161445985.png" alt="image-20240629161445985"></p></li></ol><h2 id="第七章-死锁"><a href="#第七章-死锁" class="headerlink" title="第七章 死锁"></a>第七章 死锁</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>当一组进程中的每个进程都在等待某事件(请求资源)，而仅有该组进程中被阻塞的其他进程可以触发某事件，就称为死锁。                                                                              <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629133258736.png" alt="image-20240629133258736"></p><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><p>死锁有四个必要条件：</p><ol><li><strong>互斥</strong>：一次只有一个进程使用一个资源, 其他进程不能访问分配给其他进程 的资源；</li><li><strong>非抢占</strong>：不能强行抢占进程已占有的资源；</li><li><strong>占有并等待</strong>：当一个进程等待其他进程时，继续占有已分配的资源；</li><li><strong>循环等待</strong>：存在一个闭合的进程链， 每个进程至少占有此链中下一个进程所需的一个资源；</li></ol><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><ul><li>P为进程，R为资源，R的小点数量为该种资源R的数量。</li><li>如果是P指向R，代表进程P申请资源R。</li><li>如果是R指向P，代表进程P获得资源R。                                                                         <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629135150815.png" alt="image-20240629135150815"></li></ul><p>如果<strong>无环</strong>则必定<strong>不会存在死锁</strong>。</p><p>如果<strong>有环</strong>则<strong>可能发生死锁</strong>。</p><p>如果<strong>有环</strong>且<strong>每个资源只有一个实例</strong>，<strong>必定发生死锁</strong>。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629135517156.png" alt="image-20240629135517156"></p><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><p><strong>鸵鸟算法</strong>：完全忽略死锁这个问题，并假设系统永远不会出现死锁。</p><ul><li>死锁避免：银行家算法，在分配资源前得到当前使用资源的额外信息，再判断是否分配资源。</li><li>死锁预防：打破死锁四个必要条件的一个。</li><li>死锁检测：利用检测算法检测是否存在死锁。</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>互斥、占有并等待、非抢占都比较难打破。</p><ul><li><p>打破<strong>互斥</strong></p><p>共享数据不互斥就不会有死锁了</p></li><li><p>打破<strong>占有并等待</strong></p><p>要求请求其他资源时，一定不能获得资源。</p></li><li><p>打破<strong>非抢占</strong></p><p>假设进程A申请资源a需要等待，则进程A的资源可以被其他进程抢占。</p></li><li><p>打破<strong>循环等待</strong></p><p>把所有的资源类型进行一个递增的排序，并且要求进程申请资源的时候以递增顺序。</p></li><li><p>缺点</p><p>系统性能差，因为每次获取资源都要顺序。</p></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>需要知道每个进程的每种类型资源的最大声明数量。</p><ul><li><p>安全状态</p><p>是指系统能够按某种<strong>进程序列</strong>为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利的执行完成。</p><p>进程序列被称为<strong>安全序列</strong>。</p></li><li><p>非安全状态</p><p>不存在安全序列就称为非安全状态。</p></li></ul><p><strong>安全状态</strong>一定<strong>没死锁</strong>；<strong>非安全状态可能有死锁</strong>。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629142003333.png" alt="image-20240629142003333" style="zoom:67%;" /></p><h5 id="银行家算法-我说必考"><a href="#银行家算法-我说必考" class="headerlink" title="银行家算法(我说必考)"></a>银行家算法(我说必考)</h5><ul><li>每个进程都必须先验地给出最大需求资源的数量；</li><li>当进程请求资源时，如果不能进入安全状态，它必须等待；</li><li>当一个进程获得所有资源时，它必须在有限的时间内返回它们；</li></ul><p>假设有n个进程和m种资源</p><p>存在MAX矩阵、已分配allocate矩阵、还需要Need矩阵、available向量。</p><p>时间复杂度为<strong>O(n^2 * m)</strong></p><p><strong>算法流程</strong>：</p><ol><li>合理性检查：检查请求是否小于available向量。</li><li>试探性分配：假设分配资源后，看看是否处于安全状态；如果是安全状态，则分配；如果是不安全状态，回到一开始的值。</li></ol><ul><li>死锁避免缺点：必须要提前声明每种类型资源的最大申请数。</li></ul><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>死锁检测算法，和银行家差不多。</p><ul><li><p>死锁恢复</p><p>当检测到死锁时，如何恢复。</p><ol><li>终止所有死锁进程：代价很大</li><li>一次终止一个进程，直到解决死锁问题。</li><li>不断抢占一些进程的资源以便给其他进程使用，直到打破死循环。</li></ol></li></ul><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><ol><li><p>饥饿和死锁的区别？</p><p>答：饥饿是一直分配不到资源，例如在优先级调度中，低优先级一直被高优先级的进程抢占；死锁是一组进程在相互等待组内其他进程的资源。死锁一定是饥饿，饥饿不一定是死锁。</p></li><li><p>可抢占的资源分配策略可以避免死锁(死锁预防)，但是只适用于<strong>主存和处理器</strong>。</p></li><li><p>什么是相关临界区？在进程并发中与涉及相同共享资源的程序段。</p></li></ol><h2 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h2><p>CPU可以直接访问的通用存储是<strong>内存</strong>和<strong>CPU内的寄存器</strong>。</p><p>程序必须从(<strong>磁盘</strong>)放入<strong>内存</strong>，CPU才能运行。</p><h3 id="基地址和限制地址"><a href="#基地址和限制地址" class="headerlink" title="基地址和限制地址"></a>基地址和限制地址</h3><p>每个进程都需要一个单独的内存空间。</p><p>为每个进程提供一个<strong>基地址寄存器</strong>和<strong>限制寄存器</strong>。                                              <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629193815616.png" alt="image-20240629193815616" style="zoom: 67%;" /></p><p>CPU寻址访问流程：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629194016757.png" alt="image-20240629194016757" style="zoom:67%;" /></p><h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>通常，程序被放在磁盘上。如果执行程序，则需要把程序调入内存。</p><p>调入内存时，需要把程序”<strong>绑定</strong>“在某个内存地址。</p><p>绑定地址可以在<strong>编译时</strong>、<strong>加载时</strong>、<strong>执行时</strong>进行。</p><ul><li><p><strong>编译</strong>时绑定</p><p>如果在编译程序的时候，就已经<strong>知道</strong>进程在内存的地址，那么编译器可以生成<strong>绝对代码</strong>。如果内存地址更改，则需要<strong>重新编译代码</strong>。</p></li><li><p><strong>加载</strong>时绑定</p><p>如果在编译程序的时候，不确定进程的地址，编译器生成<strong>可重定位代码</strong>，绑定拖到加载时。如果地址发生更改，程序要重新加载。</p></li><li><p><strong>执行</strong>时绑定</p><p>如果程序在执行的时候要从内存中移动，那么绑定要等到执行的时候才进行。(需要硬件支持)</p></li></ul><h3 id="逻辑地址空间和物理地址空间"><a href="#逻辑地址空间和物理地址空间" class="headerlink" title="逻辑地址空间和物理地址空间"></a>逻辑地址空间和物理地址空间</h3><p>CPU生成的地址为虚拟地址。</p><p>硬件看到的地址为物理地址。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629200043490.png" alt="image-20240629200043490"></p><h3 id="内存管理单元-MMU"><a href="#内存管理单元-MMU" class="headerlink" title="内存管理单元(MMU)"></a>内存管理单元(MMU)</h3><p>CPU输入逻辑地址到MMU转换出物理地址。</p><p>考虑下面一个简单的例子，设一个重定位寄存器(值为14000)，输入一个逻辑地址346，转换出物理地址为14346。                                    <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629200529930.png" alt="image-20240629200529930" style="zoom:67%;" /></p><p>站在用户角度，内存空间为(0 ~ Max)(逻辑地址)，实际上时(R ~ R + Max)(物理地址)。</p><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>假设如果要整个程序和数据都在内存内才能执行，内存空间利用率不高。</p><p>动态加载就是以<strong>可重定位代码</strong>保存在磁盘内。</p><p>只有一个程序被需要的时候，才会被加载。</p><blockquote><p>例如一个2000行的代码，里面某几行调用了一个函数，那么一开始这个函数可以不在主存内，直到调用这个函数再把该函数的代码调入主存。而不是一开始把2000行代码全都调入主存，浪费内存空间。</p></blockquote><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>进程必须要在内存执行，不过可以把暂时不用的进程”<strong>交换</strong>“到备份存储(磁盘)中，这样实现可能让所有进程的物理空间大于真实的物理空间。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629201419571.png" alt="image-20240629201419571" style="zoom:80%;" /></p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><p>整个进程的内存是<strong>连续</strong>的。</p><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>先把内存空间划分成多个”区”，然后每个区一个进程。划分的”区”可以是<strong>一样</strong>大的或者<strong>不等大</strong>的。</p><p>一般采用<strong>顺序分配</strong>。</p><p>会<strong>有内部碎片</strong>。</p><p>缺点：因为区数是一开始就决定好的，不够灵活。             <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629202832967.png" alt="image-20240629202832967" style="zoom:67%;" /></p><h4 id="可变分区-蔡国扬实验"><a href="#可变分区-蔡国扬实验" class="headerlink" title="可变分区(蔡国扬实验)"></a>可变分区(蔡国扬实验)</h4><p>使用一个表记录<strong>可用内存</strong>和<strong>已用内存</strong>。</p><p>会<strong>有外部碎片</strong>。</p><ul><li>首次适应：分配<strong>首个</strong>满足的空间给进程。</li><li>最优适应：分配最小的满足的空间给进程。</li><li>最差适应：分配最大的空间给进程。</li></ul><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629203244118.png" alt="image-20240629203244118"></p><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><ul><li><p>内部碎片</p><p>存在于进程内存内部。</p></li><li><p>外部碎片</p><p>存在于进程内存之间。</p></li></ul><p>解决方式：把所有的空闲的空间通过移动结合成一大块可用内存空间。</p><h3 id="分段-不连续内存分配"><a href="#分段-不连续内存分配" class="headerlink" title="分段(不连续内存分配)"></a>分段(不连续内存分配)</h3><p><strong>没有内部碎片</strong>，<strong>有外部碎片</strong>。</p><p>把程序分成多个段，例如<strong>代码</strong>、<strong>全局变量</strong>、<strong>堆</strong>、<strong>栈</strong>等等。</p><p>每个段的<strong>大小不一</strong>，并且不需要<strong>连续存储</strong>。</p><p>逻辑地址由<strong>段号</strong>和<strong>偏移</strong>组成。(需要检查偏移是否小于limit值)<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629204555029.png" alt="image-20240629204555029" style="zoom:80%;" /></p><h3 id="分页-不连续内存分配"><a href="#分页-不连续内存分配" class="headerlink" title="分页(不连续内存分配)"></a>分页(不连续内存分配)</h3><p><strong>没有外部碎片，有内部碎片</strong>。</p><p>进程的物理地址空间可以是<strong>不连续</strong>的；</p><p>把物理空间分成大小相同的<strong>帧</strong>；逻辑空间分成大小相同的<strong>页</strong>。页和帧大小是一样的。</p><p>如果执行一个进程需要n个页，在物理内存空间需要对应有n个帧。</p><p>CPU生成的逻辑地址由<strong>页码</strong>和<strong>页偏移</strong>组成 。                                <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629205556712.png" alt="image-20240629205556712" style="zoom:50%;" /><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629212226640.png" alt="image-20240629212226640"></p><p>物理地址转换：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629205808679.png" alt="image-20240629205808679" style="zoom:80%;" /></p><ul><li><p>页表：保存在内存中，并且使用一个<strong>页表基址寄存器</strong>指向页表地址。</p></li><li><p>在这种情况下，访问数据需要两次访存。(第一次是查页表拿数据地址，第二次是取数据)</p></li></ul><h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>采用了<strong>缓存</strong>的思想。</p><p>TLB每一项由<strong>页码</strong>和<strong>帧码</strong>组成。页表只由<strong>帧码</strong>组成(把页码当下标)。</p><p>当CPU产生一个逻辑地址后，如果该逻辑地址的页码存在于TLB，则直接找到对应的帧码，然后执行。(<strong>访存一次</strong>)</p><p>若页码不在TLB中(TLB miss)，则按照上面，<strong>需要访存两次</strong>；并且把这次逻辑地址的页码加入TLB。(时间局部性)<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629211338718.png" alt="image-20240629211338718"></p><ul><li>有效内存访问时间：<br>$$<br>\begin{equation}<br>\text{Time} &#x3D; P \times T_m + (1 - P) \times 2  T_m<br>\end{equation}<br>$$<br>Tm是访存时间，P为TLB命中率。</li></ul><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>在页表条目中增加一个”有效位”。                                                              <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629211926499.png" alt="image-20240629211926499" style="zoom:67%;" /></p><h3 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h3><p>假设虚拟内存空间位32位，页大小为12位，那么就有2^20个页，假设每个页表条目为4Byte，那么页表需要4MB存储。我们不想在主存中为每个进程都连续分配4MB存储页表。</p><h4 id="分层分页"><a href="#分层分页" class="headerlink" title="分层分页"></a>分层分页</h4><p>假设为k层页表，访问一个数据需要访存k + 1次。</p><p>像刚刚的假设，我们可以将刚刚的页表拆分成两个页表。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629213327704.png" alt="image-20240629213327704"></p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629213408488.png" alt="image-20240629213408488"></p><p>假设32位虚拟地址为0x12345678，分层分页的具体过程如下：</p><ol><li><strong>虚拟地址分解</strong>：<ul><li>页目录索引：0x12</li><li>页表索引：0x34</li><li>页内偏移量：0x5678</li></ul></li><li><strong>查找顶级页表</strong>：<ul><li>使用0x12从页目录中找到二级页表的基址。</li></ul></li><li><strong>查找二级页表</strong>：<ul><li>使用0x34从二级页表中找到物理页框的基址。</li></ul></li><li><strong>形成物理地址</strong>：<ul><li>将物理页框基址与偏移量0x5678结合，得到最终物理地址。</li></ul></li></ol><h4 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h4><p>每个哈希页表条目都是一个链表(解决碰撞)</p><p>每个哈希页表元素为虚拟页码、物理帧号、指向链表下个元素的指针。</p><p>以虚拟页号作为哈希函数的输入，然后映射，再在映射的链表上面一一对照页码来找寻对应的帧号。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629214009967.png" alt="image-20240629214009967"></p><h4 id="倒置页表"><a href="#倒置页表" class="headerlink" title="倒置页表"></a>倒置页表</h4><p>刚刚描述的页表都是每个进程一个，现在是一个系统只有一个页表。</p><p>虚拟地址为<strong>PID</strong>、<strong>虚拟页号</strong>、<strong>偏移</strong>组成。</p><p>页表条目由<strong>PID</strong>和<strong>虚拟页号</strong>组成。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629214142856.png" alt="image-20240629214142856"></p><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><ol><li><p>请指出内部碎片和外部碎片的区别</p><p>答：首先内部碎片是在进程本身内部的很难被使用(很小)的内存空间，外部碎片是进程间的很难被使用(很小的)内存空间。</p></li><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629215710272.png"></p></li></ol><p>​![50d5b59f1488b30588acc3ce987569b](C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\50d5b59f1488b30588acc3ce987569b.jpg)</p><ol start="3"><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629221817976.png" alt="image-20240629221817976"></p><p>![ef536a6fefef00768e0ecf4b3782588](C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\ef536a6fefef00768e0ecf4b3782588.jpg)</p></li><li><p>页表分页的目的是什么？</p><p>节省内存中存储页表的空间。</p></li><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629223233453.png" alt="image-20240629223233453"></p></li><li><p>固定分区分配适合多道程序，但是<strong>有内部碎片</strong>。</p></li><li><p>固定分区分配地址转换公式：<strong>下限寄存器 &lt;&#x3D; 绝对地址(下限寄存器加逻辑) &lt;&#x3D; 上限寄存器</strong></p></li><li><p>可变分区地址转换公式：<strong>基址寄存器 &lt;&#x3D; 绝对地址(逻辑加基址寄存器) &lt;&#x3D; 基址加限长寄存器</strong></p></li><li><p>可变分区地址越界：<strong>逻辑地址 &gt; 限长寄存器</strong>。</p></li><li><p>页式分配转换地址公式：<strong>绝对地址 &#x3D; 帧号 * 帧长度 + 页内偏移</strong></p></li><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630143024076.png" alt="image-20240630143024076"></p></li><li><p>固定分区是采用<strong>静态重定位</strong>，可变分区是采用<strong>动态重定位</strong>。</p></li><li><p>某个作业在执行过程中正在等待________，则该作业不能移动。<strong>IO</strong></p></li><li><p>页式存储管理提供___________逻辑地址，而段式存储管理中段间的逻辑地址是________。 <strong>连续的</strong>，<strong>不连续的</strong></p></li><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630142533176.png" alt="image-20240630142533176"></p></li><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629223730381.png" alt="image-20240629223730381"></p></li></ol><h2 id="第九章-虚拟内存管理"><a href="#第九章-虚拟内存管理" class="headerlink" title="第九章 虚拟内存管理"></a>第九章 虚拟内存管理</h2><p>因为进程执行时应该处于物理内存，策略都倾向要求每个进程在执行前应完全处于内存。</p><p>但是很少用到整个程序，所以是很浪费的。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存：将用户<strong>逻辑内存与物理内存分离</strong>。</p><p>逻辑地址空间可以比物理地址空间<strong>大得多</strong>。</p><p>这是因为：可以执行程序的时候不把整个程序都装入物理内存，而是使用到的时候才装。所以给进程感觉自己拥有很大的内存空间。</p><ul><li>进程看自己的存储视角：通常从地址0开始，连续地址直到空间结束。</li><li>同时，物理内存按照页帧组织，分配给进程的物理帧可以不连续;</li></ul><p>虚拟地址和物理地址转换靠<strong>MMU</strong>。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629230520984.png" alt="image-20240629230520984"></p><h3 id="请求-按需-调页策略"><a href="#请求-按需-调页策略" class="headerlink" title="请求(按需)调页策略"></a>请求(按需)调页策略</h3><p>请求(按需)调页：只有在需要这个程序的时候才加载页面。是一种策略</p><p>类似带<strong>交换</strong>的分页系统。</p><p>使用<strong>调页程序</strong>来把进程<strong>要使用的页</strong>调入内存。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629231422880.png" alt="image-20240629231422880"></p><p>如果进程试图访问<strong>尚未调入内存</strong>的页(即页表有效位为无效)，则会发生<strong>缺页中断</strong>。</p><p><strong>缺页中断处理流程</strong></p><ol><li>先确认是否内存引用是否有效</li><li>然后查看页表的有效位，确认该页表在磁盘而不在内存，并发出缺页中断。</li><li>在物理内存中找个空闲帧(例如使用空闲帧链表)</li><li>从磁盘复制该页到空闲帧</li><li>更新页表和TLB</li><li>重新跑一次被中断的指令</li></ol><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629232301318.png" alt="image-20240629232301318"></p><p>请求(按需)调页有效访问时间：T &#x3D; (1 - P) * Tm + P * 缺页错误时间</p><p>通常缺页错误时间要远远大于访存时间，所以缺页率P越低越好。</p><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>回想一下，如果进程使用fork()函数，那么子进程要完完全全复制父进程在内存中的页吗？</p><p>其实是不需要的，只有发生改动的时候才创建一个副本。</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630012025257.png" alt="image-20240630012025257" style="zoom: 33%;" /><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630012046460.png" alt="image-20240630012046460" style="zoom:33%;" /><h3 id="Belady异常"><a href="#Belady异常" class="headerlink" title="Belady异常"></a>Belady异常</h3><p>一般来说，帧数越多，缺页率会越低。Belady异常的意思是，随着帧数的增加，缺页率可能会增加。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="FIFO页面置换"><a href="#FIFO页面置换" class="headerlink" title="FIFO页面置换"></a>FIFO页面置换</h4><p><strong>有Belady问题</strong>。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630005424400.png" alt="image-20240630005424400"></p><h4 id="最优页面置换OPT"><a href="#最优页面置换OPT" class="headerlink" title="最优页面置换OPT"></a>最优页面置换OPT</h4><ul><li>置换最长时间不会使用的页面。</li></ul><p>效果最好，缺页率最低，可是最难实现。因为要知道未来信息。</p><p><strong>没有Belady问题。</strong></p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630005626076.png" alt="image-20240630005626076"></p><h4 id="最久未使用页面置换LRU"><a href="#最久未使用页面置换LRU" class="headerlink" title="最久未使用页面置换LRU"></a>最久未使用页面置换LRU</h4><ul><li>置换最长时间没有使用的页</li></ul><p>效果不错，用的是过去的数据。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630005809225.png" alt="image-20240630005809225"></p><p><strong>没有Belady问题。</strong></p><p>可以用<strong>计数器</strong>和<strong>堆栈</strong>实现。</p><h3 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h3><p>所分配的帧必须小于可用帧的数量。</p><p>如果进程的帧减少，那么缺页率会增加，进程效率变低。</p><h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><ul><li><p>平均分配</p><p>n个进程，m个帧，每个进程分到m&#x2F;n个帧。</p></li><li><p>比例分配</p><p>有点像轮盘赌，拥有更多页的进程分配的帧更多。</p></li></ul><h3 id="全局分配和局部分配"><a href="#全局分配和局部分配" class="headerlink" title="全局分配和局部分配"></a>全局分配和局部分配</h3><ul><li>全局分配：进程在选替换帧的时候，可以从整个系统的帧集中选择。</li><li>局部分配：进程在选替换帧的时候，只可以从自己分配的帧集选择。</li></ul><h3 id="系统抖动"><a href="#系统抖动" class="headerlink" title="系统抖动"></a>系统抖动</h3><p>因为进程被分配到的帧不够多，导致一直在缺页，一直在页面置换，最终<strong>页面置换的时间大于执行时间</strong>称为系统抖动。<strong>CPU利用率很低</strong>。</p><h4 id="系统抖动的原因"><a href="#系统抖动的原因" class="headerlink" title="系统抖动的原因"></a>系统抖动的原因</h4><p>操作系统实时监控CPU利用率，如果太低，就增加多道程度；可是如果多道程度太大，就会导致新进程从其他进程抢帧来执行，导致其他进程也会缺页。导致CPU利用率更低。</p><img src="C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\0b50b9577872eb869ee25805ac9da3b.jpg" alt="0b50b9577872eb869ee25805ac9da3b" style="zoom:67%;" /><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>利用时间局部性原理来评断。这个Δ要选的好一点，如果太大就会整个进程的页，太小就体现不出局部性。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701003309983.png" alt="image-20240701003309983"></p><p>假设D为i时刻所有进程的工作集总和，如果D &gt; M(可用帧数)的话，将会发生抖动。因为会有进程分不到帧，一直缺页中断。</p><h3 id="分配内核内存"><a href="#分配内核内存" class="headerlink" title="分配内核内存"></a>分配内核内存</h3><p><strong>伙伴系统</strong></p><p>就是一直两个两个分下去，直到分到适合的大小。</p><p>例如：一个21kb的请求<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630012643697.png" alt="image-20240630012643697"></p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701001241796.png" alt="image-20240701001241796"></p><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><ol><li><p>题目                                                                <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630014055226.png" alt="image-20240630014055226" style="zoom:67%;" /></p><p>9EF -&gt; 0EF</p><p>111 -&gt; 2EF</p><p>700 -&gt; D00</p><p>0FF -&gt; EFF</p></li><li><p>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630015325112.png" alt="image-20240630015325112"></p></li><li><p>题目               <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630021131799.png" alt="image-20240630021131799" style="zoom: 80%;" /></p></li></ol><p>​(a) 已经在抖动了。</p><p>​(b) 提高多道程度</p><p>​(c) 提高多道程度</p><ol start="4"><li><p>存储管理的目的是<strong>方便用户</strong>和<strong>增加主存利用率</strong>。</p></li><li><p>一个被置换出的页面一定要写回外存吗？</p><p>答：不一定，如果没有被更改就不写了。看修改位。</p></li><li><p>使用虚拟内存的原因：<strong>逻辑上扩展</strong>可使用的主存。</p></li></ol><h2 id="第十二章-大容量存储结构"><a href="#第十二章-大容量存储结构" class="headerlink" title="第十二章 大容量存储结构"></a>第十二章 大容量存储结构</h2><p>主要讲述的是<strong>二级存储</strong>。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630024058951.png" alt="image-20240630024058951"></p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630024307267.png" alt="image-20240630024307267"></p><p>每个盘片有两个盘面，每个盘面有多个圆形磁道，每个磁道又分成多个扇区。</p><p>下图计算磁盘的大小。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630025317616.png" alt="image-20240630025317616"></p><p>读取数据：先找到对应的磁道，再透过旋转到对应扇区读取。</p><p>随机读取耗时很久，因为<strong>需要旋转</strong>。<br>$$<br>T_{IO} &#x3D; T_{寻道时间} + T_{旋转延迟} + T_{传输速率} \<br>T_{定位时间} &#x3D; T_{寻道时间} + T_{旋转延迟}<br>$$</p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>目标：<strong>最小化磁头移动的距离</strong> 。因为磁头距离主要被寻道时间影响，也可以看成<strong>最小化寻道时间</strong>。</p><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630030145530.png" alt="image-20240630030145530"></p><h4 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h4><p>可能会<strong>导致饥饿</strong>。</p><p>每次选择距离最近的那个柱面。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630030344405.png" alt="image-20240630030344405"></p><h4 id="SCAN调度-电梯"><a href="#SCAN调度-电梯" class="headerlink" title="SCAN调度(电梯)"></a>SCAN调度(电梯)</h4><p>磁臂从磁盘的一端开始，向另一端移动；在移动到每个柱面时处理请求。<strong>当到达磁盘的另一端时</strong>，磁头移动方向反转。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630030702033.png" alt="image-20240630030702033"></p><h4 id="C-SCAN调度"><a href="#C-SCAN调度" class="headerlink" title="C-SCAN调度"></a>C-SCAN调度</h4><p><strong>当到达磁盘的另一端时</strong>，磁臂移动到另一端并且磁头<strong>移动方向不反转</strong>。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630031013878.png" alt="image-20240630031013878"></p><h4 id="LOOK调度"><a href="#LOOK调度" class="headerlink" title="LOOK调度"></a>LOOK调度</h4><p>跟SCAN算法类似，但是<strong>不用走到磁盘的一端</strong>，只需要走到一个方向的最远请求磁盘移动方向改变。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630031151535.png" alt="image-20240630031151535"></p><h4 id="C-LOOK调度"><a href="#C-LOOK调度" class="headerlink" title="C-LOOK调度"></a>C-LOOK调度</h4><p>一样，磁头方向不改变。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630031252299.png" alt="image-20240630031252299"></p><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><ol><li>要确定磁盘上一个块所在的位置必须给出三个参数：______ 、<strong><strong><strong>和</strong></strong></strong> 。柱面号，磁头号，扇区号</li><li>磁盘输入输出时，______是磁头在移动臂带动下移动到指定柱面所花的时间；______是 指定扇区旋转到磁头下所需的时间。它们与信息在______有关。寻找时间（寻道时间）， <strong>延迟时间，磁盘上的位置</strong></li><li>为了减少磁盘移动臂移动所花费的时间，每个文件的信息不是按盘面上的______顺序 存放满一个盘面后，再放到另一个盘面上，而是按______存放。<strong>磁道，柱面</strong></li><li>存储型设备用<strong>块</strong>作传输，IO设备用<strong>字符</strong>。</li><li>题目 <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630221210666.png" alt="image-20240630221210666"></li></ol><h2 id="第十三章-IO系统"><a href="#第十三章-IO系统" class="headerlink" title="第十三章 IO系统"></a>第十三章 IO系统</h2><p>计算机的两个主要工作是<strong>计算</strong>和<strong>IO</strong>。很多时候，主要工作是IO，而不是计算，例如查看网站时。</p><h3 id="IO硬件"><a href="#IO硬件" class="headerlink" title="IO硬件"></a>IO硬件</h3><p>有关IO基本硬件有<strong>设备</strong>、<strong>设备控制器</strong>、<strong>总线</strong>。</p><p>控制设备的内核模块称为**设备驱动程序(Device Driver)**。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630145752151.png" alt="image-20240630145752151"></p><h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>由四个寄存器组成，分别是<strong>输入寄存器</strong>、<strong>输出寄存器</strong>、<strong>状态寄存器</strong>、<strong>命令寄存器</strong>。</p><h3 id="控制器与主机交互"><a href="#控制器与主机交互" class="headerlink" title="控制器与主机交互"></a>控制器与主机交互</h3><ul><li><p><strong>轮询</strong></p><ol><li><strong>从状态寄存器读取忙位，直到该位清零；</strong> </li><li>主机设置读或写位，如果写入，则将数据复制到数据输出寄存器中； </li><li>主机设置命令就绪位； </li><li>控制器设置忙位； </li><li>控制器读取命令寄存器，并看到命令。从数据输出寄存器中 读取一个字节，并向设备执行I&#x2F;O操作； </li><li>传输完成时，控制器清除忙位、错误位、命令准备位；</li></ol><p>有点像自旋锁，很浪费时间。                                                                <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701010029911.png" alt="image-20240701010029911"></p></li><li><p><strong>中断</strong></p><p>当设备准备好服务的时候，再通知CPU，让设备通知CPU准备好的机制为<strong>中断</strong>。</p><p>当CPU收到用户的IO请求，就告诉IO处理器，让他准备好，然后CPU执行其他进程。</p><p>在执行其他进程时，每执行一条指令就查看是否有中断信号。</p><p>如果有中断信号，根据中断向量表找到对应的中断处理程序。</p><p>处理完后再执行进程。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630150737522.png" alt="image-20240630150737522"></p></li></ul><p>​<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630151150386.png" alt="image-20240630151150386"></p><h3 id="设备和内存的数据传输"><a href="#设备和内存的数据传输" class="headerlink" title="设备和内存的数据传输"></a>设备和内存的数据传输</h3><p>可以用<strong>程序控制IO</strong>来传输，或者用<strong>DMA控制器</strong>来传输。</p><h4 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h4><p>DMA可以数据传输绕过CPU(<strong>从而减轻CPU的负担</strong>)，直接让<strong>I&#x2F;O设备</strong>与<strong>内存</strong>进行数据传输。</p><p>简单来说，就是专门有一个处理器DMA来帮助CPU控制传输数据。</p><p>当DMA占用内存总线时，CPU被暂时阻止访问内存。可是CPU可以执行其他工作并且可以访问cache。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630152020136.png" alt="image-20240630152020136"></p><h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><p><strong>阻塞型IO：</strong>当应用程序执行阻塞型时，自己会被调回等待队列，直到该系统调用完成再回到执行。</p><p><strong>非阻塞型IO：</strong>一个例子是用户接口，用来接收键盘输入并同时显示在荧幕上。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630153430966.png" alt="image-20240630153430966"></p><h3 id="Spooling"><a href="#Spooling" class="headerlink" title="Spooling"></a>Spooling</h3><p>就是把外设输出的buffer储存起来，例如一台打印机，我们希望多个进程同时使用，可是我们不希望打印的结果是一张进程A，一张进程B的，所以要把进程A的输出buffer储存起来，先打印完进程A，再打印进程B。</p><h3 id="buffer和高速缓存"><a href="#buffer和高速缓存" class="headerlink" title="buffer和高速缓存"></a>buffer和高速缓存</h3><ul><li><p>高速缓存</p><p>在内存中开个区域，来放置磁盘平时传输的数据，下次IO传输时，就可以先看看高速缓存内有没有这个数据。</p><p>逻辑上是磁盘的，实际上是内存。</p></li><li><p>buffer</p><p>就是高速设备和低速设备数据如果要传输数据的时候，就把数据放到一个buffer，让另一方去读。</p></li><li><p>区别</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701140226307.png" alt="image-20240701140226307"></p></li></ul><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><ol><li><p>试述外围设备与主存储器之间的DMA数据传送控制方式。</p><p>答：当IO设备准备好，通知DMA控制器，DMA控制器占用内存总线，并且开始数据传输。这段期间，CPU是可以进行计算的，当DMA传输完成后，向CPU发出一个中断信号。</p></li><li><p>设备的独立性是指用户程序使用的设备与实际使用哪台设备无关的一种特性。</p></li><li><p>中断机制传输和DMA传输区别</p><p>答：中断机制传输传输完一次数据之后就要中断，而DMA处理器可以传输一大批数据。中断机制传输说到底还是CPU完成的，DMA传输不是。</p></li><li><p>阻塞型IO和非阻塞型IO区别</p><p><strong>阻塞IO：</strong>在阻塞IO中，一个进程发起一个IO操作后，如果数据还没有准备好，进程就会被挂起（阻塞），直到数据准备好为止。这就像是你在电话中等待对方的回答，你无法做其他的事情。</p><p><strong>非阻塞IO：</strong>在非阻塞IO中，一个进程发起一个IO操作后，如果数据还没有准备好，进程不会被挂起，而是立即返回，进程可以继续做其他的事情。这就像是你在发<a href="https://cloud.tencent.com/product/sms?from_column=20065&from=20065">短信</a>，你发送完短信后，不需要等待对方的回复，你可以做其他的事情。</p></li></ol><h2 id="第十章-文件系统"><a href="#第十章-文件系统" class="headerlink" title="第十章 文件系统"></a>第十章 文件系统</h2><h3 id="什么是文件？"><a href="#什么是文件？" class="headerlink" title="什么是文件？"></a>什么是文件？</h3><p><strong>操作系统对存储设备的物理属性加以抽象，从而定义的逻辑存储单位。</strong></p><p>是<strong>逻辑记录</strong>的一个序列。</p><p>人话：就是拿来存储的。</p><p>再人话：他是二级存储的抽象，我们不需要知道计算机怎么存储的，只需要知道把存储的东西放在文件里面。</p><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><ul><li>文件名称</li><li>文件标识符(Inode)</li><li>文件类型</li><li>文件位置</li><li>文件大小</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>创建文件</li><li>写文件：系统保留写指针。</li><li>读文件：系统保留读指针。</li><li>删除文件</li><li>重定位文件(lseek)</li><li>截断文件：就是把内容清空，但是不删除文件。</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用于<strong>管理</strong>文件系统中的文件和其他目录。</p><p>目录的主要作用是提供一种层次结构，使得文件和目录可以有条理地组织起来，方便用户和程序进行文件的查找、访问和管理。</p><p>接下来，说下目录的结构：</p><h4 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h4><p>所有文件包含在同一个目录。所以<strong>必须要有唯一的名称</strong>。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630162110406.png" alt="image-20240630162110406"></p><h4 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h4><p>每个用户都有自己的<strong>用户文件目录</strong>。不同用户<strong>可以拥有相同命名</strong>的文件，只要主文件目录中的文件名是唯一的。</p><p>这个结构可以有效的让用户隔离，如果用户之间要合作会比较麻烦。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630162332765.png" alt="image-20240630162332765"></p><h4 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h4><p>将二级目录进行推广。允许用户创建自己的子目录和文件。</p><p><strong>不能共享文件或目录</strong>。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630162720120.png" alt="image-20240630162720120"></p><h4 id="无环图目录"><a href="#无环图目录" class="headerlink" title="无环图目录"></a>无环图目录</h4><p>要求目录不能有环。</p><p>允许用户之间可以共享目录。两个程序员可以更好的合作。</p><ul><li>使用<strong>软链接</strong>和<strong>硬链接</strong>进行目录共享。</li><li>软链接：创建一个新文件(新Inode)，内容是path1.</li><li>硬链接：等价于一个Inode有path1和path2。</li></ul><p>可是搜索和<strong>删除变得更加复杂</strong>了。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630163219387.png" alt="image-20240630163219387"></p><h4 id="通用型目录"><a href="#通用型目录" class="headerlink" title="通用型目录"></a>通用型目录</h4><p>在共享文件时更加方便。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630163725766.png" alt="image-20240630163725766"></p><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><ol><li>题目对顺序文件进行读文件操作时，总是从 ( ) 按顺序读出信息。 A．文件头部向后 B．文件尾部向前 C．文件中部开始 D．当前位置开始 <strong>答案是D</strong>           </li><li>文件管理实际上是对<strong>辅助存储空间</strong>管理。</li><li>打开文件的步骤<ol><li>用户使用open函数</li><li>系统拿着file_name去目录找对应的Inode(FCB)</li><li>找到FCB之后，更新进程的已打开文件表</li><li>为该文件分配一个文件描述符。</li><li>返回fd，之后可以用fd对文件进行操作。</li></ol></li><li>题目                                                                    <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630221457916.png" alt="image-20240630221457916"></li></ol><h2 id="第十一章-文件系统实现"><a href="#第十一章-文件系统实现" class="headerlink" title="第十一章 文件系统实现"></a>第十一章 文件系统实现</h2><p>为了提高IO效率，<strong>内存和磁盘之间的IO传输是以块为单位的</strong>。</p><p>一个块为多个扇区。</p><h3 id="什么是文件系统"><a href="#什么是文件系统" class="headerlink" title="什么是文件系统"></a>什么是文件系统</h3><p>文件系统提供高效的磁盘访问，实现对文件的<strong>按名访问</strong>。</p><p>文件系统本身由很多层组成。每层设计用更底层的功能来创建更高层的服务。</p><p>从外到内：<strong>应用程序 – 逻辑文件系统 – 文件组织模块 – 基本文件系统 – IO控制 – 设备</strong></p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630190736078.png" alt="image-20240630190736078" style="zoom:67%;" /><h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><p>在<strong>磁盘</strong>上，文件系统包括<strong>如何启动存储在那里的操作系统</strong>、<strong>总的块数</strong>、<strong>空闲块的数量和位置</strong>。</p><ul><li>引导控制块：包含该卷引导操作系统的所需信息。(就是上电之后启动操作系统)</li><li>卷控制块：如分区块的大小、空闲块的数量和指针、空闲的FCB数量。</li><li>目录结构：其实就是一个链表，&lt;filename, inode&gt;。</li><li>每个文件的FCB。</li><li>等等</li></ul><p>类似进程一样，每个文件都有一个FCB(唯一的标识号)。</p><ul><li>FCB文件控制块包括：<strong>文件权限</strong>、<strong>文件日期</strong>、<strong>文件所有者</strong>、<strong>文件大小</strong>、<strong>文件数据块</strong>。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630193751751.png" alt="image-20240630193751751"></li></ul><p>在内存里，文件系统包括<strong>安装表</strong>、<strong>目录缓存</strong>、<strong>系统的打开文件表</strong>、<strong>进程的打开文件表</strong>。</p><h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><p>目录的操作有<strong>查找</strong>、<strong>增加</strong>、<strong>删除</strong>。</p><p>目录实质上是文件名和Inode的映射。</p><p>所以要实现<strong>按名存取</strong>和<strong>让用户更好的共享</strong>。</p><h4 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h4><p>就是<strong>文件名</strong>和<strong>数据块指针</strong>的线性列表。</p><p>你妈的就是拿name去找对应的inum。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630201451936.png" alt="image-20240630201451936"></p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>key为filename去映射。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630201555893.png" alt="image-20240630201555893"></p><h3 id="文件分配空间"><a href="#文件分配空间" class="headerlink" title="文件分配空间"></a>文件分配空间</h3><p>为文件在磁盘分配的常用方法为连续、链接、索引。</p><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>有点类似可变分区算法(可是这是在磁盘)</p><p><strong>连续分配要求，每个文件在磁盘上占有一组连续的块。</strong></p><p>因为每个文件的块都是紧邻着的，所以寻道时间是最短的。</p><p>支持<strong>顺序访问</strong>和<strong>直接访问</strong>。</p><p>缺点：难以在磁盘中找到对应的空间。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630203014236.png" alt="image-20240630203014236"></p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>链接分配解决了连续分配的问题。</p><p>链接分配，每个文件是磁盘块的链表。</p><p>容易增加文件(只需要找到空闲块并加入链表尾部即可)</p><p>缺点：只能顺序访问文件，需要为指针分配额外空间。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630203427208.png" alt="image-20240630203427208"></p><p>链表分配一个重要的变种是文件分配表FAT的使用。</p><p>FAT表的使用与链表相同，优点是查询的时候不用再移动磁头来查询下一个磁盘块的位置，直接查表即可。特别是如果把FAT表加在缓存中。</p><p>可以很好的改善随机访问的时间。(可以查完表之后就知道哪一块)<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630203945904.png" alt="image-20240630203945904"></p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>索引分配：每个文件把指针放在一个<strong>索引块</strong>。</p><p>支持直接访问。</p><p>缺点：专门用一个索引块来储存指针开销很大，会比链表指针大，特别是一个文件只有两三个磁盘块的时候。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630204324189.png" alt="image-20240630204324189"></p><p>因为每个文件都需要一个索引块，索引块应尽可能小。可是如果太小，它不能为大的文件提供足够的指针。</p><p>用多级索引来解决这个问题。</p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630204752913.png" alt="image-20240630204752913"></p><ul><li><p>要会计算每种块指针能索引多少文件块。文件最大的大小要会算。</p></li><li><p>直接地址索引的表示的文件大小 &#x3D; 直接地址索引数 * 数据块大小</p></li><li><p>一级间接地址索引表示的文件大小 &#x3D; 一级间接地址索引数 * (索引块大小 &#x2F; 地址大小) * 数据块大小</p></li><li><p>二级间接地址索引表示的文件大小 &#x3D; 二级间接地址索引数 * (索引块大小 &#x2F; 地址大小)^2 * 数据块大小</p></li><li><p>就是要先把一个索引块能索引多少个地址算出来，再看情况。</p></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>对于任何类型的访问，连续分配都只需要访问一次就能获得磁盘块。</p><p>对于链接分配，很明显直接访问效能很差。</p><p>索引分配更复杂，效能要看索引结构。</p><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><h4 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h4><p>无脑bit map                          <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630205439347.png" alt="image-20240630205439347"></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>将所有空虚的磁盘块用链表链接起来。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630205527563.png" alt="image-20240630205527563"></p><h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><p>在第一块空闲磁盘块中存储n个空闲块地址，n-1个磁盘块都是空闲的，第n个磁盘块又有n个空闲地址。</p><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>通常，多个连续分配的文件要同时释放。</p><p>000001111000</p><p>可以表示为(0:5), (9,3)</p><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><ol><li>题目<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630213332844.png" alt="image-20240630213332844"></li></ol><p>​答：4个直接地址索引为1k，2个一级间接地址索引为 2 * (256 &#x2F; 4) * 256 &#x3D; 32k，一个二级间接地址索引为 (256 &#x2F; 4) * (256 &#x2F; 4) * 256 &#x3D; 1024k，答案是1057k。</p><ol start="2"><li>题目             <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630213801015.png" alt="image-20240630213801015"></li></ol><p>​512M</p><ol start="3"><li><p>扇区和块的区别</p><p>扇区是磁盘中<strong>最小的存储单位</strong>。块是操作系统中<strong>最小的逻辑存储单位</strong>。块是抽象(虚拟)出来的。</p></li><li><p>比较三种磁盘分配(连续，链接，索引)的优缺点</p><ol><li><p>连续分配：支持直接访问和顺序访问，但会产生外部碎片。</p></li><li><p>链接分配：只支持顺序访问，不产生外部碎片，但指针需要空间存放，且指针如果丢失，会导致访问文件出错。</p></li><li><p>索引分配：支持直接访问，顺序访问，不产生外部碎片，但也要耗费空间</p></li></ol></li><li><p>链接分配中FAT的优点是什么？</p><p>可以提升随机访问的时间，并且可以直接访问中间的块了，不需要再去一块一块访问。</p></li><li><p>对输入输出设备，输入输出操作的信息传输单位为 ( )。字符</p></li><li><p>对存储型设备，输入输出操作的信息是以 ( ) 为单位传输的。块</p></li><li><p>索引结构为每个文件建立一张索引表，用来存放 ( )。 A．逻辑记录的地址 B．部分数据信息 C．主关键字内容 D．逻辑记录存放位置的指针 D是答案。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人工智能复习</title>
    <link href="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能复习"><a href="#人工智能复习" class="headerlink" title="人工智能复习"></a>人工智能复习</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ol><li>人工智能的定义、概况；</li><li>人工智能主要学派及主要观点。</li></ol><h3 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h3><p>需要先有<strong>信息</strong>、<strong>认识</strong>、<strong>知识</strong>、<strong>智力</strong>、<strong>智能</strong>概念才能定义人工智能。</p><ul><li>信息：是搭配了<strong>上下文</strong>的<strong>数据</strong>，是经过整理（解释）的数据，例如“今天天气是30摄氏度”，配合上下文（天气和摄氏度）形成了有意义的信息。</li><li>认识：是用<strong>符号</strong>（例如文字）去整理信息，并且确定它们之间的联系。</li><li>知识：是被<strong>认识</strong>了的<strong>信息</strong>和信息之间的联系。是经过加工（整理）的信息，例如“水在摄氏度0度以下会结冰”就是一种知识。</li><li>智力：是<strong>学习</strong>的能力、<strong>解决问题</strong>的能力，强调运用推理来应对问题。</li><li>智能：定义为<strong>知识集</strong> + <strong>智力</strong>。所以智能就是运用知识来解决问题的能力。</li></ul><p><strong>人工智能定义</strong>：就是利用机器去模仿人类的智能来解决问题。</p><h3 id="人工智能学派及主要观点"><a href="#人工智能学派及主要观点" class="headerlink" title="人工智能学派及主要观点"></a>人工智能学派及主要观点</h3><p><strong>符号主义学派（数理逻辑）</strong></p><ul><li>主要观点：人工智能源于<strong>数理逻辑</strong>。认知基元是符号，以归结原理为基础。</li><li>应用：IBM提出的<code>DEEP BLUE</code>国际象棋和<code>WATSON</code>认知系统。</li></ul><p><strong>联结主义学派（仿生学）</strong></p><ul><li>主要观念：人工智能源于<strong>仿生学</strong>。通过神经元连接和相互作用模拟大脑的结构和功能，通过神经网络来实现智能行为。</li><li>应用：计算机视觉、卷积神经网络、自然语言处理。</li></ul><p><strong>行为主义学派（控制论）</strong></p><ul><li>主要观念：人工智能来源于<strong>控制论</strong>和<strong>反馈机制</strong>。通过模拟生物体在环境中的适应能力和行为来实现智能。</li><li>应用：强化学习、Google研发的机器狗。</li></ul><h2 id="第二章-知识表示和推理"><a href="#第二章-知识表示和推理" class="headerlink" title="第二章 知识表示和推理"></a>第二章 知识表示和推理</h2><h3 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h3><ol><li><p>命题逻辑语法、语义；</p></li><li><p>谓词逻辑语法、语义；</p></li><li><p>谓词推理规则（等价式、永真蕴含式）以及应用；</p></li><li><p>命题及谓词逻辑归结推理（子句、子句集、置换与合一、答案提取）。</p></li></ol><h3 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h3><ul><li><strong>项</strong><ol><li><strong>常数（Constant）</strong>：表示特定的对象，例如<code>a</code>、<code>b</code>、<code>c</code>。</li><li><strong>变量（Variable）</strong>：表示可以取不同值的对象，例如<code>x</code>、<code>y</code>、<code>z</code>。</li></ol></li><li><strong>谓词</strong><ol><li>谓词符号通常是大写字母，例如P(x)、Q(a,b)。</li></ol></li><li><strong>量词</strong><ol><li><strong>全称量词（Universal Quantifier）</strong>：表示对所有的情况都成立，符号为∀，例如∀x P(x)表示“对所有x，P(x)都成立”。</li><li><strong>存在量词（Existential Quantifier）</strong>：表示存在某种情况成立，符号为∃，例如∃x P(x)表示“存在某个x，使得P(x)成立”。</li></ol></li></ul><h3 id="谓词逻辑推理规则"><a href="#谓词逻辑推理规则" class="headerlink" title="谓词逻辑推理规则"></a>谓词逻辑推理规则</h3><ul><li><p>假言推理：</p><p>P→Q, P ⇒ Q</p></li><li><p>假言否定:</p><p>P→Q, ¬Q ⇒ ¬P</p></li><li><p>等等</p></li></ul><h3 id="谓词逻辑应用"><a href="#谓词逻辑应用" class="headerlink" title="谓词逻辑应用"></a>谓词逻辑应用</h3><ul><li>课件一中有两题例子，可以刷下。</li></ul><h3 id="归结推理"><a href="#归结推理" class="headerlink" title="归结推理"></a>归结推理</h3><p>需要先了解<strong>反证法</strong>、<strong>子句集</strong>、<strong>归结操作</strong>的概念才能清楚归结推理。</p><ul><li><p>反证法</p><p>P ⇒ Q  当且仅当  P ∧ ¬Q ⇔ False</p></li><li><p>子句集</p><ol><li>文字：原子公式及其否定。例如：P：正文字，¬P：负文字。</li><li>子句：任何文字的<strong>析取</strong>，当然一个文字自己也是子句。例如：P ∨ Q ∨ R。</li><li>子句集：子句的<strong>合取</strong>集合。例如 {P ∨ Q, ¬P ∨ R, ¬Q}这个子句集合表示了一个包含三个子句的集合，其中 P ∨ Q, ¬P ∨ R, 和 ¬Q 是各自的子句。在归结推理中，我们可以通过归结操作来处理这些子句，从而推导出新的子句或证明目标。</li></ol></li><li><p>归结操作</p><ol><li>定义：归结操作步骤包括选择两个子句并尝试将它们合并成一个新的子句。合并的过程依赖于通过消解相反的文字来生成新的子句。</li><li>例子：有两个子句{P ∨ Q, ¬Q}，经过归结操作后生成新子句{P}。</li></ol></li></ul><p>归结推理的基本步骤是利用反证法：首先将目标子句的否定加入子句集中，然后通过归结操作处理子句集，直到推导出空子句。根据反证法的原理，这表明目标子句是可证明的。</p><ul><li><p>谓词公式转换子句集</p><ol><li>消去蕴涵和等价符号</li><li>内移否定符号¬</li><li>变量标准化（变量换名）</li><li>消去存在量词（<code>Skolemize</code>）</li><li>化为前束型</li><li>把母式化成合取范式</li><li>略去全称量词</li><li>把母式用子句集表示</li><li>子句变量标准化（最好每个子句的变量都不一样）</li></ol></li><li><p>合一</p><ol><li>定义：在谓词归结过程中（子句集内）寻找谓词相同但是项不同，把它们不同的项经过置换，使得该谓词项相同，就是合一。</li></ol></li><li><p>置换</p><ol><li><p>定义：用σ &#x3D; {v1&#x2F;t1, v2&#x2F;t2,…, vn&#x2F;tn}来表示任一置换。vi &#x2F;ti 是指表达式中的变量vi以项ti来替换，且不允许vi 用与vi 有关的项ti（但是ti中可以包含其它变量）作置换。</p></li><li><p>例子：**{a&#x2F;x, w&#x2F;y, f(s)&#x2F;z}是置换**; <strong>{x&#x2F;x}, {y&#x2F;f(x)}不是置换</strong>;、</p></li><li><p>置换是同时进行的。</p></li></ol></li><li><p>复合置换</p><ol><li>过程：θ&#x3D;{t1&#x2F;x1,…,tn&#x2F;xn}，λ&#x3D;{u1&#x2F;y1,…,um&#x2F;ym},求θ°λ<ol><li>构成{t1λ&#x2F;x1,…,tnλ&#x2F;xn,u1&#x2F;y1,…,um&#x2F;ym};（可想象成先置换t1λ&#x2F;x1,…,tnλ&#x2F;xn这一部分再一个一个置换λ）</li><li>如果yj∈(x1,…,xn),  则删除uj&#x2F;yj;<strong>（即替换的变量前面已经被换过了）</strong>（<strong>要记得是θ先做变换的，只要是θ里面更换的变量，λ都要删除</strong>）</li><li>如果tkλ&#x3D;xk,     则删除tkλ&#x2F;xk;<strong>（类似 y &#x2F; y这种）</strong></li></ol></li><li>性质：(θ° λ)° μ&#x3D;θ° (λ° μ) 成立，θ° λ&#x3D;λ ° θ 不一定成立。</li></ol></li><li><p>最一般合一项（MGU）算法：</p><p>给定两个原子公式 f 和 g：</p><ol><li><p>初始化：</p><p>σ&#x3D;{ };S&#x3D;{f,g}</p><p>σ 是当前的<strong>替换集</strong>，初始为空。 S 是包含两个公式 f 和 g 的集合。</p></li><li><p>检查 S 是否包含相同的一对公式。如果是，停止并返回 σ 作为 f 和 g 的 MGU。</p></li><li><p>否则，找到 S 中不一致的项集 D&#x3D;{e1,e2}。</p></li><li><p>检查不一致的项：</p><ul><li>如果 e1&#x3D;V 是一个变量，并且 e2 是不包含 V 的项（反之亦然），则更新替换集： σ&#x3D;σ ° {V&#x3D;t};S&#x3D;S ° {V&#x3D;t}。</li></ul></li><li><p>否则，停止，表示 f 和 g 不能被合一。1</p></li></ol></li><li><p>应用归结原理求解问题</p><ol><li>就是把待求解的问题<strong>否定</strong>加上与<code>A(x)</code><strong>析取</strong>转换成子句并加入到子句集合中，运用归结操作求解答案。</li></ol></li></ul><h2 id="第三章-搜索技术"><a href="#第三章-搜索技术" class="headerlink" title="第三章 搜索技术"></a>第三章 搜索技术</h2><h3 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h3><ol><li>盲目搜索（深度搜索、宽度搜索、迭代加深搜索）；</li><li>启发式搜索（最好优先搜索、A*搜索）；</li><li>博弈树搜索（极大极小过程、alpha-beta剪枝）。</li></ol><h3 id="搜索的形式化定义"><a href="#搜索的形式化定义" class="headerlink" title="搜索的形式化定义"></a>搜索的形式化定义</h3><ol><li>状态空间：即整个要搜索的空间。</li><li>动作：即在当前这个状态需执行的动作。</li><li>初始状态：就是自己目前的状态。</li><li>目标状态：目标的状态。</li><li>启发式函数：指导搜索的方向。</li></ol><p>除此之外，搜索算法还包括<strong>后继函数</strong>、<strong>动作成本</strong>以及如何<strong>选择下一步动作</strong>（这个最重要）等等。</p><h3 id="盲目搜索（无信息搜索）"><a href="#盲目搜索（无信息搜索）" class="headerlink" title="盲目搜索（无信息搜索）"></a>盲目搜索（无信息搜索）</h3><p>采用<strong>固定</strong>的选择策略来选择下一个状态。</p><h4 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h4><ol><li>定义：把当前要扩展的状态的后继状态放在边界的<strong>最后</strong>。</li><li>性质：宽度优先搜索具有<strong>完备性</strong>和<strong>最优性</strong>。<ul><li>完备性：宽度优先从短到长从上到下慢慢搜索，最终一定能找到目标状态。</li><li>最优性：根据宽度优先搜索定义，短的路径一定会在长的路径前被探索完，所以一定有最优性。</li><li>时空复杂度：时空复杂度开销很大，都是O(b^{d+1})，特别是空间复杂度。</li></ul></li></ol><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ol><li>定义：把当前要扩展的状态的后继状态放在边界的<strong>最前面</strong>。</li><li>性质：深度优先搜索不具有<strong>完备性</strong>和<strong>最优性</strong>。<ul><li>完备性：如果状态空间无限或者存在回路则找不到目标状态；若状态空间有限并且一直进行剪枝的话具有完备性。</li><li>时空复杂度：时间复杂度为O(b^m)，空间复杂度**O(bm)**。</li></ul></li></ol><h4 id="迭代加深搜索"><a href="#迭代加深搜索" class="headerlink" title="迭代加深搜索"></a>迭代加深搜索</h4><p>其实就是深度优先和宽度优先缝合；具有宽度优先的优势（每个节点都搜索），也具有深度优先的优势（搜索快）</p><ol><li>定义：迭代加深搜索从<strong>深度限制为0</strong>开始，逐渐增加深度限制，直到找到目标节点或搜索完整个图。每次搜索都是<strong>深度优先搜索</strong>，但只允许到当前的最大深度限制为止。</li><li>性质：具有<strong>完备性</strong>和<strong>最优性</strong>。<ul><li>完备性：类似宽度优先一样。</li><li>最优性：类似宽度优先一样。</li><li>时空复杂度：空间复杂度为O(b^{d})（跟宽度优先一样，可是不用提前存储下一层的节点）；时间复杂度为O(bm)（跟深度优先一样）。</li></ul></li></ol><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><p>对于一个具体问题，构造专用于该领域的<strong>启发式函数 ℎ(𝑛)</strong>, 该函数用于估计从节点𝑛到达目标节点的成本。要求对于所有满足目标条件的节点𝑛，有<strong>ℎ(𝑛)</strong> &#x3D; 0。并且使用<strong>评价函数f(n)<strong>来选择下个要到达的状态。</strong>f(n) &#x3D; g(n) + h(n)</strong></p><ul><li>g(n)是初始节点到n的实际代价。</li></ul><h4 id="贪婪最佳优先搜索"><a href="#贪婪最佳优先搜索" class="headerlink" title="贪婪最佳优先搜索"></a>贪婪最佳优先搜索</h4><ol><li>定义：就是利用启发式函数<strong>ℎ(n)</strong> 来对边界上的节点进行排序，然后每次选择**ℎ(n)**最小的节点n去搜索。</li><li>评价函数（可以理解成）：<strong>f(n) &#x3D; h(n)</strong></li><li>性质：没有<strong>完备性</strong>和<strong>最优性</strong>。</li></ol><h4 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h4><ol><li><p>定义：就是利用评价函数<strong>f(n)</strong> 来对边界上的节点进行排序，然后每次选择f**(n)**最小的节点n去搜索。</p></li><li><p>评价函数：<strong>f(n) &#x3D; g(n) + h(n)</strong></p><ul><li>启发式函数**h(n)*<em>可采纳性：假设ℎ*(𝑛) 是从节点𝑛到目标节点的最优路径的成本，当对于所有节点𝑛，满足ℎ(𝑛) ≤ ℎ</em>(𝑛)，ℎ(n)是可采纳的。<ul><li>为什么叫可采纳，是因为一直低估了最优的代价，可以让A*算法更好的找到最优解。</li></ul></li><li>启发式函数**h(n)**一致性：对于任意节点𝑛1和𝑛2，若 ℎ(𝑛1) ≤ 𝑐(𝑛1 → 𝑛2) + ℎ(𝑛2) 则ℎ(𝑛)具有一致性。<ul><li>为什么叫一致性，因为保证f值是<strong>非递减</strong>的。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240702224627410.png" alt="image-20240702224627410"></li></ul></li><li><strong>证明：一致性可推可采纳性：</strong><ol><li>假设启发式函数 h(n)是一致的。</li><li>假设 h(n) 不是可采纳的。这意味着存在某个节点 n 使得 h(n)&gt;h∗(n)。</li><li>选择一个实际从起始节点 s 到目标节点的最优路径，并设这个路径为 s,n1,n2,…,ng，其中 ng 是目标节点。</li><li>在这条路径上，由于 h 是一致的，我们有： <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240702223842521.png" alt="image-20240702223842521"></li><li>由于目标节点 ng 的启发值为零（即 h(ng)&#x3D;0），将这些不等式相加得到： <img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240702223905637.png" alt="image-20240702223905637"></li><li>因为 c(s,ng)c(s, n_g)c(s,ng) 就是从 sss 到 ngn_gng 的最小实际代价 h∗(s)h^*(s)h∗(s)，所以： h(s)≤h∗(s)</li><li>这与假设的 h(s)&gt;h∗(s) 矛盾。因此，假设 h(n) 不是可采纳的前提是错误的。</li></ol></li></ul></li><li><p>性质：<strong>可能</strong>具有最优性。</p><ul><li><p>一致性可以推出可采纳性。</p></li><li><p>如果**h(n)**只具有可采纳性，没有环检测的情况下是有最优性的。有环检测则不是。</p></li><li><p>如果**h(n)**具有一致性，就算有环检测，也有最优性。</p></li></ul></li></ol><h3 id="博弈树搜索"><a href="#博弈树搜索" class="headerlink" title="博弈树搜索"></a>博弈树搜索</h3><h4 id="Minimax算法"><a href="#Minimax算法" class="headerlink" title="Minimax算法"></a>Minimax算法</h4><ol><li>定义：假设对方能总是做出最优的行动，己方总是做出能最小化对方获得的收益的行动，通过最小化对方的收益，可以最大化己方的收益。</li><li>使用<strong>深度优先搜索</strong>。（模拟算法很重要）</li></ol><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>只要计算节点n的一部分子节点就可以确定在<code>MiniMax</code>算法中我们不会考虑走到节点n了；如果已经确定节点n不会被考虑，那么也就不用继续计算n的子节点了。如下图：<code>x</code>和<code>y</code>已经不用被搜索了。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621191942772.png" alt="image-20240621191942772" style="zoom:67%;" /></p><ul><li>MAX剪枝：对于Max节点n，如果它的α(子) ≥ β(父)的时候，就可以停止遍历n的子节点了。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621192426769.png" alt="image-20240621192426769"></li><li>MIN剪枝：对于Min节点n，如果它的α(父) ≥ β(子)的时候，就可以停止遍历n的子节点了。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621192631831.png" alt="image-20240621192631831"></li></ul><p>简单来说，对于Min节点n, 如果β值变得 ≤ 某个Max 祖先节点的α值, 那么就可以停止扩展n节点了。Max节点也是一样的。</p><p><strong>要记得！是α ≥ β就可以发生剪枝！</strong></p><h2 id="第四章-高级搜索"><a href="#第四章-高级搜索" class="headerlink" title="第四章 高级搜索"></a>第四章 高级搜索</h2><h3 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h3><ol><li>爬山法（基本思想）；</li><li>遗传算法（基本操作）（旅行商问题）。</li></ol><h3 id="爬山法（基本思想）"><a href="#爬山法（基本思想）" class="headerlink" title="爬山法（基本思想）"></a>爬山法（基本思想）</h3><ul><li>是一种<strong>贪婪局部搜索算法</strong>。 能很快<strong>朝着解的方向进展</strong>。</li><li>登高：一直向值增加的方向持续移动，将会在到达一个 “峰顶”时终止，并且在相邻状态中没有比它更高的值。 这个算法保留搜索得路径，因此当前节点的数据结构只需要记录当前状态和它的目标函数值。</li><li>优点：<ol><li>它们只用很少的内存。（因为没有保留搜索得路径）</li><li>它们通常能在很大状态空间中找到合理的解。</li></ol></li><li>可以把爬山法想象成一种地形图，既有“位置”（用状态定义），又有“高度”（用启发式函数定义）。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621202221480.png" alt="image-20240621202221480"></li><li>爬山法的缺点：容易陷入局部最优解。<ol><li>局部最大值：局部极大值是一个比它的每个邻居状态都高的峰顶，但是比全局最大值要低。爬山法找不到最优解。</li><li>山脊：就是一系列的局部最大值，爬山法搜索容易陷入死循环。</li><li>高原：高原是在状态空间地形图上评价函数值平坦的一块区域。像上图的<code>shoulder</code>（山肩）和<code>flat local maximum</code>（水平的局部最大值）都是高原。爬山法搜索效率降低。</li></ol></li><li>解决优点：从不同的状态开始运行爬山法看看哪个解更好。</li></ul><h3 id="爬山法和模拟退火的区别"><a href="#爬山法和模拟退火的区别" class="headerlink" title="爬山法和模拟退火的区别"></a>爬山法和模拟退火的区别</h3><p>因为爬山法是局部贪婪算法，所以容易陷入局部最优解；模拟退火算法是全局优化算法，它可以接受比当前更差的解，所以不会容易陷入局部最优解，并且随着时间慢慢降低接受差解的概率。</p><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>三函数两准则(状态生成函数 状态接受函数 降温函数 退火结束准则 内循环终止准则)</p><p>流程图：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240703143135428.png" alt="image-20240703143135428"></p><p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240703144219931.png" alt="image-20240703144219931"></p><h3 id="遗传算法（基本操作）"><a href="#遗传算法（基本操作）" class="headerlink" title="遗传算法（基本操作）"></a>遗传算法（基本操作）</h3><p>遗传算法的一般步骤为<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621213314264.png" alt="image-20240621213314264"></p><p>流程中，不一定每个个体都会发生<strong>交叉</strong>和<strong>变异</strong>，都是有概率的。</p><p>包括编码、适应度函数、<strong>选择</strong>、<strong>交叉</strong>、<strong>变异</strong>。(后面三种为基本操作)</p><ul><li><p>编码：就是将每个个体进行二进制编码。</p></li><li><p>适应度函数：返回值是判断该个体的适应度，适应度越大代表该个体越好。</p></li><li><p>选择：选择是用来确定重组或交叉个体，以及被选个体将产生多少个子代个体。适应度越大的个体被选择的概率越大。选择方法有：</p><ol><li>轮盘赌：首先按照适应度比例分配给每个个体被选中的概率，然后所有个体被选中概率之和为1，再随机[0,1]生成浮点数，看落在哪个区间，就选择哪个个体。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621212351847.png" alt="image-20240621212351847"></li><li>锦标赛选择：就是按照轮盘赌抽几个个体进行适应度比较，适应度高的个体被选择，一直重复执行下去。</li></ol></li><li><p>交叉：结合父代中选择的个体中的信息而产生新的个体。交叉方法有：</p><ol><li>单点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换，并生成两个新的个体。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621213039839.png" alt="image-20240621213039839"></li><li>两点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。</li></ol></li><li><p>变异：子代基因按小概率扰动产生的变化。变异方法有：</p><ol><li>位点变异：群体中的个体码串，随机挑选一个或多个基因座，并 对这些基因座的基因值以变异概率作变动。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621213549835.png" alt="image-20240621213549835"></li></ol></li><li><p>遗传算法的特点：遗传搜索是针对<strong>一组候选解决方案</strong>（individuals）而不是单个候选方案进行的。在搜索过程中，算法会保留当前一代的一组个体。遗传算法的每次迭代都会创建下一代个体。相反，大多数其他搜索算法都维持单个解决方案，并迭代地修改它以寻找最佳解决方案。例如，梯度下降算法沿当前最陡下降方向迭代移动当前解，梯度方向为给定函数的梯度的负数。</p></li><li><p>遗传算法的群体初始化规模：太小会导致局部最优解，太大会难以收敛。</p></li><li><p>例子：TSP旅行商问题、背包问题</p></li></ul><h2 id="第五章-不确定知识表示以及推理"><a href="#第五章-不确定知识表示以及推理" class="headerlink" title="第五章 不确定知识表示以及推理"></a>第五章 不确定知识表示以及推理</h2><h3 id="考点-4"><a href="#考点-4" class="headerlink" title="考点"></a>考点</h3><ol><li>贝叶斯网络定义及表示、联合概率表示、构建方法、朴素贝叶斯方法、独立性判断D分离；</li><li>贝叶斯网络边缘概率及条件概率计算。</li></ol><h3 id="贝叶斯网络定义及表示"><a href="#贝叶斯网络定义及表示" class="headerlink" title="贝叶斯网络定义及表示"></a>贝叶斯网络定义及表示</h3><ul><li>定义：它由一个有向无环图（表达了变量之间的有向依赖关系）和一系列条件概率表（衡量了上述关系的强度）组成。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623174719759.png" alt="image-20240623174719759"></li><li>补充：P(e)可推出P(<del>e)（一个参数），需要知道P(c|e)和P(c|</del>e)可推出P(<del>c|e)和P(</del>c|~e)（两个参数）。以此类推。</li><li>贝叶斯网络的构建：<ol><li>在某种变量顺序下，对所有变量的联合概率应用链式 法则 Pr(X1,…,Xn) &#x3D; Pr(Xn|X1,…, Xn-1)Pr(Xn-1|X1,…, Xn-2)…Pr(X1)</li><li>对于每个变量Xi ，考虑该变量的条件集合X1,…,Xi-1，Xi 和Xj 是条件独立的，则将Xj 从Xi 的 条件集合中删除。经过这一步骤，可以得到下式 Pr(X1,…,Xn) &#x3D; Pr(Xn|Par(Xn))Pr(Xn-1|Par(Xn-1))…Pr(X1)。</li><li>基于上述公式，构建一个有向无环图。其中，对于每个用节点表示的变量Xi，其父节点为Par(Xi)中的变量集合。</li><li>为每个家庭（即变量及其父节点集合）确定条件概率表的取值。</li></ol></li></ul><h3 id="朴素贝叶斯方法（上网找些题目看看）"><a href="#朴素贝叶斯方法（上网找些题目看看）" class="headerlink" title="朴素贝叶斯方法（上网找些题目看看）"></a>朴素贝叶斯方法（上网找些题目看看）</h3><ul><li>定义：就是人为定义条件独立的变量，使得式子变得更加简单。即类似**P(A,B,C,D) &#x3D; P(A|B)P(C|B)P(D|B)**。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623180235338.png" alt="image-20240623180235338"></li><li>就是先算给定x向量情况下y为正的可能性和y为负的可能性。</li></ul><p> <a href="https://blog.csdn.net/doge_coding/article/details/130307202">轻松搞定朴素贝叶斯(有例题)_朴素贝叶斯算法例题-CSDN博客</a>这个讲的挺好的。</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><ul><li>极大似然法：就是先把式子列出来，然后对数，再对该式子求导并且等于0。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623180513734.png" alt="image-20240623180513734"></li></ul><h3 id="贝叶斯网络的D-分离"><a href="#贝叶斯网络的D-分离" class="headerlink" title="贝叶斯网络的D-分离"></a>贝叶斯网络的D-分离</h3><ul><li><p>串形连接： 在串行连接中A通过事件B影响C，同样事件C也是用过事件B影响A。我们认为当<strong>证据B确定时</strong>，A、C条件独立。<img src="https://i.loli.net/2020/01/12/SAgIbNLnD4xKqGs.png" alt="image-20200112230651132.png" style="zoom: 200%;" /></p></li><li><p>共同的原因：<strong>给定父节点的前提下</strong>，子节点们条件独立。<img src="https://i.loli.net/2020/01/12/a7VzY1tb5vM4snc.png" alt="image-20200112231016234.png" style="zoom:200%;" /></p></li><li><p>共同的作用：<strong>当不给定子节点时</strong>，父节点们条件独立。<img src="https://i.loli.net/2020/01/12/CevZnGT2z467yiX.png" alt="image-20200112231325308.png" style="zoom:200%;" /></p></li><li><p>若存在一条路径将这两个节点（直接）连通，则称这两个节点是<strong>相关</strong>的。若不存在这样的路径将这两个节 点连通，则这两个节点就是<strong>独立</strong>的。</p></li></ul><h3 id="贝叶斯网络计算"><a href="#贝叶斯网络计算" class="headerlink" title="贝叶斯网络计算"></a>贝叶斯网络计算</h3><ul><li>就是一直使用加法原理把父节点加入到式子中，然后链式法则，再对式子展开（条件独立就可以删除）。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623181434174.png" alt="image-20240623181434174"></li></ul><h2 id="第七章-机器学习"><a href="#第七章-机器学习" class="headerlink" title="第七章 机器学习"></a>第七章 机器学习</h2><h3 id="考点-5"><a href="#考点-5" class="headerlink" title="考点"></a>考点</h3><ol><li>监督学习（分类与回归，感知机、逻辑回归；神经网络、<strong>反向传播</strong>、CNN、RNN）；</li><li>非监督学习（Kmeans）；</li><li>强化学习（MDP定义、状态值函数和动作值函数、Q学习及SARSA、DQN）。</li></ol><h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><ul><li>定义：会给定<strong>输入特征</strong>和输出的<strong>标签</strong>（Y）</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>定义：预测<strong>离散</strong>型变量。给定(x1, y1), (x2, y2), …, (xn, yn)，学习一个输入x、预测y的函数f(x)。y是<strong>离散</strong>的。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623195838671.png" alt="image-20240623195838671"></li></ul><h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><ul><li>定义：预测<strong>连续</strong>性变量。给定(x1, y1), (x2, y2), …, (xn, yn)，学习 一个输入x、预测y的函数f(x) 。y是<strong>连续</strong>的。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623200254815.png" alt="image-20240623200254815"></li></ul><p>联结主义（Connetionism）学派：认为人工智能源于<strong>仿生学</strong>。（神经网络）</p><h4 id="感知机学习"><a href="#感知机学习" class="headerlink" title="感知机学习"></a>感知机学习</h4><p>解决<strong>二分类问题</strong>的算法。是有监督学习中的<strong>分类</strong>。</p><ul><li><p>定义：主要是处理<strong>线性可分</strong>的数据。对于拥有d个特征的 x&#x3D;(x1,x2,…,xd) , 计算它的带权“分数” 。如果分数大于0则预测为真，分数小于0则预测为假。</p></li><li><p>输入层：感知机接收一组输入特征向量 x&#x3D;(x1,x2,…,xn)，每个输入有一个对应的权重 w&#x3D;(w1,w2,…,wm)。</p></li><li><p>加权求和：输入特征向量和权重向量进行加权求和，计算公式为：<br>$$<br>\begin{equation}<br>z &#x3D; \mathbf{w} \cdot \mathbf{x} + b &#x3D; \sum_{i&#x3D;1}^{n} w_i x_i + b<br>\end{equation}<br>$$<br> 其中，b是偏置。</p></li><li><p>激活函数：加权求和的结果通过激活函数（通常是阶跃函数）进行处理，输出一个二值结果。阶跃函数的定义为：<br>$$<br>f(z) &#x3D;<br>\begin{cases}<br>1 &amp; \text{if } z \geq 0 \<br>0 &amp; \text{if } z &lt; 0<br>\end{cases}<br>$$</p></li><li><p>损失函数：定义为所有误分类点到分类线距离的总和。（M是所有误分类点的集合）<br>$$<br>L(w, b) &#x3D; -\sum_{\mathbf{x}_i \in M} y_i (w \cdot \mathbf{x}<em>i + b)<br>$$<br>修改函数利用梯度下降法：<br>$$<br>\begin{align}<br>\nabla_w L(w,b) &amp;&#x3D; -\sum</em>{\mathbf{x}_i \in M} y_i \mathbf{x}<em>i \<br>\nabla_b L(w,b) &amp;&#x3D; -\sum</em>{\mathbf{x}_i \in M} y_i<br>\end{align}<br>$$</p></li><li><p>感知机学习：</p><ol><li><p>先初始化权重向量w(0)和偏置b , 然后根据D来修正w和b。（通常初始化为0）</p></li><li><p>对于每个训练样本，计算感知机的输出。</p></li><li><p>如果感知机某个样本的输出与真实标签不一致，根据以下规则更新权重和偏置：<br>$$<br>\begin{align}<br>w_{i+1} &amp;\leftarrow w_i + \eta y_i x_i \<br>b &amp;\leftarrow b + \eta y_i<br>\end{align}<br>$$<br>其中η是学习率。</p></li><li><p>跳回第二步。</p></li></ol></li><li><p>分类图片如下：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623210433383.png" alt="image-20240623210433383" style="zoom:67%;" /></p></li></ul><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>感知机算法只要计算的分数大于0输出标签为真，可是分数<strong>1</strong>和<strong>1000</strong>也是输出标签为真。</p><p>解决<strong>多分类</strong>的算法。</p><ul><li><p>定义：和<strong>感知机学习算法</strong>一样，主要处理线性可分的数据。对于拥有d个特征的 x&#x3D;(x1,x2,…,xd) , 计算一个0到1的概率值，表示<strong>样本属于某个类别的概率</strong>。</p></li><li><p>输入层：感知机接收一组输入特征向量 x&#x3D;(x1,x2,…,xn)，每个输入有一个对应的权重 w&#x3D;(w1,w2,…,wm)。gai</p></li><li><p>加权求和：输入特征向量和权重向量进行加权求和，计算公式为：<br>$$<br>\begin{equation}<br>y &#x3D; \mathbf{w} \cdot \mathbf{x} + b &#x3D; \sum_{i&#x3D;1}^{n} w_i x_i + b<br>\end{equation}<br>$$<br>其中，输出y是该样本属于这个类别的可能性（目前还未经过转化），b是偏置。</p></li><li><p>激活函数：使用Logistic函数将求和y映射到一个介于 0 和 1 之间的概率值：<br>$$<br>\sigma(y) &#x3D; \frac{1}{1 + e^{-y}}<br>$$<br>这里的σ(y)是把刚刚加权求和的总数转换成概率。若y越大，则概率σ(y)就越大。</p></li><li><p>损失函数：定义为交叉熵函数。<br>$$<br>L(w) &#x3D; -\sum_{i&#x3D;1}^{N} \left[ y_i \log(q_i) + (1 - y_i) \log(1 - q_i) \right]<br>$$<br>yi 是第 i 个样本的真实标签（0或1），qi是模型预测的第 i 个样本属于类别 1 的概率。当qi越接近yi，损失函数值就越小。（等价于让损失函数最小）</p><p>修改函数利用梯度下降法：<br>$$<br>\begin{align*}<br>\nabla_{\mathbf{w}} L(\mathbf{w}) &amp; &#x3D; -\sum_{i&#x3D;1}^{N} \left[ y_i - q_i \right] \mathbf{x}_i<br>\end{align*}<br>$$</p></li><li><p>逻辑回归学习：</p><ol><li><p>初始化w和偏置 b，通常可以选择为零或者随机初始化。</p></li><li><p>对于每个训练样本 (xi,yi)，计算模型的预测输出 qi&#x3D;σ(w⋅xi+b)。</p></li><li><p>如果某个样本的输出与真实标签不一致，根据以下规则更新权重和偏置：<br>$$<br>\mathbf{w} \leftarrow \mathbf{w} - \eta  \sum_{i&#x3D;1}^{N} \left[ q_i - y_i \right]\mathbf{x}_i<br>$$</p></li><li><p>跳回第二步。</p></li></ol></li><li><p>其实本质是二分类输出还是0和1，还是一条直线。</p></li></ul><h4 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h4><h5 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h5><ul><li>定义：一个基本的神经网络包括：<strong>输入</strong>、<strong>计算</strong>、<strong>输出</strong>。下图是一个典型的人工神经网络模型，它包含3个输入，1个 输出，以及2个计算功能。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624000843701.png" alt="image-20240624000843701" style="zoom:67%;" /></li><li>人工神经元：人工神经网络中的计算单位。由下列部分组成：<ol><li>输入信号xi</li><li>一个激活层对输入信号乘上加权求和，神经元的激活层由加权输入的总和确定。</li><li>一个阈值函数 f(x)，该函数通过确定激活是低于还是高于阈值来计算最终输出。</li></ol></li><li>应用：可以实现“与”、“或”功能，可是不能处理异或。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624002553421.png" alt="image-20240624002553421" style="zoom: 50%;" /></li></ul><h5 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h5><p>优势：单层神经网络只能处理线性问题，而两层神经网络可以无限逼近<strong>任意连续函数</strong>。面对复杂的非线性分类任务，带一个隐藏层的两层神经网络可以分类的很好。输入和输出节点之间的附加层称为<strong>隐藏层</strong>。</p><p>原因：从输入层到隐藏层时， 数据发生了<strong>空间变换</strong>。这是因为输入层的阈值函数是<strong>非线性</strong>的，对数据进行了转换。</p><p>传递：训练的算法每次迭代都有<strong>前向传递阶段</strong>和<strong>反向传递阶段</strong>。</p><ol><li>前向传递阶段：利用第(l)层处的神经元的输出来计算第(l+1)层的输出。</li><li>反向传递阶段：第(l+1)层的权重在更新第(l)层的权重之前被更新。</li></ol><p>激活函数：</p><ol><li><p>双曲正切函数(tanh)：<br>$$<br>\begin{align}<br>\tanh(x) &amp;&#x3D; \frac{e^x - e^{-x}}{e^x + e^{-x}}\<br>\tanh’(x) &amp;&#x3D; 1 - \tanh^2(x)<br>\end{align}<br>$$</p></li><li><p>sigmoid函数：<br>$$<br>\begin{align}<br>f(x) &amp;&#x3D; \frac{1}{1 + e^{-x}}\<br>f’(x) &amp;&#x3D; f(x) \left(1 - f(x)\right)<br>\end{align}<br>$$<br>函数的<strong>导数</strong>特性很重要！</p></li></ol><p>损失函数：定义为最小二乘法：<br>$$<br>E &#x3D; \frac{1}{2} e^2 &#x3D; \frac{1}{2} (T - O)^2<br>$$<br>为了使用梯度下降调整权重 wjk,我们首先计算在wjk 上误差E的偏导数：<br>$$<br>\begin{align*}<br>\frac{\partial E}{\partial w_{jk}} &amp;&#x3D; \frac{\partial E}{\partial e} \times \frac{\partial e}{\partial O_k} \times \frac{\partial O_k}{\partial w_{jk}} \<br>&amp;&#x3D; -\left( e \right) \times \left( O_k (1 - O_k) \right) \times \left( O_j \right) \<br>&amp;&#x3D; -(T_k - O_k) O_k (1 - O_k) O_j<br>\end{align*}<br>$$</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193053302.png" alt="image-20240624193053302" style="zoom:80%;" /><p>前向传播输入：</p><ul><li>净输入：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193550696.png" alt="image-20240624193550696"></li><li>净输出：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193620428.png" alt="image-20240624193620428"></li></ul><p>反向传播误差：</p><ul><li>对于<strong>输出层</strong>，定义误差为：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193737699.png" alt="image-20240624193737699" style="zoom:80%;" /></li><li>对于<strong>隐藏层</strong>，定义误差为：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193803486.png" alt="image-20240624193803486" style="zoom:80%;" /></li><li><strong>权重更新公式</strong>（利用梯度下降）：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193903303.png" alt="image-20240624193903303" style="zoom:80%;" /></li><li>缺点：很容易梯度消失，每传递一层梯度就是原本的0.25倍。</li><li><a href="https://www.cnblogs.com/BlairGrowing/p/14982115.html">(<em>´∇｀</em>) 欢迎回来！ (cnblogs.com)</a>把这题刷一下基本没问题了(更改偏置b1和b2的时候，这个偏置项有点特殊，可以看成是一个隐藏层的节点进行处理，o1和o2的Err值都对它影响）<img src="C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\b9a535cdb2ab277d41473d468584db9.jpg" alt="b9a535cdb2ab277d41473d468584db9" style="zoom: 50%;" /></li></ul><h4 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h4><ul><li><p>是<strong>深度学习</strong>算法。主要用于图像识别。</p></li><li><p>卷积计算：如下图<img src="https://img-blog.csdnimg.cn/ea3d406273ef408a9a0e1a0903cf24d5.png" alt="img" style="zoom:80%;" /></p><p>描述卷积的四个量：卷积核个数、<strong>卷积核大小f</strong>、<strong>填充0值p</strong>、<strong>步长s</strong>。</p><p>假设原本大小为拿，卷积结果大小为(n可以是高或者宽)<br>$$<br>\frac{n + 2p - f}{s} + 1<br>$$</p></li><li><p>卷积神经网络的构造</p><ol><li><p>输入层：输入层接收原始图像数据。图像通常由三个颜色通道（红、绿、蓝）组成。（输入数据）</p></li><li><p>卷积层（可以有<strong>多层卷积层</strong>）：将输入图像与卷积核进行卷积，然后再进行<strong>非线性变换</strong>(RELU)，再进行<strong>池化</strong>。（提取特征）RELU函数为：<br>$$<br>\text{ReLU}(x) &#x3D; \max(0, x)<br>$$</p></li><li><p>全连接层：全连接层将提取的特征映射转化为网络的最终输出。（就是多层神经网络）<img src="https://pic1.zhimg.com/v2-f91e88cee5b0d44012a67da8853a8aa2_720w.jpg?source=172ae18b" alt="卷积神经网络（CNN）基础及经典模型介绍（续） - 知乎"></p></li><li><p>输出层：输出层是CNN的最后一层，其神经元的数量<strong>等于分类任务中的类别数</strong>。输出层的激活函数根据任务的不同而选择，例如Softmax用于多分类任务，Sigmoid用于二分类任务。</p></li></ol></li><li><p>卷积神经网络（CNN）是一种深度学习方法，它的发展历史可以追溯到20世纪90年代。最早的CNN是由Yann LeCun等人提出的，他们利用多层感知机（MLP）进行手写数字识别。随着技术的进步，CNN的结构变得越来越复杂，性能也得到了显著提高。</p></li><li><p>输入层用于接收原始数据，通常是图像数据。图像通常由三个颜色通道（红、绿、蓝）组成，每个通道包含图像的像素值。输入层只是数据的初始存储区域，不进行任何处理。</p></li><li><p>卷积层是CNN的核心部分，主要用于提取输入数据的局部特征。卷积层通过在每个位置计算卷积核与输入数据的点积，卷积操作后，特征图通过激活函数进行非线性变换，这种非线性变换使模型能够学习和表示更复杂的特征。池化层用于对卷积层生成的特征图进行下采样，减少特征图的尺寸，从而降低计算复杂度。</p></li><li><p>全连接层位于网络的最后几层，将前面层提取到的特征整合并映射到最终的输出。全连接层类似于传统的多层神经网络，每个神经元与上一层的所有神经元相连。通过全连接层，模型能够基于提取到的特征进行分类或回归任务。</p></li><li><p><strong>卷积神经网络和全连接神经网络区别</strong>：卷积神经网络有<strong>卷积层</strong>能够提取更多的数据特征，并且卷积的时候参数是<strong>共享</strong>的还有<strong>平移不变</strong>性。</p></li></ul><h4 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h4><ul><li><p>是<strong>深度学习</strong>算法，主要用于语言识别。</p></li><li><p>因为其余的神经网络输出只和当前时刻网络的输入相关。可是像预测天气这种问题还是很需要<strong>之前</strong>的数据的。这是一个<strong>有记忆</strong>的神经网络。<img src="https://img-blog.csdnimg.cn/a9f135e2447f4c91aceb93f646580000.gif" alt="img"></p></li><li><p>例如像判断广州是目的地还是出发地，需要看前一个英文单词，所以需要用到之前的记忆。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624215758219.png" alt="image-20240624215758219" style="zoom:50%;" /></p></li><li><p>简单来说，就是隐藏层的输出还存储在记忆中，并且记忆内容作为隐藏层的输入。<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624214743675.png" alt="image-20240624214743675" style="zoom:50%;" /></p></li><li><p>例子如下：假设所有权重都是1，激活函数都是线性的。</p></li><li><p>第一步：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624215015924.png" alt="image-20240624215015924" style="zoom:50%;" /></p></li><li><p>第二步：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624215128804.png" alt="image-20240624215128804" style="zoom:50%;" /></p></li><li><p>第三步：<img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624215206066.png" alt="image-20240624215206066" style="zoom:50%;" /></p></li><li><p><strong>不同的</strong>输入顺序会影响到循环神经网络的输出，因为是<strong>有记忆</strong>的！</p></li></ul><p>基本上理解卷积神经网络就是眼睛，主要用来图像识别；循环神经网络就像嘴巴，主要用来语言识别。</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>就是不会给出<strong>标签</strong>的学习。</p><h4 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h4><ul><li><p><strong>聚类</strong>：基于距离度量，将对象集合<strong>聚类到簇(cluster)中</strong>，使得簇内对象的距离<strong>尽量小</strong>，且簇之间对象的距离<strong>尽量大</strong>。</p></li><li><p>向量x和y之间距离公式：</p><ol><li><p><strong>街区距离</strong>：<br>$$<br>d(x, y) &#x3D; \sum_{i&#x3D;1}^{n} |x_i - y_i|<br>$$<br>n是向量的维度。</p></li><li><p><strong>欧式距离</strong>：<br>$$<br>d(x, y) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n} (x_i - y_i)^2}<br>$$<br>n是向量的维度。</p></li></ol></li><li><p>K-Means算法流程：</p><ol><li><strong>初始化</strong>：<ul><li>确定聚类的数目K。</li><li>随机选择K个数据点当作质心。</li></ul></li><li><strong>分配每个点到最近的质心</strong>：<ul><li>对于每个数据点，计算它到每个质心的距离。</li><li>将每个数据点分配到距离最近的质心所属的簇。</li></ul></li><li><strong>更新质心</strong>：<ul><li>对于每个簇，计算所有属于该簇的数据点的平均值，这个平均值就是新的质心。</li><li>更新质心的位置为新的平均值。</li></ul></li><li><strong>重复步骤2和步骤3</strong>：<ul><li>反复执行步骤2和步骤3，直到质心不再发生变化，或者达到预设的迭代次数。</li></ul></li><li><strong>完成聚类</strong>：<ul><li>最终的质心和数据点的分配结果即为K-means算法的输出。</li></ul></li></ol></li><li><p>K-Means算法改进：</p><p>可以发现，一开始选择的质心很重要，很影响算法。所以初始化的质心应该离得越远越好。</p><ul><li><p>K-Means++算法：</p><ol><li><p>计算每个数据点x到最近的一个已选质心的距离</p><p>对于每个数据点 x，计算它到最近的一个已选质心的距离D(x)。假设我们已经选择了m 个质心 c1,c2,…,cm。<br>$$<br>D(x) &#x3D; \min_{i \in {1, 2, \ldots, m}} \text{dist}(x, c_i)<br>$$</p></li><li><p>计算每个点被选中当质心的概率</p><p>将每个数据点 x 到最近质心的距离 D(x) 的平方作为该点被选为下一个质心的概率权重。具体来说，计算概率权重：</p><p>$$<br>P(x) &#x3D; \frac{D(x)^2}{\sum_{y \in X} D(y)^2}<br>$$</p></li><li><p>轮盘赌选择下一个质心</p><p>离被选中的质心越远被选做质心的可能性越大。</p></li></ol></li></ul></li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习基本要素有：<strong>状态</strong>、<strong>动作</strong>、<strong>策略</strong>、<strong>奖励</strong>、值函数（<strong>状态值函数</strong>、<strong>动作值函数</strong>）</p><p>强化学习的基本目标是：<strong>找到最大化奖励的策略</strong>。</p><ul><li><p>状态值函数V(s)：用于评断当前状态s在给定策略π下，未来累计的期望值。<br>$$<br>V^{\pi}(s) &#x3D; \mathbb{E}<em>{\pi} \left[ \sum</em>{t&#x3D;0}^{\infty} \gamma^t R_{t+1} \mid S_0 &#x3D; s \right]<br>$$</p><img src="C:\Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240625155050199.png" alt="image-20240625155050199" style="zoom:50%;" /><p>两条公式是<strong>等价</strong>的。</p></li><li><p>动作值函数Q(s,a)：表示在状态 s 下采取动作 a，然后遵循策略 π 时，未来累积奖励的期望值。</p></li></ul><h4 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h4><p>是一种<strong>贪心</strong>算法，学习的策略和实际的策略可能<strong>不同</strong>。<strong>异策略</strong>。</p><p>通过反复的试验和更新，逐渐逼近最优的状态值函数（Q函数），从而找到最优策略。</p><p>更新Q值的公式如下：<br>$$<br>Q(s, a) \leftarrow   r + \gamma \max_{a’} Q(s’, a’)<br>$$<br>其中r是到达s’的奖励。</p><p>更新Q值时，因为是贪心算法，所以取s’状态的<strong>max值</strong>。</p><h4 id="SARSA"><a href="#SARSA" class="headerlink" title="SARSA"></a>SARSA</h4><p>学习的策略与实际执行的策略是<strong>一致</strong>的。<strong>同策略</strong>。</p><p>更新Q值的公式如下：<br>$$<br>Q(s, a) \leftarrow  r + \gamma Q(s’, a’)<br>$$<br>更新Q值时，所以取s’状态的Q值。</p><h4 id="Q-learning-和-SARSA区别"><a href="#Q-learning-和-SARSA区别" class="headerlink" title="Q-learning 和 SARSA区别"></a>Q-learning 和 SARSA区别</h4><ol><li>策略类型<ul><li>Q-learning: Off-policy，学习的策略（最优策略）与执行的策略（探索策略）不同。</li><li>SARSA: On-policy，学习的策略与执行的策略相同。</li></ul></li><li>更新Q值的依据<ul><li>Q-learning: 更新Q值时使用的是新状态s’下的最大Q值（max⁡Q(s′,a′)）。</li><li>SARSA: 更新Q值时使用的是新状态s’下实际选择的动作的Q值（Q(s′,a′)）。</li></ul></li></ol><h4 id="TD时序差分"><a href="#TD时序差分" class="headerlink" title="TD时序差分"></a>TD时序差分</h4><p>更改Q值的时候，还会利用到原本的Q值。</p><ul><li><p>可以与<strong>Q-learning</strong>和<strong>SARSA</strong>混合使用。</p></li><li><p><strong>Q-learning TD</strong>算法公式：<br>$$<br>Q(s, a) \leftarrow (1 - \alpha)Q(s, a) + \alpha \left[ r + \gamma \max_{a’} Q(s’, a’)  \right]<br>$$</p></li><li><p><strong>SARSA TD</strong>算法公式：<br>$$<br>Q(s, a) \leftarrow (1 - \alpha)Q(s, a) + \alpha \left[ r + \gamma Q(s’, a’)  \right]<br>$$<br>α是学习率，γ是折扣因子。</p></li></ul><h4 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h4><p>是<strong>Q-learning算法</strong>和<strong>深度神经网络</strong>结合，并额外引入两个机制<strong>经验回放</strong>和<strong>目标网络</strong>。</p><ul><li><p>经验回放：将智能体探索环境得到的数据储存起来，然后随机采样小批次样本更新深度神经网络的参数。</p></li><li><p>目标网络：额外引入一个目标网络（和Q网络具有同样的网络结构），此目标网络不更新梯度，每隔一段时间将Q网络的参数赋值给此目标网络。</p></li><li><p>实现步骤：</p><ol><li><strong>初始化神经网络</strong>：包括主网络和目标网络的初始化。</li><li><strong>与环境交互</strong>：使用当前策略（通常是 ε-greedy 策略）与环境交互，收集经验数据。</li><li><strong>存储经验</strong>：将每次交互的经验（状态、动作、奖励、下一个状态）存储到经验回放缓冲区中。</li><li><strong>经验回放</strong>：从经验回放缓冲区中随机抽取小批量的经验样本，用于训练主网络。</li><li><strong>Q-learning 更新</strong>：使用抽样的经验样本，计算 Q-learning 的目标并更新主网络的参数。</li><li><strong>更新目标网络</strong>：定期更新目标网络的参数，以保持其与主网络的一致性，但更新频率较低，如每隔一定步数更新一次。</li><li><strong>迭代训练</strong>：重复上述步骤直至收敛或达到预定的训练步数。</li></ol></li><li><p>DQN和深度神经网络区别</p><ol><li><p>概括</p><ul><li>深度神经网络是一种通用的机器学习模型，用于学习输入数据中的复杂模式和特征。</li><li>DQN 是一种强化学习算法，结合了深度神经网络和Q-learning的思想。</li></ul></li><li><p>训练方法</p></li></ol><ul><li>深度神经网络训练通常使用监督学习或无监督学习的方法，通过最小化预测输出与真实标签之间的损失来优化网络参数。</li><li>DQN训练过程是通过交互式学习与环境进行，智能体通过试错和反馈来优化动作值函数。</li></ul></li></ul><h2 id="押题"><a href="#押题" class="headerlink" title="押题"></a>押题</h2><p>谓词归结一题 <strong>贝叶斯网络一题</strong> <strong>A*一题</strong>  <strong>Minimax剪枝一题</strong>  感觉爬山法可能会有一题</p><p><strong>遗传一题</strong> </p><p><strong>Qlearning一题</strong></p><p><strong>k-means一题</strong> </p><p><strong>BP一题</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>show-photo</title>
    <link href="/2024/12/02/show-photo/"/>
    <url>/2024/12/02/show-photo/</url>
    
    <content type="html"><![CDATA[<p>以下是一张图片：</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
