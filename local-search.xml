<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习复习</title>
    <link href="/2025/01/25/%E6%9E%81%E9%80%9F%E7%89%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/01/25/%E6%9E%81%E9%80%9F%E7%89%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="极速版机器学习"><a href="#极速版机器学习" class="headerlink" title="极速版机器学习"></a>极速版机器学习</h1><p>作者：哈利波特👑</p><h2 id="1-线性回归和逻辑回归"><a href="#1-线性回归和逻辑回归" class="headerlink" title="1. 线性回归和逻辑回归"></a>1. 线性回归和逻辑回归</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p><strong>建模：</strong></p><p><strong>目标函数（最小二乘法）：</strong></p><p><strong>参数更新：</strong></p><p><strong>数据集形式：</strong></p><p><strong>梯度下降法：</strong></p><ul><li>简单容易实现</li><li>可能陷入局部最优</li><li>对参数尺度敏感（需要归一化）</li></ul><p><strong>为什么需要空间转换</strong></p><p>因为线性回归模型是假设X和Y是线性的，但是现实中不一定所有都是线性的，所以进行空间转换，希望能更好的捕捉希望将这种非线性转换成线性关系。</p><p><strong>了解偏差 误差 方差</strong></p><ul><li><strong>偏差</strong>：总是低估或高估价格（预测值与真实值有系统性差异）。</li><li><strong>误差</strong>：每次预测与实际房价的差异（具体的预测偏差）。</li><li><strong>方差</strong>：不同训练集上的预测结果波动（模型的稳定性）。</li><li><a href="https://blog.csdn.net/qq_40535327/article/details/106000161">机器学习中偏差、方差的理解与总结_机器学习 偏差 方差-CSDN博客</a></li></ul><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归就是在线性回归的基础上，增加了sigmoid函数，使得它的输出是 0~1 。</p><p><strong>与线性回归差别</strong></p><ul><li><p>线性回归是预测连续值的（房价），逻辑回归是进行分类的。</p></li><li><p>线性回归要求X和Y是线性关系，逻辑回归没有要求。</p></li><li><p>线性回归要求因变量（Y）是连续的，逻辑回归要求Y是离散（标签）。</p></li></ul><p><strong>目标函数：</strong></p><p><strong>参数更新</strong></p><p><strong>为什么要增加正则项</strong></p><p>提高分类模型的泛化能力。</p><h2 id="2-评判指标"><a href="#2-评判指标" class="headerlink" title="2. 评判指标"></a>2. 评判指标</h2><p>看作业</p><h2 id="3-PCA（主成分分析）"><a href="#3-PCA（主成分分析）" class="headerlink" title="3. PCA（主成分分析）"></a>3. PCA（主成分分析）</h2><p>将数据从高维空间映射到低维空间，同时尽可能保留数据的主要特征（或信息）。非监督。</p><p>可以从<strong>最小化重构误差理解</strong>，或者从<strong>最大化方差理解</strong>。</p><ul><li><p>最小化重构误差</p><p>PCA通过选择最重要的方向来表示数据，使得通过这些方向来重建原始数据时，重构误差最小。</p></li><li><p>最大化方差</p><p>通过将数据投影到这些方差最大的方向上，我们最大化了数据中保留的信息。</p></li></ul><p>假设方向向量（主成分）是<strong>两两正交的</strong>。</p><ul><li>这样就没有冗余信息，两两独立。</li></ul><p>基本思想：PCA确实是通过寻找一组正交方向，然后将数据投影到这些方向上来实现降维的。</p><p>$$\alpha_i$$的取值是由下面推导出来的（可以理解成是X在方向向量上的投影）：</p><p>方向向量是基于协方差矩阵特征值分解，找到特征值最大的几个向量作为方向向量。再将X投影到这些方向向量上进行降维。</p><p>因为特征值越大，代表这个方向上的方差越大，即信息越多。</p><p>换个角度想，PCA也可以用作提取特征。</p><p><strong>应用：</strong></p><ul><li>图像压缩</li><li>降噪</li><li>提取特征（像人脸识别）</li></ul><p><strong>缺陷：</strong></p><ul><li><p>适合于线性数据，不适合非线性数据。（想想看建模）</p></li><li><p>计算协方差矩阵对于尺度敏感，需要归一化。</p></li><li><p>需要大量的矩阵运算和特征值分解。</p></li></ul><p>推导过程：</p><p><strong>从最小化重构误差的角度理解 PCA</strong></p><ul><li><p>高维空间中的正交方向是一组两两正交的（单位）向量组，<strong>正交可以表示成向量内积等于 0。</strong></p></li><li><p><strong>定理：在给定 M 个标准正交方向 $u_i$ 下，与数据样本 $x$ 的最佳近似为：$\hat {\mathbf x} &#x3D; \alpha_1 \mathbf u_1 + \alpha_2 \mathbf u_2 +…+\alpha_M \mathbf u_M$， $\alpha_i &#x3D; \mathbf u_i^T\mathbf x$（系数 $\alpha_i$ 可以算出，但最佳方向还未确定）。</strong></p></li><li><p>目标：确定最佳方向</p><ul><li>给定数据 ${\mathbf x^{(n)}}<em>{n&#x3D;1}^N \in \mathbb R^D$ ，找出最能代表原始数据的正交方向 $u_i$，即 $\mathbf x^{(n)} \approx \sum</em>{i&#x3D;1}^{M}\alpha_i^{(n)}\mathbf u_i$</li><li>目标可以表述为最小化数据 $\mathbf x^{(n)}$与其近似值 $\hat{\mathbf x}^{(n)} &#x3D;  \sum_{i&#x3D;1}^{M}\alpha_i^{(n)}\mathbf u_i$ 之间的误差</li></ul></li><li><p>推导步骤：</p><ol><li><p>中心化样本：$\mathbf x^{(n)} - \overline {\mathbf x} &#x3D; \mathbf x^{(n)} - \frac1N\sum_{n&#x3D;1}^N\mathbf x^{(n)}$</p></li><li><p>描述目标问题：<br>$$<br>E &#x3D; \frac1N\sum_{n&#x3D;1}^N||(\mathbf x^{(n)}-\overline{\mathbf x})-\hat{\mathbf x}^{(n)}||^2 \<br>\alpha_I^{(n)} &#x3D; \mathbf u_i^T(\mathbf x^{(n)}-\overline{\mathbf x})<br>$$</p></li><li><p>将 $ \hat{\mathbf x}^{(n)}$ 的表达式代入 $E$，并将平方展开，再将 $\alpha_i^{(n)}$ 的表达式代入展开后的 $E$ 得到：<br>$$<br>E &#x3D; \frac1N(\sum_{i&#x3D;1}^{N}||\mathbf{x}^{(n)}-\overline{\mathbf x}||^2 - 2\sum_{n&#x3D;1}^N\sum_{i&#x3D;1}^M\alpha_i^{(n)}(\mathbf{x}^{(n)}-\overline{\mathbf x})^T\mathbf u_i + \sum_{n&#x3D;1}^N\sum_{i&#x3D;1}^M(\alpha_i^{(n)})^2) \<br>E &#x3D; \frac1N\sum_{i&#x3D;1}^{N}||\mathbf{x}^{(n)}-\overline{\mathbf x}||^2 - \sum_{i&#x3D;1}^M\mathbf u_i^T\frac1N\sum_{n&#x3D;1}^N(\mathbf x^{(n)}-\overline{\mathbf x})(\mathbf x^{(n)}-\overline{\mathbf x})^T\mathbf u_i<br>$$<br>我们令 $s &#x3D; \frac1N\sum_{n&#x3D;1}^N(\mathbf x^{(n)}-\overline{\mathbf x})(\mathbf x^{(n)}-\overline{\mathbf x})^T$，$E$ 的前半部分是常数</p></li><li><p>将 $E$ 写成矩阵形式：<br>$$<br>E &#x3D; ||\mathbf X - \overline{\mathbf X}||^2_F - \sum_{i&#x3D;1}^M\mathbf u_i^T\mathbf S\mathbf u_i<br>$$<br>其中：$\mathbf X &#x3D; [\mathbf x^{(1)}, \mathbf x^{(2)}, …, \mathbf x^{(N)}]$，$||\cdot||_F$ 是 Frobenius范数，定义为矩阵各项元素的绝对值平方的总和开根。</p></li><li><p>问题转换：</p><ul><li><p>在 $M&#x3D;1$ 的情况下，使用拉格朗日方法，可以看出 $u_1$ 应该是 $S$ 最大特征值对应的特征向量<br>$$<br>\max_{u_1} u_1^TSu_1\<br>\text{s.t. } u_1^Tu_1 &#x3D; 1\<br>\text{Lagrange Method: }L &#x3D;  u_1^TSu_1- \lambda(u_1^Tu_1-1) \<br>\text{derivative of u1 &#x3D; 0: } Su_1 &#x3D; \lambda u_1<br>$$</p></li><li><p>在 $M &#x3D; k$ 的情况下（推导同样使用拉格朗日方法，注意利用正交的条件），**$u_i$ 就是 $S$ 最大的 $k$ 个特征值对应的特征向量**</p></li></ul></li></ol></li><li><p><strong>从最大化方差的角度理解 PCA</strong>：最大化方差等于尽可能保留原始数据的信息</p><ul><li><p>推导过程：</p><ul><li><p>以 $M&#x3D;1$ 为例：</p><ul><li><p><strong>对于第一个方向 $u_1$，我们希望投影到 $u_1$ 方 向上的数据方差，即 $\mathbf u_1^T\mathbf x^{(n)}$，是最大的。</strong></p></li><li><p>方差的表达式：<br>$$<br>var &#x3D; \frac1N\sum_{n&#x3D;1}^N(\mathbf u_1^T(\mathbf x^{(n)}-\overline{\mathbf x}))^2 \<br> &#x3D; \mathbf u_1^T\frac1N\sum_{n&#x3D;1}^N(\mathbf x^{(n)}-\overline{\mathbf x})(\mathbf x^{(n)}-\overline{\mathbf x})^T\mathbf u_1 \<br> &#x3D; \mathbf u_1^T\mathbf S\mathbf u_1<br>$$</p></li><li><p>同样可以推出  $u_1$ 应该是 $S$ 最大特征值对应的特征向量</p></li></ul></li><li><p>在 $M &#x3D; k$ 的情况下（推导同样使用拉格朗日方法，注意利用正交的条件），**$u_i$ 就是 $S$ 最大的 $k$ 个特征值对应的特征向量**</p></li></ul></li></ul></li></ul><h2 id="4-自动编码器-AE"><a href="#4-自动编码器-AE" class="headerlink" title="4. 自动编码器 AE"></a>4. 自动编码器 AE</h2><p>是一种无监督机器学习算法。</p><p>基本上分为编码和解码过程：</p><ul><li>编码：将输入通过一个编码器（通常是一个神经网络）来转换为低维的隐层表示。编码后的结果可以理解成输入数据的关键信息或者是一个隐含信息（隐含层）。</li><li>解码：将隐层表示通过解码器进行重构，希望能恢复出原数据。目标是让解码器输出尽可能接近输入数据。</li></ul><p><strong>目标函数：</strong></p><p><strong>PCA与自动编码器的关系：</strong></p><ul><li>都是无监督的、降维、提取数据特征。</li><li>并且可以从降维后的数据尽量恢复出原始数据。</li><li><strong>PCA只能处理线性数据，AE可以处理非线性数据。</strong></li></ul><p><strong>自动编码器的变种算法：</strong></p><ul><li><strong>去噪自动编码器（Denoising Autoencoder, DAE）</strong>： 输入数据中加入噪声，训练网络恢复原始的无噪声数据。这种方法可以帮助网络学习到更加鲁棒的特征。</li><li><strong>变分自动编码器（Variational Autoencoder, VAE）</strong>： 变分自动编码器是一种生成模型，它通过对潜在变量的概率分布进行建模来生成新的数据样本。</li></ul><p><strong>应用：</strong></p><ul><li>去噪</li><li>生成图片（VAE）</li></ul><h2 id="5-BP神经网络"><a href="#5-BP神经网络" class="headerlink" title="5. BP神经网络"></a>5. BP神经网络</h2><p>主要作用是通过计算误差并将其传播回网络，从而更新神经网络的权重，使得网络的输出更接近目标值。</p><p><strong>激活函数：</strong></p><p>激活函数的作用是使得神经网络可以处理非线性的数据（想想看感知机处理异或）</p><ul><li>sigmoid好处是跟概率一样都是0到1，导数很好求，但是可能会梯度消失。</li><li>Relu好处是不会梯度消失，并且计算更快，但是可能导致部分神经元（死神经元）一直不参与运算。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/32819991">BP（反向传播算法）公式推导及例题解析 - 知乎</a></p><p>前向和反向传播公式推导一下。</p><p>基于动量的梯度下降法：</p><p>很像下降之后还有一个惯性，利用了更多的历史信息（对比经典梯度下降）。</p><p><strong>应用：</strong></p><ul><li>图像分类</li><li>语音识别</li></ul><h2 id="6-聚类"><a href="#6-聚类" class="headerlink" title="6. 聚类"></a>6. 聚类</h2><p>分为软聚类和硬聚类。</p><p>软聚类表示数据点可以属于多个类，利用概率来表示。</p><p>硬聚类表示数据点只能属于一个类。</p><p>模糊C-means 是一个<strong>软聚类</strong>算法。</p><ul><li>Wij 表示数据点Xi属于聚类Cj的概率。</li><li>先固定Wij，来更新聚类中心点Cj。</li><li>再固定Cj，来更新权重Wij。</li></ul><h3 id="高斯混合聚类"><a href="#高斯混合聚类" class="headerlink" title="高斯混合聚类"></a>高斯混合聚类</h3><p>一种基于概率的算法，是软聚类。</p><p>GMM假设数据是由若干个高斯分布混合而成，每个高斯分布代表一个簇。</p><p><strong>使用期望最大化（EM）算法进行优化：</strong></p><ul><li><p>GMM通常使用期望最大化（EM）算法来估计模型参数。EM算法由两部分组成：</p><ul><li><p><strong>E步（期望步）</strong>：计算每个数据点属于每个高斯分布的后验概率（责任值）。</p></li><li><p><strong>M步（最大化步）</strong>：基于责任值更新每个高斯分布的参数（均值、协方差和权重）。</p></li></ul></li></ul><h3 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K Means聚类"></a>K Means聚类</h3><blockquote><p>目的，终止条件，一定最优吗，kmeans有哪几步，优缺点，乘积聚类。</p></blockquote><p>无监督、硬聚类算法。</p><p><strong>聚类的目的：</strong>提高类内的相似性，减少类间相似性。</p><p><strong>Kmeans 流程如下：</strong></p><ol><li>一开始随机初始化k个中心点。</li><li>计算每个数据点到每个中心点的距离，选择最小的中心点的类作为数据点的类。</li><li>计算类间位置均值，将该均值调整为该类新的中心点。</li><li>重复上述步骤2 3，直到收敛。</li></ol><p><strong>Kmeans目标函数：</strong></p><p><strong>不一定最优</strong>：</p><ul><li>因为Kmeans很吃初始点的位置，如果选择的不好对最后的分类结果影响很大。</li><li>并且如果数据点的分布很复杂，Kmeans效果也不太好，Kmeans假设簇是圆形的。</li><li>K值的取值也是一个关键因素。</li></ul><p><strong>改进：</strong>选择中心位置的时候，先假设选择前k个中心点，剩下的中心点距离前k个中心点越远越好。</p><p><strong>算法收敛的证明：</strong></p><p>因为数据点到最优中心点的距离总和有下界，并且每次随着算法运行距离总和都会下降，最终收敛。</p><p><strong>优缺点：</strong></p><ul><li>简单易懂</li><li>适合用于数据分布为球状的时候</li><li>对初始中心位置敏感</li><li>不能处理复杂形状的数据</li><li>K值的取值也是一个关键因素。（选择肘部点）</li></ul><p><strong>单链接层次聚类</strong></p><p>主要步骤：</p><ol><li><strong>初始化</strong>：每个数据点都看作一个单独的簇。</li><li><strong>计算距离</strong>：计算所有簇之间的距离，初始时簇间的距离是簇内点之间的距离。对于每一对簇，计算簇间的距离。</li><li><strong>合并簇</strong>：选择距离最小的两个簇进行合并，形成一个新的簇。</li><li><strong>更新距离</strong>：更新新合并簇与其他簇之间的距离。使用<strong>单链接</strong>方法，即新的簇与其他簇之间的距离是新簇与其他簇之间点对距离的<strong>最小值</strong>。</li><li><strong>重复</strong>：重复步骤3和步骤4，直到所有数据点都被合并成一个簇为止，或者满足某个停止条件（例如，设定的簇数）。</li></ol><p>适用于对簇的形状没有严格要求的情况，尤其是当簇的形状不规则</p><h2 id="7-EM算法（高斯混合聚类）"><a href="#7-EM算法（高斯混合聚类）" class="headerlink" title="7. EM算法（高斯混合聚类）"></a>7. EM算法（高斯混合聚类）</h2><p>最大似然函数是根据X反推参数zeta，在高斯混合聚类中，参数就是聚类结果。</p><p>适合有观察变量和隐变量使用的算法。</p><p><strong>为什么不是全局最优</strong>：</p><ul><li>EM算法的每一步（E步和M步）都是为了<strong>局部改进</strong>对数似然值，缺乏探索整个参数空间的能力。换句话说，它是一个贪心的算法，每次优化只考虑当前步骤的改进，而不是全局视角。</li><li>并且对初始参数敏感，如果设置的不好效果差很多。</li><li>所以容易陷入局部最优解。</li><li>试多几次。</li></ul><p>介绍：</p><ul><li><p><strong>无监督分类问题，有点像 K-Means</strong></p></li><li><p><strong>问题的一般形式</strong>：给定一个联合分布 $p(x,z;\theta)$（在概率模型的参数 $\theta$ 下，$x,z$ 的联合概率分布），$x$ 是观测变量，$z$ 是隐变量（Latent variable），目标是最大化似然分布：$\theta &#x3D; \arg\max_\theta\log p(x;\theta)$，满足 $ p(x;\theta) &#x3D; \sum_z p(x,z;\theta)$。即我们需要根据联合概率分布函数 $p(x,z;\theta)$，优化边缘概率分布函数 $p(x;\theta)$</p></li><li><p><strong>EM 算法（期望最大化算法）算法步骤</strong></p><ul><li><p><strong>E 步</strong>：评估期望（下标所示分布下，括号内的随机变量的期望）</p><ul><li>假定参数已知，计算此时隐变量的后验概率（<strong>求出每一个样本属于类别的期望值</strong>）</li></ul><p>$$<br>Q(\theta;\theta^{(t)})&#x3D;\mathbb E_{p(z|x;\theta^{(t)})}[\log p(x,z;\theta)]<br>$$</p></li><li><p><strong>M 步</strong>：更新参数</p><ul><li>带入隐变量的后验概率，最大化样本分布的对数似然函数，求解相应的参数（<strong>通过当前数据求出最可能的分布参数</strong>）</li></ul><p>$$<br>\theta^{(t+1)} &#x3D; \arg\max_{\theta}Q(\theta;\theta^{(t)})<br>$$</p></li><li><p>参数说明：</p><ul><li><p>$p(z|x;\theta^{(t)})$：隐变量的后验分布（条件概率）</p></li><li><p>$Q$：联合分布的对数⁡ $\log p(x,z;\theta)$ 关于后验概率分布 $p(z|x;\theta^{(t)})$ 的期望</p><blockquote><p>条件概率：$P(B|A) &#x3D; \frac{P(AB)}{P(A)}$；</p><p>全概率公式：$P(A) &#x3D; \sum_{i&#x3D;1}^nP(B_i)P(A|B_i)$</p></blockquote></li></ul></li></ul></li><li><p>EM 的证明：证明算法可以保证每一步的 likelihood 增加<br>$$<br>\log p(x;\theta) &#x3D; \sum_z q(z) \log \frac{p(x,z;\theta)}{p(z|x;\theta)} \<br>&#x3D; \sum_z q(z) \log \frac{p(x,z;\theta)}{q(z)} + \sum_z q(z) \log \frac{q(z)}{p(z|x;\theta)} \<br>&#x3D;L(q,\theta) + KL(q||p(z|x;\theta)), \forall \theta,q(z)<br>$$</p><ul><li>其中：$KL(q||p) &#x3D; \int q(z)\log\frac{q(z)}{p(z)}dz$ 是 KL 散度，用于衡量两个分布的距离</li></ul><p>$$<br>L(p(z|x;\theta^{(t)}),\theta^{(t)}) &#x3D; \sum_z p(z|x;\theta^{(t)})\log\frac{p(x,z;\theta^{(t)})}{p(x|z;\theta^{(t)})}<br>$$</p></li><li><p><strong>训练高斯混合模型的例子</strong></p><ul><li><p>混合高斯分布：<br>$$<br>p(x) &#x3D; \sum_{k&#x3D;1}^{K}\pi_k\mathcal N(x;\mu_k,\Sigma_k)<br>$$</p><ul><li><p>可以将其表示为联合分布的边缘分布（？）<br>$$<br>p(x,z)&#x3D;p(x|z)p(z)&#x3D;\prod_{k&#x3D;1}^K[\pi_k\mathcal N(x;\mu_k, \Sigma_k)]^{z_k}<br>$$<br>其中，$\mathbf z &#x3D; [z_1, z_2, …, z_k]$ 服从分类分布，参数为 $\pi$</p><blockquote><p>分类分布：$P(X&#x3D;x_k\theta_1,\theta_2,…\theta_K) &#x3D; \prod_{k&#x3D;1}^K\theta_k^{x_k}$，其中$\sum_{k&#x3D;1}^K\theta_k &#x3D;1, x_k\in {0,1}, k\in {1,2,…,K}$</p></blockquote></li></ul></li><li><p><strong>E 步</strong>：</p><ul><li><p>后验分布：其中 $1_k$ 指第 $k$ 个元素为 1 的独热向量<br>$$<br>p(z&#x3D;1_k|x;\theta)&#x3D;\frac{p(x,z&#x3D;1_k;\theta)}{\sum_{i&#x3D;1}^Kp(x,z&#x3D;1_i;\theta)}<br>$$</p></li><li><p>对数联合分布：就直接在混合高斯分布上加 $\log$ 就行了<br>$$<br>\log p(x,z;\theta) &#x3D; \sum_{k&#x3D;1}^K z_k \cdot [\log \mathcal N(x|\mu_k, \Sigma_k) + \log \pi_k]<br>$$</p></li><li><p>计算期望：<br>$$<br>\mathbb E_{p(z|x;\theta^{(t)})}[\log p(x,z;\theta)] \<br>&#x3D; \sum_{k&#x3D;1}^K \mathbb E_{p(z|x;\theta^{(t)})}[z_k][\log \mathcal N(x|\mu_k, \Sigma_k) + \log \pi_k]<br>$$<br>其中，$E_{p(z|x;\theta^{(t)})}[z_k]$ 用后验分布的式子代替（将混合高斯分布代入 $p$，参数加上标）<br>$$<br>E_{p(z|x;\theta^{(t)})}[z_k] &#x3D; \frac{\mathcal N(x|\mu_k^{(t)}, \Sigma_k^{(t)})\pi_k}{\sum_{i&#x3D;1}^K \mathcal N(x|\mu_i^{(t)}, \Sigma_i^{(t)})\pi_i} &#x3D; \gamma_k^{(t)}<br>$$<br>最后代入到 $Q(\theta;\theta^{(t)})$：<br>$$<br>Q(\theta;\theta^{(t)})&#x3D;\sum_{k&#x3D;1}^K \gamma_k^{(t)} [\log \mathcal N(x|\mu_k, \Sigma_k) + \log \pi_k]<br>$$</p></li><li><p>将 $\mathcal N(x|\mu_k,\Sigma_k) &#x3D; \frac1{(2\pi)^{D&#x2F;2}|\sigma|^{1&#x2F;2}}\exp{-\frac12(x-\mu_k)^T\Sigma_k^{-1}(x-\mu_k)}$ 代入 $Q(\theta;\theta^{(t)})$：<br>$$<br>Q(\theta;\theta^{(t)})&#x3D; \sum_{k&#x3D;1}^K\gamma_k^{(t)} [-\frac12(x-\mu_k)^T\Sigma_k^{-1}(x-\mu_k)-\frac12|\Sigma_k| + \log \pi_k] + C<br>$$<br>$C$ 是常量（$\frac{1}{(2\pi)^{D&#x2F;2}}$ 部分）</p></li><li><p>最后，考虑所有样本：<br>$$<br>Q(\theta;\theta^{(t)})&#x3D; \frac1N\sum_{n&#x3D;1}^{N}\sum_{k&#x3D;1}^K \gamma_k^{(t)} [-\frac12(x^{(n)}-\mu_k)^T\Sigma_k^{-1}(x^{(n)}-\mu_k)-\frac12|\Sigma_k| + \log \pi_k] + C<br>$$</p></li></ul></li><li><p><strong>M 步</strong>：通过对 $\mu_k, \Sigma_k, \pi_k$ 求导并将它们设为零，得到最佳 $\theta$：<br>$$<br>\mu_{k}^{(t+1)} &#x3D; \frac1{N_k}\sum_{n&#x3D;1}^N\gamma_{nk}x_n \<br>\Sigma_k^{(t+1)} &#x3D; \frac{1}{N_k}\sum_{n&#x3D;1}^{N}\gamma_{nk}(x_n-\mu_k^{(t+1)})(x_n-\mu_k^{(t+1)})^T \<br>\pi_k^{(t+1)} &#x3D; \frac{N_k}{N}<br>$$<br>其中：$N_k &#x3D; \sum_{n&#x3D;1}^{N}\gamma_{nk}$，分配给第 $k$ 类的样本数</p></li></ul></li><li><p><strong>训练高斯混合模型的EM算法总结：</strong></p><ul><li><p>给定当前估算值：${\mu_k, \Sigma_k, \pi_k}<em>{k&#x3D;1}^K$，更新 $\gamma</em>{nk}$：<br>$$<br>\gamma_{nk} \leftarrow \frac{\mathcal N(x|\mu_k,\Sigma_k)\pi_k}{\sum_{i&#x3D;1}^{K}\mathcal N(x|\mu_i,\Sigma_i)\pi_i}<br>$$</p></li><li><p>跟据 $\gamma_{nk}$，更新 $\mu_k, \Sigma_k, \pi_k$<br>$$<br>N_k \leftarrow \sum_{n&#x3D;1}^N\gamma_{nk} \<br>\mu_{k} \leftarrow \frac1{N_k}\sum_{n&#x3D;1}^N\gamma_{nk}x_n \<br>\Sigma_k \leftarrow \frac{1}{N_k}\sum_{n&#x3D;1}^{N}\gamma_{nk}(x_n-\mu_k)(x_n-\mu_k)^T \<br>\pi_k \leftarrow \frac{N_k}{N}<br>$$</p></li></ul></li></ul><h2 id="8-集成模型"><a href="#8-集成模型" class="headerlink" title="8. 集成模型"></a>8. 集成模型</h2><p><strong>动机：</strong>希望可以利用多个弱分类器来组合出一个强分类器，这些弱分类器可能在数据集的某些地方表现很好，如果将在不同部分上表现良好的弱分类器结合在一起，就可以得到一个强分类器。</p><ul><li>例如有些分类器比较会识别猫，有些比较会识别狗。</li></ul><p><strong>结合的方法：</strong></p><ul><li>使用投票机制（无权重），即利用多数赞成来决定分类器的结果。<strong>bagging</strong></li><li>使用加权平均投票，即表现好的分类器获得更大的权重。<strong>boosting</strong></li></ul><p>目的：</p><ul><li>提高模型准确率</li><li>增加鲁棒性</li><li>减少过拟合和欠拟合</li><li>增加模型的多样性</li></ul><h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><p>基本流程如下：</p><ol><li>采用bootstrap方法对数据集采样（有放回采样）K个数据集。</li><li>根据这K个数据集训练出K个决策树。</li><li>最终使用<strong>大多数投票机制</strong>将这K个决策树合并为一个决策树（强分类器）。</li></ol><h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h4><p>思想：如果样本A分错了，则下次采样到样本A的几率上升，很像错题本一样。</p><ul><li><strong>弱分类器创建：</strong>重复执行以下步骤：识别被错误分类的例子，重新训练分类器，对错误分类的例子给予更多的权重 。</li><li><strong>弱分类器合并：</strong>将各分类器的预测结果进行<strong>加权平均</strong>。</li></ul><p>Adaboost算法流程如下：</p><p>分类器准确率越高，权重越高。</p><ul><li><p>迭代：计算第一个分类器  上的错误率，并为此分类器赋予权值 。最开始的时候，每一个样本的权重都是一样的，而现在需要将被错误分类的样本的权重以的倍率增强，被正确分类的样本的权重以的倍率减弱，不断迭代计算。</p></li><li><p>结合：每个弱分类器的输出乘以权重后加和做为最终输出。</p></li></ul><h4 id="无监督集成学习的挑战"><a href="#无监督集成学习的挑战" class="headerlink" title="无监督集成学习的挑战"></a>无监督集成学习的挑战</h4><p>例如考虑聚类，可能不同弱分类器分的聚类结果有不同的意思。</p><p>解决方法：</p><ul><li><p>硬对应：标签重命名和投票。</p></li><li><p>软对应：软对应的思想是通过优化多个聚类结果之间的对应关系，找到一个共识聚类，使得每个数据点的归属在所有聚类中尽量一致。</p><p>成员矩阵M的元素表示数据点与类别的归属关系。</p><p>每个 Sj 矩阵是一个 n×n 的矩阵，记录了数据点之间的对应关系。</p></li></ul><h2 id="9-Knn"><a href="#9-Knn" class="headerlink" title="9. Knn"></a>9. Knn</h2><p>这是个分类算法。</p><ul><li>已经有一批有标签的数据了。</li><li>然后再输入一批没有标签的数据。</li><li>选取没有标签的数据的前k个最近邻居，统计它们的标签，出现最多的标签成为这个数据的标签。</li></ul><p><strong>计算距离公式</strong></p><p>利用欧拉距离。</p><p><strong>分类结果受什么影响</strong></p><ul><li><strong>受到K值大小影响，如果k太小，容易受到噪声影响；如果k太大，则性能会下降，因为可能包括其他类别的邻居了。</strong></li><li>受原本有标签的样本数量影响，如果样本数量太小了，效果也不好。</li><li>需要对数据点进行归一化，因为需要计算距离，需要每个维度能表示的范围一致，避免被某个维度支配了。</li></ul><p><strong>如何确定k值</strong></p><ul><li><p>k折交叉验证：</p><p>将数据集划分为k等分，⼀份为测试集，其他为训练集，计算k次测试集上的正确率的平均值。⽐较knn不同的参数的k折交叉验证的结果，选取效果最好的。</p></li></ul><p><strong>优缺点</strong></p><ul><li>是懒惰算法，无需训练模型，可以适合动态数据。</li><li>原理简单，易实现。</li><li>对多分类问题很适合。</li><li>计算代价大，需要计算距离。</li><li>k值选取需要谨慎。</li></ul><h2 id="10-推荐系统"><a href="#10-推荐系统" class="headerlink" title="10. 推荐系统"></a>10. 推荐系统</h2><p>目的：目的是为了向用户推荐相关项，项可以是未看过的电影，网站或者是未买过的物品。推荐系统为客户实现一种个性化的推荐。</p><p>给定用户集合和项的集合，推出用户对项打分的集合。推荐系统可以总结为以下模型：<br>$$<br>\text{Utility Function: } u: X \times S \to R<br>$$<br>其中，$X$ 是用户的集合，$S$ 是项的集合，$R$ 是用户对项评分的集合，并且是关于项的有序集。</p><ul><li><p>推荐系统问题关键问题：如何为矩阵收集已知的评级，如何从已知的评级中推断未知的评级，如何评估推断的好坏。</p></li><li><p>冷启动问题：项没有被评分，用户的评分记录为空。</p></li></ul><p>推荐系统有有三种实现方式：协同（需要打分，冷启动问题，相似用户或者相似商品）、基于内容特征（基于内容的特征，无需依赖其他用户，避免冷启动，但是比较吃用户的历史资料）、基于知识（无冷启动问题，难获得知识）。</p><p>三种实现的优缺点：</p><ul><li><p>协同：需要进行打分，需要一个打分矩阵，容易有冷启动问题（对于基于用户的协同滤波算法，需要积累足够多的用户，并且用户有一定评分时才能找到一个用户的相似用户），主要思想是基于用户和商品的相似性来进行推荐，即假设用户A和用户B相似度很高，则推荐系统会认为它们喜欢的商品很接近，容易发现用户潜在的兴趣。不需要提取商品的特征，只依赖于用户的打分。有首评者问题，如果一个商品被打分的次数太少，那么也不会进行推荐；会有流行性传播的问题，一直推荐最近流行的商品，可能有用户不喜欢。</p></li><li><p>基于内容特征：注重于商品的特征，不需要依靠其他用户（无用户冷启动），可以实现比较精准的推荐，但是吃用户的历史资料并且难以获得商品的特征。如：一个人很喜欢看科幻电影，所以可以推荐科幻的书本给他。难以发现用户潜在的特征。</p></li><li><p>混合方法：可以利用加权平均组合协同和基于内容特征的推荐系统。例如将基于内容特征的特性加入到一个协同推荐系统中，当遇到用户冷启动（即用户刚刚打开网站），此时可以利用基于内容特征的推荐方法（利用用户的个人信息）为它推荐商品。</p><p>例子：电影推荐系统，一个新用户协同推荐系统无法为他推荐电影，但是可以基于内容特征推荐系统根据这个新用户的年龄和性别对他进行推荐电影</p></li></ul><blockquote><p><strong>物品-物品协同过滤方法和基于内容的推荐方法很相似</strong>：这两者都通过评估物品之间的相似性来进行推荐。然而，为什么协同过滤方法没有物品特征选择的问题呢？</p><p>这个问题的意思是，物品-物品协同过滤和基于内容的方法在推荐逻辑上看起来有相似之处：它们都评估物品之间的相似性，然后推荐相似的物品。但与基于内容的方法需要选择合适的物品特征来进行比较不同，协同过滤方法则是基于用户的行为数据来计算物品之间的相似性，完全不需要考虑物品的具体特征。因此，协同过滤方法不受特征选择的困扰。</p></blockquote><ul><li><p><strong>协同</strong></p><ul><li><p><strong>基于用户的协同</strong></p><p>思想：用户A和用户B如果对于过往的项的评分很接近，那么它们的喜好和兴趣是接近的。推荐系统为用户A提供一些与用户A相似度高的用户B的商品。</p><p><strong>给定一个打分矩阵，计算用户a和用户b的相似度：</strong></p><p><strong>根据用户之间的相似性，可以预测用户对于这个项的打分是多少：</strong></p></li><li><p><strong>基于商品的协同</strong></p><p>思想：如果用户喜欢商品A同时也喜欢商品B，那么喜欢商品A的用户也很可能喜欢商品B。</p><p>计算商品之间的相似度：</p></li></ul></li></ul><p>对推荐系统的推荐进行评判的指标有：召回率，准确率，F1评判指标，均方根误差。</p><ul><li><strong>记得看看基于内容的</strong>。</li></ul><h2 id="11-决策树"><a href="#11-决策树" class="headerlink" title="11. 决策树"></a>11. 决策树</h2><p>处理分类和回归问题，有监督学习算法。</p><p>基本思想：对属性进行逐层划分，每次划分将数据分割成不同的子集，以实现对目标的分类预测。</p><p>学习目的：为了实现一个泛化能力强的决策树。</p><p><strong>决策树建立流程如下：</strong></p><ol><li>根据算法选择 “最优属性” 。</li><li>根据最优属性划分数据集。</li><li>不断重复上述两个步骤，直到数据集内的数据都是同一类的。</li><li>进行剪枝。</li></ol><p>关键点在于<strong>如何选择最优属性</strong>进行划分。</p><ul><li>希望能选择一个属性，划分完之后的数据集子集尽量都属于同一个类别。</li></ul><p>有三种选择最优属性的判断方法：<strong>信息熵</strong>、<strong>信息增益</strong>、<strong>基尼指数</strong>。</p><p>ID3算法：使用信息增益选择测试属性。</p><p>信息增益倾向于取值较多的特征，因此我们对信息增益归⼀化（就是除以原本数据集D的熵），引入增益率：</p><p>不过还存在的问题是，它更倾向于取值数目比较少的属性 。</p><p>启发式方法：⼀种启发式方法是结合二者，先从候选划分属性中找出信息增益高于平均水平的属性，再从中选取增益率最高的。</p><p>CART：使用gini指标进⾏属性选择 </p><p>Gini值：反映了从D中随机抽取两个样本，其类别标记不一致的概率，因此Gini指标越小，代表这样分类越好。</p><p>决策树容易有<strong>过拟合问题</strong>：</p><ol><li><p><strong>预剪枝：在模型构建过程中对模型进⾏剪枝</strong> </p><p>在决策树⽣成过程中，对每个结点在划分前进⾏验证集的估计，如果划分结点对泛化能⼒不带来提 升，则停⽌划分并将当前结点记为叶结点。</p><p><strong>带来了欠拟合的风险。</strong></p></li><li><p><strong>后剪枝：构建完之后再进⾏剪枝</strong></p><p>后剪枝：先从训练集⽣成⼀棵完整的决策树，然后⾃底向上地对非叶结点进⾏考察，若将该结点对应的⼦树替换为叶结点能带来泛化性能提升则更换。</p><p><strong>泛化能力好，但是开销比预剪枝要大。</strong></p></li></ol><h2 id="12-支持向量机"><a href="#12-支持向量机" class="headerlink" title="12. 支持向量机"></a>12. 支持向量机</h2><p>目的：在空间中找出一个超平面，使得分类效果最好。找寻超平面的目标是最大化类内距离超平面最近的点（支持向量）的距离。</p><p>距离超平面最近的数据点成为支持向量，因为超平面是根据它们而选择的。</p><p><strong>软间隔：如果数据集不是线性可分的，可以增加一部分松弛变量，使得模型允许一些分类错误。</strong></p><ul><li>其实我觉得可以把它想象成一个正则项。</li></ul><p><strong>核函数：因为支持向量机只能处理线性可分的数据，对于线性不可分的数据集可以使用核函数进行升维，升维度之后可能数据集就会可分了。</strong></p><p>直接定义数据在高维空间的内积为核函数，不需要定义如何转换到高维空间。</p><p>记得高斯核。</p><p><strong>优缺点：</strong></p><ul><li><p>能够处理高维分类</p></li><li><p>能处理非线性可分数据（经过核函数）</p></li><li><p>只依赖支持向量（一小部分数据集）</p></li><li><p>鲁棒性好</p></li><li><p>计算复杂度高</p></li><li><p>无法处理多分类问题</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式笔记</title>
    <link href="/2025/01/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式笔记"><a href="#分布式笔记" class="headerlink" title="分布式笔记"></a>分布式笔记</h1><p>作者：哈利波特👑</p><h2 id="第一章-分布式简介"><a href="#第一章-分布式简介" class="headerlink" title="第一章 分布式简介"></a>第一章 分布式简介</h2><blockquote><p>分布式定义，分布式特点，目标（四个特性的含义），分布式的类型。</p></blockquote><h3 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h3><p>由若干个<strong>独立</strong>的计算机组成（硬件），这些计算机对于用户来说像是一个<strong>耦合</strong>系统（软件），这些计算机（节点）之间通过网络通信来互相协同，共同完成特定的任务。</p><p><strong>物理分布，逻辑集中，个体独立，整体统一。</strong></p><h3 id="分布式系统的特性"><a href="#分布式系统的特性" class="headerlink" title="分布式系统的特性"></a>分布式系统的特性</h3><ol><li><p><strong>构成组件被所有用户共享</strong></p><p>这意味着用户无需关心资源的具体位置或所属节点，可以像使用本地资源一样访问和使用这些共享资源。</p></li><li><p><strong>系统资源可能不允许访问</strong></p><p>尽管资源是共享的，但并不是所有资源对所有用户都开放。</p></li><li><p><strong>软件运行在不同处理器上的多个并发进程上</strong></p><p>在分布式系统中，软件不是在单一的处理器或计算机上运行，而是分布在多个处理器或节点上同时运行。</p></li><li><p><strong>允许多点控制</strong></p><p>多点控制指的是系统中的多个节点或用户能够同时控制和管理系统资源或服务。在一个分布式版本控制系统（如Git）中，多个开发者可以在不同的地点同时对代码库进行更改和管理。</p></li><li><p><strong>允许多点失效</strong></p><p>多点失效意味着系统能够容忍多个节点或组件的同时故障，而不会影响整个系统的正常运行。</p></li></ol><h3 id="分布式系统的四个目标"><a href="#分布式系统的四个目标" class="headerlink" title="分布式系统的四个目标"></a>分布式系统的四个目标</h3><h4 id="资源能够共享（方便访问数据）"><a href="#资源能够共享（方便访问数据）" class="headerlink" title="资源能够共享（方便访问数据）"></a><strong>资源能够共享（方便访问数据）</strong></h4><p>在云计算平台上，用户可以存储和访问存储在不同服务器上的数据，而无需了解数据存储的具体位置。</p><h4 id="透明性（用户不知道分布式系统内部是如何协作和计算的）"><a href="#透明性（用户不知道分布式系统内部是如何协作和计算的）" class="headerlink" title="透明性（用户不知道分布式系统内部是如何协作和计算的）"></a><strong>透明性（用户不知道分布式系统内部是如何协作和计算的）</strong></h4><p>用户在使用分布式文件系统时，无需关心文件存储在哪个服务器上，只需像操作本地文件一样进行访问和管理。</p><p>但是<strong>完全透明性是不可取的！</strong>因为：</p><ul><li><p><strong>难以找到失效的节点</strong></p></li><li><p><strong>分不清节点是失效还是性能变慢</strong></p><p>当一个节点响应变慢时，系统难以判断是节点真正失效还是只是暂时的性能下降。这会影响系统的故障处理策略，可能导致误判和资源浪费。</p></li><li><p><strong>会牺牲性能</strong></p><p>为了隐藏数据分布，系统可能需要频繁地进行数据复制和同步，这会增加网络负载和延迟，影响系统的响应速度。</p></li><li><p><strong>有一致性问题</strong></p><p>在分布式文件系统中，当一个文件被修改时，需要将修改同步到所有副本节点。这一过程需要时间，如果同步延迟过长，用户可能会看到不一致的文件版本。</p></li></ul> <h4 id="开放性"><a href="#开放性" class="headerlink" title="开放性"></a><strong>开放性</strong></h4><p>通过标准化的接口使得不同设备和应用可以轻松地进行通信和数据交换。</p><p><strong>标准化的接口：</strong>使用大家都认可的通信规则和接口，让不同的系统和设备能够互相“说同一种语言”。</p><ul><li><strong>策略（做什么）</strong>与<strong>机制（如何做）</strong>分离</li></ul><h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a><strong>可扩展性</strong></h4><p>分布式数据库系统可以通过增加更多的服务器节点来处理更大的数据量和更多的并发请求，而不影响查询速度和响应时间。</p><ul><li><p>规模扩展性</p><p>系统能够在用户数量和进程（或服务）数量不断增加的情况下，依然保持高效运转。</p></li><li><p>地域扩展性</p><p>系统中的节点能够分布在很远的地理位置（甚至跨国跨洲），但整体依旧能高效运作，避免因网络延迟、带宽等问题导致系统性能急剧下降。</p><p>CDN</p></li><li><p>管理扩展性</p><p>大型企业或跨国公司在多个地区有独立的IT管理团队，系统需要支持多层权限和多域管理，保证各团队在各自的权限范围内管理资源，同时又能协同工作。</p></li></ul><p>可扩展技术如下：</p><ul><li><p>隐藏通信时间</p><p>就是想办法在等待远程响应的同时，让系统做其他有用的事情。</p></li><li><p>分布</p><p>在多个机器上划分数据和计算</p></li><li><p>副本</p></li></ul><h3 id="分布式系统的分类"><a href="#分布式系统的分类" class="headerlink" title="分布式系统的分类"></a>分布式系统的分类</h3><h4 id="分布式内存共享系统"><a href="#分布式内存共享系统" class="headerlink" title="分布式内存共享系统"></a><strong>分布式内存共享系统</strong></h4> <p>分布式内存共享系统是一种使多个节点（计算机）看起来像一个统一的共享内存空间的系统。通过这种方式，分布在不同节点上的进程可以像在单一系统中一样访问和操作共享内存，从而简化并行编程模型。</p><h4 id="集群计算系统"><a href="#集群计算系统" class="headerlink" title="集群计算系统"></a><strong>集群计算系统</strong></h4><p>想象一下，你和你的朋友们一起完成一个大型项目：</p><ul><li><strong>单台计算机</strong>：就像一个人独自完成整个项目，可能速度较慢，遇到问题时无法继续。</li><li><strong>集群</strong>：就像一个团队，每个人负责不同的部分，大家一起工作，完成速度更快，而且如果某个人有事，其他人还能继续完成任务。</li></ul><h4 id="网格计算系统"><a href="#网格计算系统" class="headerlink" title="网格计算系统"></a><strong>网格计算系统</strong></h4><p><strong>想象你在组织一个全球性的拼图比赛：</strong></p><ul><li><strong>单台计算机</strong>：就像一个人独自拼一幅巨大的拼图，可能需要很长时间才能完成。</li><li><strong>网格计算</strong>：就像你邀请世界各地的朋友们，每个人负责拼图的一部分，大家一起合作，很快就能完成整个拼图。</li></ul><h2 id="第二章-分布式系统架构"><a href="#第二章-分布式系统架构" class="headerlink" title="第二章 分布式系统架构"></a>第二章 分布式系统架构</h2><blockquote><p>两种架构（系统、软件）、软件：四种（分层、事件… 四种特性）、系统三种（集中、非集中、混合特点）</p><p>重点：C-S集中式架构、P2P非集中式：非结构P2P如何查询、DHT构建与查询</p></blockquote><h3 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h3><h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><p>主要用于客户-服务器模型。</p><p>每层之间是独立的，并且每层只知道下一层提供的服务而不关心是如何实现的。</p><h4 id="面向对象结构"><a href="#面向对象结构" class="headerlink" title="面向对象结构"></a>面向对象结构</h4><p>每个对象都有自己的数据和方法（函数），假设对象A调用方法B，但是方法B其实在对象B上，对象A对对象B执行RPC。</p> <h4 id="基于事件结构"><a href="#基于事件结构" class="headerlink" title="基于事件结构"></a>基于事件结构</h4><p>发布者发布事件，订阅者订阅感兴趣的事件。当事件发生时，发布者将事件发送到一个中介，订阅者接收并处理这些事件。</p><p>将时间解耦了，发布者发布完事件之后就可以做自己的事情（异步）。</p><h4 id="共享数据空间结构"><a href="#共享数据空间结构" class="headerlink" title="共享数据空间结构"></a>共享数据空间结构</h4><p>多个进程或节点通过共享一个共同的数据空间进行通信和协作。</p><p>将空间解耦了，节点并不知道自己使用的是谁的数据。</p> <h3 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h3><p>确定软件组件、软件组件之间的交互与位置，就是软件体系结构的一个实例，也是软件体系结构的一个具体应用。</p><h4 id="集中式体系结构"><a href="#集中式体系结构" class="headerlink" title="集中式体系结构"></a>集中式体系结构</h4><p>整个系统包含一个控制中心，协同系统的运行。</p><p>有<strong>客户服务器模型</strong>：</p><ul><li>Server进程：实现特定服务的进程；</li><li>Client进程：通过往服务器发送请求来请求服务、然后等待服务器回复的进程；</li></ul><blockquote><p>像软件体系结构的分层和面向对象都是客户服务器模型。</p></blockquote><h5 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h5><p>我的理解是跟数据库的分层是一样的。</p> <p>层与层之间有<strong>接口</strong>，同一层的两个节点有<strong>通信</strong>和<strong>提供的服务</strong>。</p><h4 id="非集中式组织结构-P2P"><a href="#非集中式组织结构-P2P" class="headerlink" title="非集中式组织结构(P2P)"></a>非集中式组织结构(P2P)</h4><p>系统没有一个整体的控制中心，各个节点独立自主运行。</p><ul><li><p>垂直分布：系统逻辑分层，不同层次分布式不同的机器上；</p></li><li><p>水平分布：客户或者服务器在物理上分成逻辑上相等的几个部分， 每个部分相对独立，且分布在不同的机器上；</p></li><li><p>点对点系统（P2P）：水平分布，构成点对点的系统的进程完全相同（既是客户端又是服务器、无中心化系统）。</p><ul><li><p>结构化的P2P系统：P2P系统中的节点按照特定的分布式数据结构组织，like chord环形结构。</p></li><li><p>无结构化的P2P系统 ：点的邻居是随机选择的。</p></li><li><p>混合化的P2P系统：某些组织是具备特定结构的。</p></li></ul></li></ul><h5 id="分布式哈希表（DHT）"><a href="#分布式哈希表（DHT）" class="headerlink" title="分布式哈希表（DHT）"></a>分布式哈希表（DHT）</h5>  <p>可以不依赖一个中心服务器，每个节点维护一部分的哈希数据。</p><ul><li><strong>加入</strong>：新节点加入DHT网络时，会根据哈希函数分配一部分键空间，接管部分数据存储，保持哈希表的平衡。</li><li><strong>离开</strong>：节点离开时，其存储的数据会被重新分配到其他节点，确保数据的完整性和可访问性。</li></ul><h5 id="非结构化P2P数据查询"><a href="#非结构化P2P数据查询" class="headerlink" title="非结构化P2P数据查询"></a>非结构化P2P数据查询</h5><p>节点之间的连接是动态且随机的，网络的整体拓扑结构没有严格的规则。</p><p>维持一个动态随机的邻接表，确保每个节点只与网络中一部分随机选取的其他节点直接连接，从而降低维护整个网络连接的复杂性。</p><ul><li><p><strong>泛洪方式：</strong></p><p>因为只能看到部分视图，所以像其他所有邻居节点发送数据查询请求，如果邻居也没有的话就继续迭代下去发送数据请求。会有很多冗余请求。</p></li><li><p><strong>随机游走：</strong></p><p>随机选择一个邻居发送数据查询请求，没有就找下一个邻居。这种方式可能会找不到数据。</p></li></ul><p>因为非结构化P2P很难查询数据，所以引入<strong>超级对等节点</strong>。</p><h6 id="超级对等节点"><a href="#超级对等节点" class="headerlink" title="超级对等节点"></a>超级对等节点</h6><p>将非结构化的P2P系统拓扑划分为一个个自治区（子网），然后找数据的时候只需要找自治区的超级对等节点（边缘路由器）就行了。</p> <p>选择超级对等节点的条件：选择运算力大、存储空间大或者看自治区的拓扑与节点位置决定。</p><h4 id="混合组织结构"><a href="#混合组织结构" class="headerlink" title="混合组织结构"></a>混合组织结构</h4><p>系统中既包含集中式结构也包含了非集中式结构。</p><p>在很多场景中，客户端-服务器架构（集中式）是和P2P架构（非集中式）整合在一起的。</p><p>例如像计网的CDN：</p> <p>首先有客户请求视频（集中式架构），但是存储视频的服务器可能将视频存到多个CDN服务器上，客户可以直接去找CDN服务器拿视频。CDN服务器既是服务器也是客户（非集中式结构）。</p><h3 id="分布式系统的自我管理"><a href="#分布式系统的自我管理" class="headerlink" title="分布式系统的自我管理"></a>分布式系统的自我管理</h3><p>出现问题能够自我优化、恢复。在需要完成自适应功能时， 系统架构和软件架构之间的界线逐渐模糊。</p><p>采用反馈控制循环来控制：</p><p>like 强化学习。</p><h2 id="第三章-分布式系统的进程与虚拟化"><a href="#第三章-分布式系统的进程与虚拟化" class="headerlink" title="第三章 分布式系统的进程与虚拟化"></a>第三章 分布式系统的进程与虚拟化</h2><blockquote><p>虚拟化的含义、类型，docker的定义，有&#x2F;无状态服务器优缺点，服务器集群（负载均衡），代码迁移。</p></blockquote><h3 id="为什么要利用线程而不是进程"><a href="#为什么要利用线程而不是进程" class="headerlink" title="为什么要利用线程而不是进程"></a>为什么要利用线程而不是进程</h3><ul><li>线程是共享内存的，切换上下文不需要操作系统介入。</li><li>线程切换上下文的开销比进程小，进程切换上下文需要操作系统内核操作。</li><li>创建和删除线程的开销比进程小很多，并且速度快很多。</li></ul><p>但是因为线程是共享内存的，所以其实不安全。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>虚拟化是通过软件技术将物理计算资源抽象和隔离，使多个独立的虚拟实例能够在同一硬件上同时运行。</p><p><strong>情景描述：</strong> 假设你有一台运行Windows操作系统的电脑，但你同时需要使用Linux系统来完成某些特定任务。</p><p><strong>虚拟化的应用：</strong></p><ol><li><strong>安装虚拟机软件</strong>：<ul><li>你可以安装像VirtualBox或VMware这样的虚拟机软件，这些软件能够在你的Windows系统上创建虚拟环境。</li></ul></li><li><strong>创建虚拟机</strong>：<ul><li>在虚拟机软件中，你创建一个新的虚拟机实例，并为其分配一定的硬件资源（如CPU、内存、存储空间）。</li></ul></li><li><strong>安装Linux操作系统</strong>：<ul><li>在这个虚拟机中，你安装Linux操作系统。现在，你的电脑上既运行着Windows系统，又通过虚拟机运行着Linux系统。</li></ul></li></ol><p>通过<strong>模拟接口</strong>，虚拟化软件为虚拟机提供了一个<strong>虚拟的、标准化的硬件环境</strong>。这使得虚拟机中的操作系统和应用程序<strong>无需感知底层物理硬件的具体细节</strong>，能够像在真实硬件上运行一样操作。</p><h3 id="虚拟机化的不同方式"><a href="#虚拟机化的不同方式" class="headerlink" title="虚拟机化的不同方式"></a>虚拟机化的不同方式</h3><ul><li><p><strong>进程虚拟机</strong>：分离的指令集合，实际是运行在操作系统之上的解释器或者模拟器。</p><p>它为单个应用程序或进程提供一个抽象的执行环境，使其能够在不同的硬件和操作系统平台上运行，而无需修改源代码。</p><p>例如像JVM，允许Java程序在任何安装了JVM的设备上运行，无需关心具体的操作系统和硬件架构。</p></li><li><p><strong>原生虚拟机监控器</strong>：底层的指令，同时具有跑在硬件上的最小的操作系统。</p><p>是一种直接运行在物理硬件上的虚拟化层，不依赖于宿主操作系统，所以性能高。</p></li><li><p><strong>主机虚拟机监控器</strong>：底层指令，但是需要一个完整的 OS。</p><p>是一种运行在宿主操作系统之上的虚拟化软件。</p></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>镜像—镜像就像是一份<strong>食谱</strong>。，docker 将所有app都标准化，需要使用就拉取镜像。 </li><li>仓库—仓库就相当于是一个<strong>烹饪书</strong>，里面存放了各种食谱，docker将所有镜像存储于仓库。 </li><li>容器—容器就是就像是根据食谱<strong>实际制作出来的菜肴</strong>，每个容器是独立的。这就体现了它的隔离性；</li></ul><h3 id="虚拟机与Docker的比较"><a href="#虚拟机与Docker的比较" class="headerlink" title="虚拟机与Docker的比较"></a>虚拟机与Docker的比较</h3><ul><li><strong>虚拟机：</strong>虚拟机是在物理硬件之上运行的完整计算机系统。每个虚拟机都有自己的操作系统（Guest OS），并通过虚拟化软件（如VMware、Hyper-V、VirtualBox）与物理硬件交互。</li><li><strong>Docker：</strong>通过容器（Containers）运行应用程序。</li></ul><p>虚拟机隔离性更好，每个虚拟机有自己独立的操作系统；Docker性能更好。</p><h3 id="服务器与状态"><a href="#服务器与状态" class="headerlink" title="服务器与状态"></a>服务器与状态</h3><ul><li><p><strong>无状态服务器</strong></p><p>在处理完请求后，从来不保存关于客户端的精确的信息。</p><ul><li>不记录一个文件是否被打开</li><li>不去追踪客户的信息</li><li>客户端和服务器完全独立</li></ul><p>可能会导致：</p><ul><li>客户和服务器的不一致问题减少，因为客户的记录和服务器的记录不需要一致。</li><li>由于服务器不能预测客户端的行为，可能导致性能下降（例如有状态服务器可以记录上次这个文件看到哪里了，但是无状态服务器不行）。</li></ul></li><li><p><strong>有状态服务器</strong></p><p>记录客户端的状态信息。</p><ul><li>记录客户端打开的文件，下次访问可以提前预取。</li><li>需记录客户的信息。</li></ul><p>可能会导致：</p><ul><li>有状态的服务器的性能非常高。</li><li>可靠性问题是一个主要的问题（可能客户端和服务器端的缓存不一致）。</li></ul></li></ul><h3 id="服务集群的负载均衡"><a href="#服务集群的负载均衡" class="headerlink" title="服务集群的负载均衡"></a>服务集群的负载均衡</h3><p>负载均衡：用于将网络或应用程序的流量分配到多个服务器上，以确保系统的高可用性、可靠性和高性能。</p><p>简单来说，首先先基于内容可感知的分派：</p><p><strong>客户端发送 Setup Request (连接请求)</strong></p><ul><li><strong>Client → Switch</strong><br>客户端向负载均衡器（Switch）发送一个连接请求（Setup Request），这个请求可能包含连接所需的信息。</li></ul><p><strong>Switch 将请求转发给分发器 (Distributor)</strong></p><ul><li><strong>Switch → Distributor</strong><br>负载均衡器将 Setup Request 转发给分发器。分发器会负责根据调度算法决定将请求分配给哪个应用服务器。</li></ul><p><strong>分发器选择应用服务器</strong></p><ul><li><strong>Dispatcher Selects Server</strong><br>分发器根据某种调度策略（如最少连接数、权重等）选择最合适的应用服务器来处理该请求。</li></ul><p><strong>TCP 连接的转交 (Hand Off)</strong></p><ul><li><strong>Distributor → Application Server</strong><br>分发器选定服务器后，将该 TCP 连接的处理权交给具体的应用服务器。这一步实现了对客户端请求的分派。</li></ul><p><strong>Switch 被通知处理其他消息</strong></p><ul><li><strong>Distributor → Switch</strong><br>分发器将负载分配信息通知 Switch，使其知道后续的数据包应如何转发。</li></ul><p><strong>应用服务器处理请求并返回响应</strong></p><ul><li><strong>Application Server → Client</strong><br>应用服务器完成客户端请求的处理，并将结果直接返回给客户端，通常通过 Switch 转发。</li></ul><p>就是可以考虑到的条件更多了，例如像查看请求的内容去分发合适的服务器，之前是只分发TCP连接少的服务器。</p><h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><p>迁移模型中，进程由三个部分组成：</p><ul><li>代码片段（code）：包含实际执行的代码； </li><li>数据片段（resource）：包含状态 ；</li><li>执行状态（exec）：包含线程执行对象代码的上下文；</li></ul><ul><li><p>弱移动性：<strong>仅仅移动代码和数据片段</strong></p><ul><li>相对简单，特别是如果代码是可移植的</li><li>需要区分两种模式：代码推送（push）和代码拉取（pull）</li></ul></li><li><p>强移动性：<strong>移动组件，包括执行状态</strong></p><ul><li><p>迁移：将整个对象从一个机器移动到另一个机器；</p><p><strong>冷迁移，两个对象的执行状态可能不一样。</strong></p></li><li><p>克隆：开始克隆，将其设置为相同的执行状态；</p><p><strong>热迁移，两个对象的执行状态一样。</strong></p></li></ul></li></ul><h3 id="虚拟机迁移"><a href="#虚拟机迁移" class="headerlink" title="虚拟机迁移"></a>虚拟机迁移</h3><p>无论哪种方式，虚拟机都会停机。</p><ul><li>预拷贝：将内存页面<strong>推送</strong>到新的机器，在迁移过程中重新发送被修改过的页面； </li><li>停机-迁移-启动：停止当前的虚拟机；迁移内存，然后重新启动虚拟机； </li><li>按需拉取：让新的虚拟机按需<strong>拉取</strong>内存页面：在新的虚拟机上立即创建进程，并且按需拷贝内存页面；</li></ul><h2 id="第四章-通信"><a href="#第四章-通信" class="headerlink" title="第四章 通信"></a>第四章 通信</h2><blockquote><p>RPC的基本过程、通信类型（异步同步）、面向消息通信（sockets的操作：创建发送接收）、消息队列类型，实现，管理器，路由，转发器等作用</p><p>多播通信，Gossip通信（解决传播）（反熵，流言工作过程）</p></blockquote><h3 id="通信类型"><a href="#通信类型" class="headerlink" title="通信类型"></a>通信类型</h3><p> <strong>瞬态 VS 持久通信</strong></p><ul><li><p>瞬态通信：当消息不能传递到另外一个服务器的时候，丢弃消息；</p><p>依赖双方同时在线，例如像线上聊天系统。</p></li><li><p>持久通信：消息存储在通信服务器直到消息被传递出去；</p><p>消息在中间保存，适用于可靠传输的系统，例如像邮件系统。</p></li></ul><p><strong>异步通信VS 同步通信</strong></p><ul><li>同步通信：客户端需要等待服务器响应（阻塞）。客户端等待回应的时候不能做其他工作。</li><li>异步通信：客户端不需要等待服务器响应。</li></ul><h3 id="RPC的基本过程"><a href="#RPC的基本过程" class="headerlink" title="RPC的基本过程"></a>RPC的基本过程</h3><p>程序在不同计算机上调用另一个计算机的程序。</p><p>透明性：使得用户像在本地调用函数一样。</p><p>基本流程如下：</p><p><strong>客户端流程</strong></p><ol><li><p><strong>客户端调用本地代理（Stub）</strong>：</p><ul><li>客户端调用一个本地方法（例如 <code>doit(a, b)</code>），看起来像本地函数调用。</li><li>实际上，这个方法会被传递给客户端的“Stub”（代理）处理。</li></ul></li><li><p><strong>客户端 Stub 构建消息</strong>：</p><ul><li><p>客户端的 Stub 将调用的函数名（<code>doit</code>）、参数类型（如 <code>type1</code>）和参数值（如 <code>val(a)</code>）打包成一个消息。</p></li><li><p>Stub 的工作是将本地调用转换为可以通过网络发送的消息（<strong>序列化</strong>）。</p><blockquote><p>函数参数可能是复杂的对象、列表、字符串等，无法直接通过网络传输</p></blockquote></li></ul></li><li><p><strong>客户端操作系统发送消息</strong>：</p><ul><li>客户端 Stub 调用本地操作系统（Client OS）来通过网络发送消息到服务端。</li></ul></li></ol><p><strong>服务端流程</strong></p><ol><li><strong>服务端操作系统接收消息</strong>：<ul><li>消息通过网络到达服务端的操作系统（Server OS）。</li><li>操作系统将消息传递给服务端的 Stub。</li></ul></li><li><strong>服务端 Stub 解包消息</strong>：<ul><li>服务端的 Stub 从消息中提取出函数名和参数，将其翻译成服务端可以理解的本地调用。</li></ul></li><li><strong>服务端调用实际方法</strong>：<ul><li>服务端 Stub 调用对应的实际实现方法（例如 <code>doit</code> 方法）。</li><li>方法使用解包后的参数（如 <code>val(a)</code> 和 <code>val(b)</code>）进行计算，返回结果。</li></ul></li></ol><p><strong>服务端返回结果到客户端</strong></p><ol><li><strong>服务端 Stub 构建响应消息</strong>：<ul><li>服务端 Stub 将返回的结果打包成一个响应消息。</li></ul></li><li><strong>服务端操作系统发送消息</strong>：<ul><li>服务端 Stub 调用操作系统，将响应消息通过网络发送回客户端。</li></ul></li><li><strong>客户端操作系统接收消息</strong>：<ul><li>客户端操作系统接收响应消息，并将其传递给客户端的 Stub。</li></ul></li><li><strong>客户端 Stub 解包消息并返回结果</strong>：<ul><li>客户端 Stub 解包消息，提取出返回值并将其交给调用者。</li><li>对客户端调用者来说，整个过程就像是一次本地函数调用。</li></ul></li></ol><h3 id="面向消息的通信"><a href="#面向消息的通信" class="headerlink" title="面向消息的通信"></a>面向消息的通信</h3><h4 id="面向消息的瞬时通信：Berkeley套接字"><a href="#面向消息的瞬时通信：Berkeley套接字" class="headerlink" title="面向消息的瞬时通信：Berkeley套接字"></a>面向消息的瞬时通信：Berkeley套接字</h4><p>记得看看服务器的accept和客户的connect是同步点。</p><p><strong>是面向消息的同步、瞬态通信。</strong></p><h4 id="面向消息的持久通信：消息队列系统（MPI）"><a href="#面向消息的持久通信：消息队列系统（MPI）" class="headerlink" title="面向消息的持久通信：消息队列系统（MPI）"></a>面向消息的持久通信：消息队列系统（MPI）</h4><p>通过中间件层的队列支持实现异步持久的通信。队列相当于通信服务器的缓冲区（持久通信）。</p><p><strong>队列管理器</strong>：负责管理队列，应用程序仅将消息放在本地队列中，然后由队列管理者将消息路由到其他地方。</p><p>消息队列系统的一般体系结构：</p> <p><strong>消息转换器</strong>：消息队列系统假定存在一个共同的消息协议；<strong>应用程序会在消息的格式上达成一致</strong>（即消息的结构和数据表示）</p><p>是消息队列系统的核心组件，负责管理消息的传递、存储和分发。</p><p>实际上实现的是<strong>队列</strong>！！</p><h3 id="面向流的通信"><a href="#面向流的通信" class="headerlink" title="面向流的通信"></a>面向流的通信</h3><h4 id="多播通信"><a href="#多播通信" class="headerlink" title="多播通信"></a>多播通信</h4><p>其本质是将分布式系统组织成一个<strong>覆盖网络</strong>，然后利用这个网络分发数据；覆盖网络的构建方法：</p><ul><li>组织成树，导致每对节点之间只有唯一的路径（一对多）；</li><li>组织成网络结构，每个节点都有多个邻居节点（健壮性高）；</li></ul><h3 id="Gossip数据通信"><a href="#Gossip数据通信" class="headerlink" title="Gossip数据通信"></a>Gossip数据通信</h3><p>本质是一种分布式的去中心化的协议，可以解决状态在集群中的传播和最终一致性的保证。</p><p>假设信息传播过程中不存在写-写冲突：</p><ul><li>更新是从一个节点开始的</li><li>仅会向几个邻居传播副本（像病毒一样传播）</li><li>更新是<strong>滞后</strong>的</li><li>最终，每一个更新都会到达所有副本。（最终一致性）</li></ul><h4 id="反熵模型"><a href="#反熵模型" class="headerlink" title="反熵模型"></a>反熵模型</h4><p>反熵模型是 结点P随机选取另一节点Q，然后与Q交换更新信息，减少系统的不一致性（降低熵）。</p><ol><li>P只是把它自己的更新信息发出给Q，即为push的方法 </li><li>P只是从Q那里获得更新信息，即为基于pull的方法 </li><li>P和Q相互发送更新信息给对方，基于push-pull的方法</li></ol><h2 id="第五章-命名系统"><a href="#第五章-命名系统" class="headerlink" title="第五章 命名系统"></a>第五章 命名系统</h2><blockquote><p>给实体名字，命名是什么（标识符），指纹表如何构建、查询。结构化命名（DNS解析）组织以及如何DNS解析。</p></blockquote><p>简单来说，分布式命名系统实现的作用就是我可以通过一个“名字”来查询我要的资源。</p><p><strong>命名</strong>：是指在系统中为对象、资源或实体分配一个唯一的标识符，以便能够识别和引用这些对象、资源或实体。</p><p><strong>名称</strong>：用名字标识分布式系统中的实体对象，由字符组成的字符串。</p><p>一个独立于实体地址的名称通常是比较合理的，而且更为灵活， 这样的名称是与位置无关（位置可能会变）。</p><p><strong>标识符</strong>：一个标识符至多引用一个实体； 每一个实体最多由一个标识符引用； 一个标识符始终引用一个实体（标识符永远不会重新使用）</p><p>一个标识符不一定是一个单纯的名字，它可以包含特定的内容。</p><p>原则上，命名系统含有一个名称到地址的绑定，即一个（name, address）对的表。</p><h3 id="分布式散列表"><a href="#分布式散列表" class="headerlink" title="分布式散列表"></a>分布式散列表</h3><ul><li>每一个节点被赋予一个由m位构成的标识符； </li><li>每一个实体被赋予一个唯一的m位的健值； </li><li>健值为k 的实体存储在满足id &gt;&#x3D; k 的最小标识符节点上，成为k 的后继者, succ(k)。</li></ul><p>指状表的第 <code>i</code> 项（<code>FTp[i]</code>）指向的是距离当前节点 <code>p</code> 至少 $$2^{i-1}$$ 位置的第一个节点。</p><p>查找逻辑：当前节点 <code>p</code> 检查它的指状表，并将查询请求转发给一个更接近目标节点的节点。</p><h4 id="查找过程："><a href="#查找过程：" class="headerlink" title="查找过程："></a><strong>查找过程：</strong></h4><ul><li>使用指状表逐步跳跃查找目标节点，每次跳跃使范围缩小一半，最终找到目标节点。</li><li>查找效率为 O(log N)。</li></ul><h4 id="节点加入："><a href="#节点加入：" class="headerlink" title="节点加入："></a><strong>节点加入：</strong></h4><ul><li>新节点计算其位置，更新后继和前驱关系。</li><li>将数据从后继节点转移到新节点。</li><li>并且其他节点也需要更新自己的指纹表。</li></ul><h4 id="节点退出："><a href="#节点退出：" class="headerlink" title="节点退出："></a><strong>节点退出：</strong></h4><ul><li>离开节点通知后继和前驱节点，将范围和数据转移给后继节点。</li><li>通过稳定化更新指状表，维持系统一致性。</li></ul><h3 id="分层定位方法"><a href="#分层定位方法" class="headerlink" title="分层定位方法"></a>分层定位方法</h3><p>创建一个大规模的搜索树，底层的网络被划分成多个分层的域。每一个域由一个目录节点表示。</p><p><strong>树结构查询的过程总结</strong></p><ul><li><strong>起点</strong>：从叶节点开始查找。</li><li><strong>向下搜索</strong>：如果当前节点知道目标实体的位置，则沿着指向子节点的指针继续向下查找。</li><li><strong>向上回退</strong>：如果当前节点无法找到目标，则回退到父节点，逐步向上查找。</li><li><strong>终止条件</strong>：<ul><li>找到目标实体，查找结束。</li><li>回退到根节点，如果根节点仍然无法找到目标实体，则查找失败。</li></ul></li></ul><p><strong>树结构插入的关键</strong></p><ul><li><p>插入请求被转发到知道实体 E 地址对的第一个节点；</p></li><li><p>建立一条从第一个知道实体 E 地址的节点到实体 E 的指针链</p></li></ul><h3 id="名称解析-闭包机制（closure-mechanism）"><a href="#名称解析-闭包机制（closure-mechanism）" class="headerlink" title="名称解析-闭包机制（closure mechanism）"></a>名称解析-闭包机制（closure mechanism）</h3><p><strong>名称解析：</strong> 给定一个路径名，查找出存储在由该名称所指向的节点中的任何信息，查询名称的过程称为名称解析。</p><p>简单来说，名称解析就是根据给定的“名称”（通常是路径名或标识符），找到对应资源的实际位置或其存储的信息。</p><p><strong>闭包机制</strong>：知道如何启动以及在何处启动名称解析通常称为闭包机制</p><p>没有闭包机制，名称解析无法顺利启动，因为系统不知道解析的入口和规则。闭包机制确保了解析能够启动并顺利完成。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>硬链接（Hard link）</strong>:我们所描述的路径名. 即用于在命名图中按照特定路径搜索节点的名字就是“硬链接”；</p><p>无论你用哪个硬链接访问文件，它们都是同一个文件。</p><p>删除一个硬链接不会影响另一个，因为实体只在所有硬链接删除后才会真正从磁盘上清除。</p><p><strong>软链接（Soft link）</strong>：允许一个节点 N 包含另外一个节点名字. 用叶节点表示实体，而不是存储实体的地址和位置，该节点存储绝对路径名。</p><p>首先解析N 的名字；读取N 的内容返回名字；利用返回的名字进行名字解析；</p><p>软连接是一个独立的实体, 实体内容是指向的实体的绝对路径.</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p><strong>挂接点:  <strong>挂接点是</strong>本地命名空间</strong>中的一个<strong>目录节点</strong>，它用来存储外部命名空间的入口。</p><p><strong>挂载点:  <strong>挂载点是</strong>外部命名空间</strong>中的目录节点，作为外部命名空间的入口点。它是外部命名空间的“根”（Root），从这里开始，外部命名空间的资源可以被访问。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间</strong>是用于区分名称的一种逻辑结构或范围，确保不同实体的名称在其范围内唯一。</p><p>三层名称空间：</p><ul><li>全局层：由最高级别的节点构成，即由根节点以及其他逻辑上靠近根节点的目录节点组成。特点是：<strong>稳定，目录表很少改变， 可以代表组织</strong>。</li><li>行政层：由那些在单个组织内一起被管理的目录节点组成。行政层中的目录节点所具有的特点是代表属于同一组织或行政单位的实体组；<strong>相对稳定，但是比全局层的目录变化频繁；</strong></li><li>管理层：由<strong>经常改变</strong>的节点组成。如代表本地主机的节点及本地文件系统等，由终端用户维护；</li></ul><h3 id="迭代命名解析"><a href="#迭代命名解析" class="headerlink" title="迭代命名解析"></a>迭代命名解析</h3><p><strong>迭代命名解析</strong>是一种<strong>逐步查询</strong>的名称解析方式。在这种方式中，<strong>客户端（请求方）</strong>负责主动与每一级名称服务器通信，并根据返回的部分解析结果，自己决定下一步要查询的服务器，直到解析完成找到目标资源。</p><p>客户端一直参与，时延比较大。</p><h3 id="递归命名解析"><a href="#递归命名解析" class="headerlink" title="递归命名解析"></a>递归命名解析</h3><p><strong>递归命名解析</strong>是一种<strong>自动查询</strong>的名称解析方式。在这种方式中，<strong>客户端（请求方）</strong>只向一个命名服务器发出请求，这个服务器会代替客户端完成所有后续的查询，并最终将结果返回给客户端。</p><p>根命名服务器负载很大。</p><h2 id="第六章-协同"><a href="#第六章-协同" class="headerlink" title="第六章 协同"></a>第六章 协同</h2><blockquote><p>时钟同步、逻辑时钟、向量时钟（必考）、互斥（集中，非集中，分布式）、选举算法</p></blockquote><p>同步（进程之间步调一致）：事件之间进行协调，在<strong>时间</strong>上达成一致。</p><p>隐含意义：是信息交换，告诉其他进程当前进程的状态。</p><p>分布式系统中的协作要比单节点、多处理器系统复杂得多。</p><p>因为每个节点都有自己的时钟，很难同步（步调一致）。</p><h3 id="时钟的内同步和外同步"><a href="#时钟的内同步和外同步" class="headerlink" title="时钟的内同步和外同步"></a>时钟的内同步和外同步</h3><p><strong>精度</strong>：保证任意两个节点之间的时钟偏差在一个给定范围内。（是相对的）</p><p><strong>准确度</strong>：节点与UTC时间的误差在一个给定范围内。</p><p><strong>内部同步：</strong>保证时钟的精度；</p><p><strong>外部同步</strong>：保证时钟的准确度；</p><h3 id="计算时间误差"><a href="#计算时间误差" class="headerlink" title="计算时间误差"></a>计算时间误差</h3><h3 id="没有UTC的情况下保障时间的准确性"><a href="#没有UTC的情况下保障时间的准确性" class="headerlink" title="没有UTC的情况下保障时间的准确性"></a>没有UTC的情况下保障时间的准确性</h3><p>本质上是因为有些机器没有联网，所以并不知道UTC时间。</p><p>Berkeley算法：时间服务器（类似一个UTC时间服务器，不过是相对时间）周期性的扫描所有的节点，计算时间均值之后告诉其他机器如何调整。</p><h3 id="happen-before关系"><a href="#happen-before关系" class="headerlink" title="happen-before关系"></a>happen-before关系</h3><p>所有的进程并不一定在时间上达成一致，而<strong>只需要在时间发生顺序上达成一致</strong>。</p><p>实际上隐含的是因果关系。</p><p>定义如下：</p><ul><li>如果a 和 b 是同一个进程中的两个事件，并且 a 在 b 之 前到达，则有：a-&gt;b； </li><li>如果 a 是消息的发送者，b 是消息的接收者，则 a-&gt;b； </li><li>如果 a-&gt;b 并且 b-&gt;c 则 a-&gt;c；</li></ul><h3 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h3><p>为每一个事件 e 分配一个时间戳 C(e) 使其满足以下属性：</p><ul><li>如果 a 和 b 是同一个进程中的事件，并且a-&gt;b， 那么有：C(a) &lt; C(b);</li><li>如果 a 是信息 m 的发送方，并且 b 是信息的接收者，那么C(a) &lt; C(b);</li></ul><blockquote><p>这个时间戳实际上是一个计数器，每个进程自己维护，每当发生事件就加一这样子。</p></blockquote><p>算法如下：</p><p>例子如下：</p> <p>要记得！时间戳并不能推出因果关系！ 只有因果关系能推出时间戳关系！所以后面引入了向量时钟</p><h3 id="全序多播"><a href="#全序多播" class="headerlink" title="全序多播"></a>全序多播</h3><p>在一个分布式系统内，每个副本更新完之后多播自己的操作，要求<strong>满足所有副本上执行的并发操作顺序是一样的</strong>。</p><p>例如像两个人同时对一个银行账户操作，一个增加1%余额，一个增加100元余额，必须保证并发操作顺序一样才能够保证账户余额一致。</p><h3 id="Lamport逻辑时钟解决互斥访问"><a href="#Lamport逻辑时钟解决互斥访问" class="headerlink" title="Lamport逻辑时钟解决互斥访问"></a>Lamport逻辑时钟解决互斥访问</h3><p>与全序多播算法一样，每个进程维护一个时间戳和事件队列，当进程 P 想访问临界区资源时，将自己加上自己当前的时间戳和自己想访问的临界区(<code>&lt;T, P, C&gt;</code>)，多播到其他进程并且加入到自己的事件队列中。</p><p>其他进程收到进程后，更新自己的逻辑时钟：<code>Lc = max(Lc, T) + 1</code>，其中 <code>T</code> 是请求的时间戳。并且将该请求加入到自己的本地队列，并进行排序。向优先级最高的请求的进程发出ack。</p><p>当进程 P 的事件队列中事件（<code>&lt;T, P, C&gt;</code>）优先级最高且收到了其他所有进程的 ack 消息（证明同步），P 可以访问临界区。</p><h3 id="向量时钟"><a href="#向量时钟" class="headerlink" title="向量时钟"></a>向量时钟</h3><p>因为逻辑时钟不能从C(a) &lt; C(b) 推导出 a-&gt;b，所以引入向量时钟来从时间戳推导出因果关系。</p><p>每个进程维护一个时钟向量（作为自己的全局视图）。</p><p><strong>因果依赖</strong></p><p>算法如下：</p><h3 id="因果有序多播"><a href="#因果有序多播" class="headerlink" title="因果有序多播"></a>因果有序多播</h3><p>与全序多播的关系：<strong>因果有序的多播比之前提到的全序多播更弱。</strong>尤其是如果两个消息互相没有任何关系，并不关心以哪种顺序发送给应用程序。</p><p>使用向量时钟，可以确保所有因果先于某个消息的所有消息接收后才传送这个消息。</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>分布式系统中的多个进程需要互斥地访问某些资源。</p><h4 id="基于令牌的方法"><a href="#基于令牌的方法" class="headerlink" title="基于令牌的方法"></a>基于令牌的方法</h4><p>仅有的一个令牌在进程之间传递。拥有令牌的进程 可以访问临界区或者将令牌传递给其他进程。</p><p>可能存在的问题：如果令牌传丢了（进程突然被kill了）或者令牌不知道传哪去了。</p> <h4 id="基于许可的集中式方法"><a href="#基于许可的集中式方法" class="headerlink" title="基于许可的集中式方法"></a>基于许可的集中式方法</h4><p>找一个协作者来管理节点，其他节点如果想访问临界资源需要先询问协作者。</p><p>可能存在的问题：太依赖协作者了，如果协作者寄了就寄了。</p><h4 id="非集中式算法"><a href="#非集中式算法" class="headerlink" title="非集中式算法"></a>非集中式算法</h4><p>因此才有了下面这种分布式的协作者方法：假设每个临界资源有N个副本，每个副本都有一个协作者管理访问，一个进程 m 需要获得 N&#x2F;2 个协作者的许可（过半数）即可访问临界资源，避免单一协作者crash之后崩溃。</p> <p>但是存在一个问题：</p><h4 id="Ricart-Agrawala互斥算法"><a href="#Ricart-Agrawala互斥算法" class="headerlink" title="Ricart &amp; Agrawala互斥算法"></a>Ricart &amp; Agrawala互斥算法</h4><p>要求系统中的所有事件都是完全排序的。对于每对事件， 比方说消息，哪个事件先发生都必须非常明确。 </p><p>进程要访问共享资源时，构造一个消息，包括资源名、它的进程号和当前逻辑时间。然后发送给所有的其他进程</p><p>接收到消息的决策动作分为三种情况：</p><ul><li>若接收进程没有访问资源，而且也不想访问资源，向发送者返回一个OK消息；</li><li>若接收者已获得对资源的访问，那么它就不答应，而是将该请求放入队列中；</li><li>如果接收者想访问资源但尚未访问时，它将收到消息的时间戳与它发送到其他进程的消息的时间戳进行比较。时间戳早的那个进程获胜，如果接收到的消息的时间戳比较早，那么返回一个OK消息。如果它自己的消息的时间戳比较早，那么接收者将收到的消息放入队列中，并且不发送任何消息；</li></ul><p>算法遇到的问题：若有单个进程crash了算法就跑不动了，因为需要全部进程发ack。并且每次想访问就进行多播，网络流量大大的增加。进程需要维护一个消息队列，不适用于进程多的情况。</p><h4 id="互斥算法的比较"><a href="#互斥算法的比较" class="headerlink" title="互斥算法的比较"></a>互斥算法的比较</h4><h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><p>某些算法需要一些进程作为一个协作者。问题是如何<strong>动态的选择</strong>（自动选择）这个特殊的进程。</p><h4 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h4><ul><li>每个进程都有一个ID。</li><li>每个进程都知道其他进程的ID，但是不知道它们是否还在运行。</li><li>选举算法是找到具有最大ID的活跃进程。</li></ul><h4 id="bully-算法"><a href="#bully-算法" class="headerlink" title="bully 算法"></a>bully 算法</h4><h4 id="Ring-算法"><a href="#Ring-算法" class="headerlink" title="Ring 算法"></a>Ring 算法</h4> <h2 id="第七章-一致性和复制"><a href="#第七章-一致性和复制" class="headerlink" title="第七章 一致性和复制"></a>第七章 一致性和复制</h2><blockquote><p>CAP原理、如何判断属于哪种一致性（数据、用户）、副本管理（主从副本）、一致性协议（要知道原理）</p></blockquote><h3 id="CAP-原理"><a href="#CAP-原理" class="headerlink" title="CAP 原理"></a>CAP 原理</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼得。</p><ul><li>一致性：无论用户从哪个节点访问副本，都会获得最新的副本版本。</li><li>可用性：无论用户何时开始访问，都会获得响应。</li><li>分区可容忍性：系统需要在部分节点通信失败的时候系统仍能运作。</li></ul><p>三者不可兼得，简单来说：一个分布式系统在网络分区存在时，必须权衡：</p><ol><li><p><strong>是否保证一致性</strong>，但可能牺牲可用性。</p><p>例如像保证分区可容忍性和一致性，就不能保证可用性，因为当发生某些节点通信失败的时候，为了保证副本的一致性，就不允许用户进行操作（可用性）。</p></li><li><p><strong>是否保证可用性</strong>，但可能牺牲一致性。</p><p>保证分区可容忍性和可用性，即在发生通信失败的时候为了响应客户的访问，可能会造成一致性的问题。</p></li></ol><p><strong>分区可容忍性是分布式系统避免不了的一个情况！！</strong></p><h3 id="数据一致性模型（以下讨论的都是基于数据的一致性模型）"><a href="#数据一致性模型（以下讨论的都是基于数据的一致性模型）" class="headerlink" title="数据一致性模型（以下讨论的都是基于数据的一致性模型）"></a>数据一致性模型（以下讨论的都是基于数据的一致性模型）</h3><p>一致性模型实际上本质是进程（客户）和数据存储的一个约定。当对数据存储的操作需要满足一定的规则，才会正常存储。特别是当多个进程发生并发读写操作，需要如何返回结果。</p><p>一致性模型解决了分布式系统中的核心问题：<strong>并发操作导致的结果不确定性</strong>。</p><h4 id="连续一致性（一致性程度）"><a href="#连续一致性（一致性程度）" class="headerlink" title="连续一致性（一致性程度）"></a>连续一致性（一致性程度）</h4><p>由以下三个部分组成：</p><ul><li><p><strong>数值偏差：</strong>不同副本之间的数值可能不同。</p></li><li><p><strong>新旧偏差：</strong>不同副本之间的“新旧”不同。</p><p>例如像天气预报，需要每隔四个小时就同步一次。</p></li><li><p><strong>顺序偏差：</strong>不同副本更新操作的顺序和数量可能不同（即不同更新方法）。</p></li></ul><p>只有当在本地提交之后才会多播给其他副本。</p><p>顺序偏差指的是本地没有提交的操作次数（白色区域）。</p><p>数值偏差的构成的第一部分是其他进程未提交的操作次数。</p><h4 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h4><p>以数据为中心的一致性模型。</p><p>任何时候的执行结果都是相同的，所有进程对数据存储的操作是按照某种顺序序列执行的，并且每个进程的操作按照程序所定制的顺序出现在这个序列中。</p><p>只需要观察每个进程的读操作是否顺序一样即可。</p><h4 id="因果一致性"><a href="#因果一致性" class="headerlink" title="因果一致性"></a>因果一致性</h4><p>一种<strong>弱化的顺序一致性模型</strong>。</p><p>所有的进程必须要以一样的顺序看到具有因果关系的写操作。</p><p>不同进程看到的并发写操作可以不同。</p><h3 id="客户一致性模型"><a href="#客户一致性模型" class="headerlink" title="客户一致性模型"></a>客户一致性模型</h3><p>先讨论数据一致性模型的特点：<strong>读写并重</strong>的数据存储，以<strong>进程</strong>作为视角。</p><p>但是以客户为中心的一致性模型是<strong>读多写少</strong>的，即大部分都是查询操作，所以提供弱一致性（最终一致性），以<strong>副本</strong>作为视角。</p><p>最终一致性：如果副本很长一段时间没有更新，则最终每个副本将变成一致的。（允许更新过程中副本是不一致的）</p><p><strong>适合数据一致性的场景：银行系统，需要确保每个账号的写操作顺序是一致的；库存管理系统，不允许衣服超卖了。</strong></p><p><strong>适合客户一致性的场景：社交媒体平台（朋友圈），允许有更新延迟；在线协作工具。</strong></p><h4 id="最终一致性的优缺点"><a href="#最终一致性的优缺点" class="headerlink" title="最终一致性的优缺点"></a>最终一致性的优缺点</h4><p>定义：如果副本最近很长一段时间没有更新操作，那么所有副本都会变得趋于一致。简单来说，就是更新操作最终会传到每个副本。</p><p>优点：只要求更新操作能传播到副本即可，开销小。</p><p>缺点：如果用户访问到了还未更新的节点则会发现不一致性。</p><h4 id="读写一致性"><a href="#读写一致性" class="headerlink" title="读写一致性"></a>读写一致性</h4><p>单调读：一旦一个进程读取了某个数据项的某个版本，接下来的所有读取操作将只会看到相同或更新的版本。</p><p>单调写：一个进程对数据项 x 执行的写操作必须在该进程对 x 执行任何后续写操作之前完成。</p><p><strong>读写一致性：一个进程对 X 的写操作总是会被该进程后续对 X 的读操作看见。</strong></p><p>即一个用户一定能看见自己写入的内容。</p><p>例子：更新自己的Web界面，确保自己刚刚修改的内容能够被自己重新登录Web页面看见（不是读取缓存的界面）。其他用户的更新可能一会才看到，但是自己的更新是立刻被看到的。</p><h4 id="写读一致性"><a href="#写读一致性" class="headerlink" title="写读一致性"></a>写读一致性</h4><p>写读一致性：一个进程对 X 进行读操作后的写操作，保证发生在与 X 取值更新的值上或者与之相等的情况。</p><p>例子：刷新闻的时候看到原文章才能看到回复文章。</p><h3 id="副本服务器放置"><a href="#副本服务器放置" class="headerlink" title="副本服务器放置"></a>副本服务器放置</h3><p>目的：从N 个可能的位置中找出 K 个最佳的位置。</p><ul><li>假定已放置了 k-1 个服务器，从N-k+1个服务器中选择一个最佳的服务器，与所有的客户端之间的距离最小，计算复杂度过高。即从剩下的服务器选出最好的并且距离最小的位置。</li><li>假定在⼀个 D 维的⼏何空间中放置服务器，节点之间的距离反映了延迟。把整个空间划分为多个单元，选择 K 个密度最⼤的单元放置副本服务器。</li></ul><h3 id="服务器放置内容"><a href="#服务器放置内容" class="headerlink" title="服务器放置内容"></a>服务器放置内容</h3><ul><li>永久副本：即机器持久存储的数据。</li><li>服务器副本：初始化数据存储的时候创建的，进程可以动态的持有副本数据，例如多客户经常访问文件A，则将文件A加入副本。</li><li>客户副本：客户端初始化创建的副本，目的是减少与服务器的通信次数。</li></ul><h3 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h3><p><strong>内容分发的方式：</strong></p><ol><li>只传播副本更新的通知（常用于缓存）。</li><li>当副本发生更新，将整个数据都传送到另一个副本（被动复制）。</li><li>当副本发生更新，将更新的操作传给其他副本（主动复制）。</li></ol><p><strong>push-base</strong>：属于主动复制，服务器主动将更新推送到其他副本。适合读&#x2F;更新频率高的系统使用。</p><p><strong>pull-base</strong>：属于被动复制，客户端向服务器获取更新内容，适合于读&#x2F;更新频率低的系统使用。</p><p>租用方式：在PUSH和PULL操作间切换，租期内是PUSH操作，租期外是PULL操作。</p><p>如果租期过长会增加服务器的负担，如果租期过短则可能未能有效地获得更新的副本。</p><h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><p>一致性协议描述了特定的一致性实现。</p><h3 id="持续一致性"><a href="#持续一致性" class="headerlink" title="持续一致性"></a>持续一致性</h3><h4 id="限制了数值偏差"><a href="#限制了数值偏差" class="headerlink" title="限制了数值偏差"></a>限制了数值偏差</h4><p>设定 Val(w) &gt; 0，其中 Val(w)是更新后和更新前的差值绝对值。</p><p>假设有N个副本，副本之间会传递更新操作给其他副本，TW[i, j]意味着所有副本 j 的写操作传到副本 i 的总和。</p><p>可判断出，目前最新值 v(t) 的计算公式为 初始值 + 所有的TW[k, k]。</p><p>单个副本 i 内的值 vi 计算公式为 初始值 + 所有的TW[i, k]。</p><p>需要限制数值偏差 v(t) - vi 小于等于一个给定的 δ。</p><h4 id="限制新旧偏差"><a href="#限制新旧偏差" class="headerlink" title="限制新旧偏差"></a>限制新旧偏差</h4><p>要记得那个例子，天气系统每隔四个小时就需要更新一次。</p><p>服务器S_k保持实时向量时钟RVC_k，其中RVC_k[i] &#x3D; T(i) 为 到时间T(i)时，S_k看到了已提交给S_i的所有写操作；</p><ul><li>即T(i)时，S_k 收到了来自 S_i 传播的写操作。</li></ul><p>如果T(k) - RVC_k[i] 大于某个设定的值，则开始拉入副本 S_i 晚于 RVC_k[i] 执行的写操作。</p><h3 id="基于主备份的协议"><a href="#基于主备份的协议" class="headerlink" title="基于主备份的协议"></a>基于主备份的协议</h3><p>分为远程写协议和本地写协议。</p><h4 id="远程写协议"><a href="#远程写协议" class="headerlink" title="远程写协议"></a>远程写协议</h4><p>从名字看，实现数据项X的更新是在远端的主备份上实现的。</p><p><strong>所有读操作和写操作都转发给单个固定的远程（主）服务器</strong>：要在数据项x上执行一个写操作的进程，会把该操作转发给x的主服务器。该主服务器在其x 的本地副本上执行更新操作，随后把该更新转发给备份服务器。</p><p>写操作：经过的比较长，W1-W2-W3-W4-W5</p><p>可靠性很好，但是性能不高。</p><p>实现了顺序一致性，完成了阻塞操作。</p><h4 id="本地写协议"><a href="#本地写协议" class="headerlink" title="本地写协议"></a>本地写协议</h4><p><strong>主副本在要执行写操作的进程之间迁移</strong>：某个进程对x进行写操作，则定位x的主副本，然后将x转移到自己的位置上。 W3处就已经返回了。</p><p>在断网之前将数据保存在本地，然后修改是对本地操作的，等重新联网后向原来的主备份同步。</p><h3 id="基于团队的复制写协议"><a href="#基于团队的复制写协议" class="headerlink" title="基于团队的复制写协议"></a>基于团队的复制写协议</h3><p>复制写协议：将各更新操作主动发给各个副本上的进程。</p><p>跟著主备份协议的区别：可以多个副本同时写（基于全序多播）。</p><p>基于团队的协议，读或者写需要通过团队的统一，为了满足一致性，需要有以下两个条件成立：</p><ol><li><p>一定要有进程既是写团体也是读团体（避免读写冲突）</p><p>这样假设访问的话就可以访问即写又读的副本了。</p></li><li><p>写团体要占大多数（避免写写冲突）</p></li></ol><h2 id="第八章-容错"><a href="#第八章-容错" class="headerlink" title="第八章 容错"></a>第八章 容错</h2><blockquote><p>故障类型（三个不同的概念），可靠性，可用性，如何保障，可靠多播，分布式两段提交，如何恢复（前向后向），检查点开销大所以用日志，两阶段具体了解。</p></blockquote><h3 id="可依赖性"><a href="#可依赖性" class="headerlink" title="可依赖性"></a>可依赖性</h3><p>定义：软件组件用于服务客户，但是软件组件可能用到其他组件的服务，即组件依赖于其他组件。</p><p>相关的四个需求：</p><ul><li>可靠性</li><li>可用性</li><li>安全性</li><li>可维护性</li></ul><h4 id="可靠性和可用性的区别"><a href="#可靠性和可用性的区别" class="headerlink" title="可靠性和可用性的区别"></a>可靠性和可用性的区别</h4><p>可靠性指的是连续工作的概率（即不被打断）。</p><p>可用性指的是工作时间跟总时间的比。</p><p><strong>可靠性高不一定可用性高：一个系统平时很少出错，但是一出错恢复时间特别长。</strong></p><p><strong>可用性高不一定可靠性高：系统经常出错，但是恢复时间十分短。</strong></p><h3 id="分布式系统中的bug"><a href="#分布式系统中的bug" class="headerlink" title="分布式系统中的bug"></a>分布式系统中的bug</h3><p><strong>失效（Failure）、错误（Error）、故障（fault）</strong>。</p><p>按照失效程度：失效 &gt; 错误 &gt; 故障。</p><p>错误是部分组件失效，失效是整个组件失效。</p><p>故障（fault）是失效 (Failure) 的原因。</p><h4 id="五个失效模型"><a href="#五个失效模型" class="headerlink" title="五个失效模型"></a>五个失效模型</h4><p><strong>崩溃性故障</strong></p><ul><li>服务器停机，但在停机之前工作正常</li></ul><p><strong>忽略性故障</strong></p><ul><li>服务器不能响应到来的请求</li><li>服务器不能接受到来地消息</li><li>服务器不能发送消息</li></ul><p><strong>时间性故障</strong></p><ul><li>服务器的响应在指定的时间间隔之外</li></ul><p><strong>响应故障</strong></p><ul><li>服务器的响应不正确</li><li>响应地值错误</li><li>服务器偏离了正确的控制流</li></ul><p><strong>任意性故障</strong></p><ul><li>服务器可能在随意的时间产生随意的响应</li></ul><h3 id="冗余掩盖故障"><a href="#冗余掩盖故障" class="headerlink" title="冗余掩盖故障"></a>冗余掩盖故障</h3><p>故障透明，用户并不知道。</p><p>冗余类型有以下三种：</p><ul><li>信息冗余：在信息中增加额外的位使得错乱的位回复正常。</li><li>时间冗余：如果系统出错，可以再次执行这个事务。</li><li>物理冗余：添加额外的装备或进程，使得系统作为一个整体来容忍部分组件的失效。</li></ul><h3 id="分布式系统检测失效"><a href="#分布式系统检测失效" class="headerlink" title="分布式系统检测失效"></a>分布式系统检测失效</h3><p>因为有<strong>忽略性失效</strong>，所以怎么检测变得困难。</p><ul><li>如果 P 没有在规定的时间 t 内收到来自 Q 的心跳信息：P 怀疑 Q 失效；</li><li>如果 Q 稍后发出消息：P 停止怀疑 Q，P 增加 timeout 的时间；</li><li>如果 Q 确实宕机，P 会一直怀疑 Q；</li></ul><h3 id="可靠的通信方式"><a href="#可靠的通信方式" class="headerlink" title="可靠的通信方式"></a>可靠的通信方式</h3><h4 id="可靠的RPC过程"><a href="#可靠的RPC过程" class="headerlink" title="可靠的RPC过程"></a>可靠的RPC过程</h4><ul><li><p><strong>两个简单的方案：</strong></p><p>定位不到服务器：像客户端报错。</p><p>请求丢失：再次发送请求。</p></li></ul><h4 id="Client-server失效场景及恢复方法"><a href="#Client-server失效场景及恢复方法" class="headerlink" title="Client-server失效场景及恢复方法"></a><strong>Client-server失效场景及恢复方法</strong></h4><ul><li><p><strong>最多一次和最少一次语义：</strong></p><p>最多执行一次写操作。</p><p>最少执行一次读操作。</p></li></ul><p>完全透明的服务器恢复是不可能的，举例说明： 假设请求服务器更新文档： </p><p>M：发送完成信息（请求的发送ACK） </p><p>P：完成文档处理 </p><p>C：crash </p><p>有6种可能的顺序：</p> <p>可以发现，完全透明的服务器恢复是不可能的。</p><h4 id="可靠的RPC过程-1"><a href="#可靠的RPC过程-1" class="headerlink" title="可靠的RPC过程"></a>可靠的RPC过程</h4><ul><li><p><strong>丢失应答信息</strong></p><p>客户端不能判断是服务器宕机还是丢失响应。</p><p><strong>将服务器设计成幂相等的系统。</strong></p></li><li><p><strong>客户端崩溃：</strong></p><ul><li><p>服务器在⼯作且持有资源，但没有客户端需要结果。</p></li><li><p>解决⽅案：</p><p>孤⼉消灭———— 客户端恢复时重启服务器或丢弃之前的计算；</p><p>再⽣—— 把时间分为顺序编号的时期，客户端恢复后向所有的服务器⼴播新时期的开始，由服务器杀死与客户端相关的「孤⼉」；</p><p>优雅再⽣；</p><p>到期；</p></li></ul></li></ul><h3 id="可靠多播"><a href="#可靠多播" class="headerlink" title="可靠多播"></a>可靠多播</h3><p>消息发送和接收按照发送者发送的顺序进行。</p><p>问题：如果存在N的接收方，会导致大量返回 N 个确认信息，如果数量 很大，发送方会被反馈消息淹没，形成反馈拥塞。</p><p>解决方案： 接收方不对消息进行反馈，而只是在消息丢失时才返回一个反馈消息。</p><p>存在的问题是：需要缓存大量的陈旧的信息。</p><h3 id="分布式两阶段提交协议"><a href="#分布式两阶段提交协议" class="headerlink" title="分布式两阶段提交协议"></a>分布式两阶段提交协议</h3><p>目的：一个操作要么被进程组中的每一个成员执行，要么一个都不执行；</p><p>可以用刚刚提到的可靠多播进行实现。</p><p>两阶段提交协议：</p><ol><li>协作者发起投票请求。</li><li>参与者收到投票请求，并根据自身情况返回 abort 或者 commit。</li><li>协作者收集请求，如果没有收到 abort，则发送 global commit；否则，发送 global abort.</li><li>参与者根据收到的全局消息执行对应的动作。、</li></ol><p>参与者失效情况：</p><ol><li><p>init：此时还未收到投票信息，不会有任何问题。</p></li><li><p>ready：此时已经投完票了，恢复后通过日志查看协作者的决策。或者查看其他参与者的动作也可以。</p><blockquote><p>若此时恢复之后发现参与者都被阻塞在ready状态，代表协作者被阻塞了。</p></blockquote></li><li><p>abort：此时是幂等操作，再执行一次abort即可。</p></li><li><p>commit：此时是幂等操作，再执行一次commit即可。</p></li></ol><p>协作者失效情况：</p><h3 id="分布式系统失效恢复的主要方式"><a href="#分布式系统失效恢复的主要方式" class="headerlink" title="分布式系统失效恢复的主要方式"></a>分布式系统失效恢复的主要方式</h3><p>前向恢复：将系统状态设置为将来的某个状态。</p><p>后向恢复：将系统状态设置为过去某个状态，需要周期性记录检查点，其实就是找恢复线。</p><blockquote><p>分布式系统恢复更困难：需要找到全局一致的检查点。</p></blockquote><h3 id="恢复线"><a href="#恢复线" class="headerlink" title="恢复线"></a>恢复线</h3><p>假定每一个进程都会周期性记录检查点，最近一次的全局一致的检查点就是恢复线路。</p><p>在上图中，（c, d）就是一个恢复线。</p><h3 id="检查点方法"><a href="#检查点方法" class="headerlink" title="检查点方法"></a>检查点方法</h3><p>保存进程的运行状态，存储到内存或者磁盘，用于对进程进行迁移或者故障恢复。</p><p>例如在数据库中，检查点是将那些未写入磁盘（还在内存）的写操作执行结果写入磁盘。</p><h4 id="独立的检查点方法"><a href="#独立的检查点方法" class="headerlink" title="独立的检查点方法"></a>独立的检查点方法</h4><p>每个进程的检查点是以一种不协调的方式来按时记录本地状态，这种分<strong>布式特性使得找到一个恢复线路非常困难</strong>，可能会导致多米诺效应。</p><p>最保守的恢复状态是初始状态！</p><h4 id="协调的检查点方法"><a href="#协调的检查点方法" class="headerlink" title="协调的检查点方法"></a>协调的检查点方法</h4><p>所有进程都<strong>同步</strong>地把他们的状态写道本地稳定存储中。优点：保存的状态自动保持全局一致，避免导致多米诺效应。</p><ol><li>协调者多播checkpoint request消息。</li><li>参与者接收到消息，打检查点，停止发送应用消息，向协作者报告他打了检查点。</li><li>所有检查点的报告都被协作者确认，协作者广播一个checkpoint done消息以允许所有进程继续。</li></ol><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>检查点的代价过高，通过“重放（replay）”的方式达到一个全局一致的状态而不需要从持久存储中恢复该状态&#x3D;&gt;在日志中持久化消息。</p><h2 id="第九章-Paxos"><a href="#第九章-Paxos" class="headerlink" title="第九章 Paxos"></a>第九章 Paxos</h2><blockquote><p>三种paxos，运用场景不一样，paxos工作过程，raft过程（跟paxos区别），PBFT知道用来干嘛</p></blockquote><h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p>定义：使所有非故障进程就由谁来执行命令达成一致，而且在有限的步骤内就达成一致。</p><p>前提 ：在一个容错组里面，每一个非故障进程执行的命令以及执行的顺序与其他非故障进程相同</p><p>共识协议的思想就是某些节点可能失效的情况下剩余的节点能达成共识。</p><p>共识协议分类 </p><p><strong>失效容错协议（Fault-Tolerant Protocols）</strong></p><ul><li><p><strong>特点</strong>：能够处理节点失效（如崩溃、掉线）情况。</p></li><li><p>准确检测失效：泛洪 </p></li><li><p>最终检测到失效：Pasox Raft </p></li><li><p><strong>应用</strong>：分布式数据库、分布式文件系统、服务协调系统</p></li></ul><p><strong>拜占庭容错协议（Byzantine Fault Tolerant Protocols, BFT）</strong></p><ul><li><strong>特点</strong>：能够处理节点的任意故障行为，包括恶意攻击、数据篡改等。</li><li>PBFT</li><li><strong>应用</strong>：区块链系统、金融交易系统、高安全性分布式系统</li></ul><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>能够在部分节点发生故障的情况下保持共识。</p><p>[Paxos 协议详解：分布式系统一致性的基石_paxos协议-CSDN博客](<a href="https://blog.csdn.net/LearnerDL/article/details/142602963#:~:text=Paxos">https://blog.csdn.net/LearnerDL/article/details/142602963#:~:text=Paxos</a> 是一个能够在分布式系统中帮助我们解决一致性问题的协议。 它可以确保多个节点（计算机）在不可靠的网络环境中达成一致，即使有些节点宕机或网络延迟，也能保证整个系统最终达到相同的决定。 Paxos 协议是由计算机科学家,莱斯利·兰伯特 （Leslie Lamport）在 1990 年代提出的，它的目标是在不可靠的网络环境中让多个分布式节点达成一致。)</p><p>分为两个阶段：预提交阶段和提交阶段。</p><p>预提交阶段：</p><p>阶段2：</p><p>以下是例子：</p><p>特性：</p><p><strong>safety安全性（Paxos满足）</strong>：</p><ul><li><p><strong>只有一个值被选定。</strong></p><p>整个系统最终只会确定一个值。（透过vrnd实现）</p></li><li><p><strong>两个正常的结点最终不会选择不同的值</strong></p><p>通过大多数投票实现。</p></li><li><p><strong>一个结点最多选一次</strong></p><p>每个提议者在某个时间只能持有一个提议编号，确保它不会同时发起多个不同值的提议。</p></li></ul><p><strong>liveness活性（Paxos没有满足！）：</strong></p><ul><li><p>每一个正常的节点最终都会选择一个值。</p></li><li><p>可能会发生活锁，即两个proposal轮流发起提议。</p></li></ul><p><strong>Paxos的主要变种：</strong></p><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><p>解决非拜占庭式失效。</p><p>Paxos问题：</p><ul><li>效率低，写入一个值要2次RPC。</li><li>无法解决livenness。</li><li>不好理解。</li></ul><p>Raft 的核心思想是通过领导者选举来简化一致性过程。与 Paxos 不同的是，Raft 一开始就明确选出一个 领导者（Leader），所有提案都由这个领导者发起。具体工作流程如下：</p><ul><li>领导者选举：系统中的节点会通过投票选举出一个领导者。这个领导者会负责处理所有的提案。</li><li>日志复制：领导者接收客户端的提案后，会将提案添加到它的日志中，然后向其他节点（称为跟随者，Followers）发送这个提案，要求它们复制日志。</li><li>日志提交：当领导者收到大多数跟随者的确认后，提案被认为提交成功，整个系统达成一致。<br>Raft 的优点：</li></ul><p>简单易懂：相比 Paxos，Raft 更容易理解，尤其是通过明确的领导者角色简化了提案过程。</p><p>统一领导者：Raft 避免了 Paxos 中多个提议者竞争导致的复杂性，提升了系统的性能。</p><h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>解决拜占庭式故障的协议。</p><h2 id="第十章-分布式文件系统"><a href="#第十章-分布式文件系统" class="headerlink" title="第十章 分布式文件系统"></a>第十章 分布式文件系统</h2><blockquote><p>分布式文件系统结构，分布式文件系统就是分布式系统的实例（有很多分布式的问题），NFS，知道GFS的特点。</p></blockquote><h3 id="NFS文件系统的主要特点"><a href="#NFS文件系统的主要特点" class="headerlink" title="NFS文件系统的主要特点"></a>NFS文件系统的主要特点</h3><p>是客户-服务器结构。</p><ul><li>每个文件服务器都提供其本地文件系统的一个标准化视图。</li><li>每个NFS都支持相同的模型。（有相同的接口）</li><li>底层模型是远程文件访问模型。</li></ul><h4 id="NFS的架构"><a href="#NFS的架构" class="headerlink" title="NFS的架构"></a>NFS的架构</h4><p>使用VFS实现，VFS是不同文件系统接口的标准， 现代OS都提供VFS。VFS提供了系统结构，屏蔽了访问本地和远程文件的差异性。</p><p>NFS像任何UNIX文件系统一样支持硬链接和符号链接；</p><h3 id="GFS文件系统的特点"><a href="#GFS文件系统的特点" class="headerlink" title="GFS文件系统的特点"></a>GFS文件系统的特点</h3><p>是基于集群的分布式文件系统。</p><p>将整个文件拆成多个块，将这些块分布、复制在不同的块服务器中。</p><p>现在描述Google File System的特点：</p><ul><li>主服务器只维护一张（filename，chunk server）的映射表（最小化IO），然后使用日志来记录对数据的操作。</li><li>大量的实际工作都是块服务器完成的，主服务器没有参与循环（避免单节点依赖性能差）</li><li>上述两个特点使得GFS的主服务器不会称为性能瓶颈，反而一个主服务器可以控制上百个块服务器，扩展性更好。</li></ul><h3 id="什么是文件共享语义，主要的语义模型包括哪些？简要描述其特征。"><a href="#什么是文件共享语义，主要的语义模型包括哪些？简要描述其特征。" class="headerlink" title="什么是文件共享语义，主要的语义模型包括哪些？简要描述其特征。"></a>什么是文件共享语义，主要的语义模型包括哪些？简要描述其特征。</h3><p>当需要处理分布式系统的时候，需要确定好并行读写的操作顺序和期望的语义（其实就是定义一个并行的规则，满足一致性）。</p><h3 id="拜占庭容错的基本思想和基本过程"><a href="#拜占庭容错的基本思想和基本过程" class="headerlink" title="拜占庭容错的基本思想和基本过程"></a>拜占庭容错的基本思想和基本过程</h3><p>基本思想是通过构造有限状态机的集合来部署主动复制， 并且这个集合中具有无故障的进程以相同的顺序执行操作。  </p><p>简单解决方案：指定一个协调器，它通过简单地给每个请求附加一个序号来序列化所有的操作。 </p><p>问题转嫁到协调器身上。</p><ol><li><strong>请求阶段</strong>：客户端向主节点发送请求。</li><li><strong>预准备阶段</strong>：主节点将请求广播给所有副本节点。</li><li><strong>准备阶段</strong>：副本节点收到请求后，进行验证并向其他节点发送准备消息。</li><li><strong>提交阶段</strong>：副本节点收集到足够的准备消息后，向其他节点发送提交消息。</li></ol><p>为了 k 个服务器的拜占庭容错，服务器组必须包含至少 3k+1 个进程；</p><blockquote><p>用一个副官模型来理解：</p><ul><li>假设只有 3 个人，A、B、C，三人中如果其中一个是叛徒。当 A 发出进攻命令时，B 如果是叛徒，他可能告诉 C，他收到的是「撤退」的命令。这时 C 收到一个「进攻」，一个「撤退「，于是 C 被信息迷惑，而无所适从。</li><li>如果 A 是叛徒。他告诉 B「进攻」，告诉 C「撤退」。当 C 告诉 B，他收到「撤退」命令时，B 由于收到了司令「进攻」的命令，而无法与 C 保持一致。</li></ul><p>因此在只有三个角色的系统中，只要有一个是叛徒，即叛徒数等于 1&#x2F;3，拜占庭问题便不可解。</p></blockquote><h3 id="P2P系统中用于提高系统可用性的方案？以及方案的主要特点。"><a href="#P2P系统中用于提高系统可用性的方案？以及方案的主要特点。" class="headerlink" title="P2P系统中用于提高系统可用性的方案？以及方案的主要特点。"></a>P2P系统中用于提高系统可用性的方案？以及方案的主要特点。</h3><p>问题：P2P系统的节点的不可用性非常高，简单的复制文件已不能保证可用性。 </p><p>冗余性方案： </p><ol><li>复制：通过放置多个副本提高数据的冗余度从而提高可用性。 </li><li>擦除编码（erasure    coding）：通过把一个文件分成m块，随后把它记录到n大于m块中，任何 m个编码块的集合都足以用于重构造原始文件。冗余性因子： n&#x2F;m。</li></ol><h3 id="在分布式文件系统中主要关注的问题包括哪些？并分别给出一些解决问题的方案"><a href="#在分布式文件系统中主要关注的问题包括哪些？并分别给出一些解决问题的方案" class="headerlink" title="在分布式文件系统中主要关注的问题包括哪些？并分别给出一些解决问题的方案"></a>在分布式文件系统中主要关注的问题包括哪些？并分别给出一些解决问题的方案</h3><h4 id="同步解决方案"><a href="#同步解决方案" class="headerlink" title="同步解决方案"></a>同步解决方案</h4><ul><li>立即将缓存文件的所有改动传播回服务器，简单但是效率低；（对所有进程即时可见）</li><li>在文件关闭之前，所有改动对其他进程都是不可见的即会话语义</li><li>所有文件都是不可改变的，文件上的操作只有 create 和 read</li><li>使用原子事务处理共享文件</li></ul><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>对于一个大型分布式系统，当需要提供对文件的共享访问时，至少要有一个全局名称空间。</p><p> 全局名称空间服务( GNS); 把现有文件系统集成进单个全局名称空间中，只使用用户级解决方案</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><h2 id="第十一章-大数据-分布式机器学习"><a href="#第十一章-大数据-分布式机器学习" class="headerlink" title="第十一章 大数据+分布式机器学习"></a>第十一章 大数据+分布式机器学习</h2><blockquote><p>MAP-Reduce 原理，优势；分布式机器学习，了解原理。</p></blockquote><h3 id="MAP-REDUCE"><a href="#MAP-REDUCE" class="headerlink" title="MAP-REDUCE"></a>MAP-REDUCE</h3><p><strong>MapReduce</strong> 是一种编程模型和计算框架，主要用于处理大规模数据集。</p><p>流程如下：</p><ol><li><strong>Map 阶段</strong>：将输入数据分成小块，并并行处理，生成一组中间的键值对。</li><li><strong>Shuffle 和 Sort 阶段</strong>：对 Map 阶段的输出进行分组和排序，确保相同的键被发送到同一个 Reduce 任务中。</li><li><strong>Reduce 阶段</strong>：处理相同键的所有值，通常进行汇总、聚合等操作，输出最终的结果。</li></ol><p>特点：</p><ul><li><p><strong>大规模的计算被分割成很多小的任务</strong></p><p>支持分布式运算。</p></li><li><p><strong>使用磁盘存储中间结果</strong></p><p>因为要处理很大规模的数据，所以没有受到内存限制。</p></li><li><p><strong>自动并行</strong></p><p>这个框架很适合并行计算。</p></li><li><p><strong>自动容错</strong></p><p>原本就是分布式的了，如果 Map 或 Reduce 任务失败，MapReduce 框架会将任务重新分配到其他节点上执行。</p></li><li><p><strong>可扩展性好</strong></p><p>只需要增加更多的节点提高计算能力。</p></li><li><p><strong>入门门槛低</strong></p><p>不需要实现底层逻辑，系统出错了也不用理。</p></li></ul><p>缺点：</p><ul><li>没有办法实时计算</li><li>输入需要是静态的，不能是动态的</li></ul><h4 id="与传统的高性能计算相比，MapReduce的优势是什么？"><a href="#与传统的高性能计算相比，MapReduce的优势是什么？" class="headerlink" title="与传统的高性能计算相比，MapReduce的优势是什么？"></a>与传统的高性能计算相比，MapReduce的优势是什么？</h4><h5 id="简化的编程模型（Simplicity-of-Programming-Model）："><a href="#简化的编程模型（Simplicity-of-Programming-Model）：" class="headerlink" title="简化的编程模型（Simplicity of Programming Model）："></a><strong>简化的编程模型（Simplicity of Programming Model）</strong>：</h5><ul><li><strong>传统 HPC</strong>：传统的高性能计算往往需要复杂的并行编程技术，如 MPI（消息传递接口）、OpenMP（开放多处理）等。开发人员需要手动管理数据的并行化、负载平衡、通信等方面，要求较高的计算机科学知识。</li><li><strong>MapReduce</strong>：MapReduce 提供了一个非常简单和抽象的编程模型，开发者只需要实现两个函数（Map 和 Reduce）。这些函数通过定义输入数据的处理方式和输出方式，完成了所有复杂的并行计算和分布式操作。MapReduce 的高层抽象隐藏了底层的并行化和分布式管理，极大简化了开发过程。</li></ul><h5 id="更高的可扩展性（Scalability）："><a href="#更高的可扩展性（Scalability）：" class="headerlink" title="更高的可扩展性（Scalability）："></a><strong>更高的可扩展性（Scalability）</strong>：</h5><ul><li><strong>传统 HPC</strong>：高性能计算通常依赖于大规模的单机系统（如超级计算机或集群），这些系统依赖于强大的硬件和高效的计算架构。然而，传统 HPC 系统的扩展性受限于硬件的投入和成本，通常只能在单一集群或数据中心中扩展。</li><li><strong>MapReduce</strong>：MapReduce 设计上就是为大规模分布式环境量身定制的，它能够通过增加计算节点来水平扩展，不需要特别昂贵的硬件，只需要普通的计算机节点即可。MapReduce 使得计算可以从几十台机器扩展到几千台机器，适用于大数据量的分布式处理。</li></ul><h3 id="分布式机器学习原理"><a href="#分布式机器学习原理" class="headerlink" title="分布式机器学习原理"></a>分布式机器学习原理</h3><p>分为服务器一方（ 主要是update 参数）和工作一方（主要是计算梯度 GPU）</p><p>基本流程如下：</p><ol><li><strong>工作节点拉取工作集</strong>：工作节点从服务器拉取当前的模型参数，并开始在本地的数据集上进行训练。</li><li><strong>迭代计算</strong>：工作节点执行模型的前向传播和反向传播，计算梯度，完成一次训练迭代。</li><li><strong>停止梯度计算</strong>：当满足某些停止条件时（如达到预定的训练轮数或模型收敛），停止梯度计算。</li><li><strong>工作节点计算梯度</strong>：工作节点在自己的数据子集上进行计算，得出梯度信息。</li><li><strong>工作节点推送梯度</strong>：工作节点将计算得到的梯度信息发送回服务器，以便进行模型更新。</li><li><strong>更新模型</strong>：服务器根据收到的梯度信息更新全局模型参数。</li><li><strong>工作节点拉取更新后的模型</strong>：工作节点从服务器拉取更新后的模型参数，继续进行下一轮的训练。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库复习</title>
    <link href="/2025/01/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9/"/>
    <url>/2025/01/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库复习内容"><a href="#数据库复习内容" class="headerlink" title="数据库复习内容"></a>数据库复习内容</h1><p>作者：哈利波特👑</p><p>加油！有些公式不想打了，就直接复制图片了… 复习时间不够…</p><h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>定义：描述事务的基本符号，是数据库的基本对象。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>定义：互相关联的数据集合 或 长期储存在计算机内、有组织的、可<strong>共享</strong>的大量数据集合。</p><p>数据模型：数据库结构的基础</p><ul><li><p><strong>关系模型</strong></p><p>一个表就是一个关系。</p><p>System-R 是关系模型。</p><p><strong>用的最广泛</strong>。</p></li><li><p><strong>实体-联系模型</strong></p></li><li><p><strong>半结构化模型</strong></p></li><li><p><strong>基于对象的模型。</strong></p></li></ul><h3 id="数据库管理系统-DBMS"><a href="#数据库管理系统-DBMS" class="headerlink" title="数据库管理系统(DBMS)"></a><strong>数据库管理系统(DBMS)</strong></h3><p>是一个在操作系统下定义的<strong>系统软件</strong>。</p><p>定义：由一个<strong>互相关联的数据的集合</strong>（数据库）和一组用<strong>以访问这些数据的程序</strong>所组成。</p><p>目的：提供一种<strong>方便</strong>、<strong>高效</strong>地存取数据库信息的途径。</p><p>核心功能：<strong>数据定义</strong>、<strong>数据操作</strong>、<strong>数据安全</strong>、<strong>数据恢复和备份</strong>、<strong>并发控制</strong>、<strong>事务管理</strong>。</p><ul><li>数据定义：定义数据库的结构，包括表、视图、索引等。</li><li>数据操作：支持数据的插入、更新、删除和查询。</li><li>数据安全性：控制用户权限，确保数据的机密性和完整性。</li><li>数据备份与恢复：提供数据备份和灾难恢复机制。</li><li>并发控制：管理多个用户同时访问数据，避免冲突和数据不一致。</li></ul><h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>定义：由数据库、数据库管理系统、应用系统、数据库管理员（或用户）所组成。</p><p>目的：为用户提供抽象的数据视图，隐藏对数据的维护。</p><h3 id="文件系统的弊端"><a href="#文件系统的弊端" class="headerlink" title="文件系统的弊端"></a>文件系统的弊端</h3><p>数据的冗余和不一致性、数据访问困难、数据孤立、完整性问题、原子性问题等等。</p><ul><li>一个学生同时有两个专业，就会在两个文件存储信息。</li><li>如果临时想要查询文件的子文件，都不行。</li><li>很难增加新的约束。</li></ul><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>一个可用的系统一定要<strong>高效</strong>的检索数据。</p><p>系统开发人员通过将数据抽象成 <strong>物理层</strong>、<strong>逻辑层</strong>、<strong>视图层</strong> 来对用户屏蔽复杂性。</p><ul><li><p><strong>物理层</strong></p><p>最低层次的抽象，描述数据如何存储。</p></li><li><p><strong>逻辑层</strong></p><p>描述数据库存储什么数据以及数据之间的联系。</p></li><li><p><strong>视图层</strong></p><p>只描述数据库的某一部分。</p></li></ul><p><strong>物理数据独立性：</strong>应用程序不依赖物理模式，物理模式隐藏在逻辑模式下，可以在应用程序不受影响的情况下轻易更改。即使物理模式改变了，也无需重写应用程序。</p><p><strong>逻辑数据独立性：</strong>指数据库的逻辑结构（表的属性）发生变化时，不会影响用户的外部视图或应用程序对数据的访问。</p><h3 id="数据库系统模式（考点）"><a href="#数据库系统模式（考点）" class="headerlink" title="数据库系统模式（考点）"></a>数据库系统模式（考点）</h3><p>特定时刻存储的数据库中的信息集合称作数据库的一个<strong>实例</strong>。</p><p>数据库总体的设计称为<strong>数据库模式</strong>。按照刚刚所说的三个层次划分，数据库系统模式有<strong>物理模式</strong>、<strong>逻辑模式</strong>、<strong>子模式</strong>。</p><blockquote><p>数据库系统模式就是变量类型，实例就是该变量在某个特定时间的值。</p></blockquote><h3 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h3><p>分为<strong>数据定义语言</strong>（DDL）和<strong>数据操纵语言</strong>（DML）。</p><ul><li><p><strong>数据定义语言</strong></p><p>例如 <code>create</code>、<code>alter</code>等等。</p><p>有<strong>域约束</strong>和<strong>引用完整性</strong>和<strong>授权</strong>。</p><ul><li>域约束就是<code>create table</code>的时候属性的类型，要符合该类型。</li><li>引用完整性就是外键。</li><li>授权就是<code>grant</code>。</li></ul></li><li><p><strong>数据操纵语言</strong></p><p>分为过程化的 DML 和声明式的 DML。</p><ul><li><p><strong>过程化</strong></p><p>要求指定用户需要什么数据以及<strong>如何获得这些数据</strong>。</p></li><li><p><strong>声明式（非过程化）</strong></p><p>要求指定用户需要什么数据即可。</p><p><strong>SQL是非过程化的！</strong></p></li></ul></li></ul><h3 id="存储管理器"><a href="#存储管理器" class="headerlink" title="存储管理器"></a>存储管理器</h3><p><strong>存储管理器</strong>是数据库管理系统中的一个核心组件，负责管理和存储数据库中的数据。</p><p>负责将原始数据通过操作系统提供的文件系统存储在磁盘上。</p><p>实现了以下几种数据结构：</p><ul><li><p><strong>数据文件</strong></p><p>存储数据库本身。</p></li><li><p><strong>数据字典</strong></p><p>数据字典是<strong>元数据</strong>的存储库，包含数据库中对象的定义、类型、约束等信息。</p><p>它帮助DBMS管理和验证数据库的结构，并允许系统在执行查询时参考这些元数据。</p></li><li><p><strong>索引</strong></p><p>提供对数据项的快速访问。</p></li></ul><p><strong>数据字典（Data Dictionary）是一个存储数据库元数据的系统，用于描述和管理数据库中的所有数据元素、结构、约束和关系。</strong></p><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p><strong>事务</strong>是指一组数据库操作的集合，这些操作要么完全执行（提交），要么完全不执行（回滚）。</p><p>事务管理确保数据库操作在执行过程中满足<strong>ACID</strong>特性，即<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>和<strong>持久性</strong>。</p><ul><li><p><strong>原子性</strong></p><p>原子性保证事务中的所有操作要么完全执行，要么完全不执行。</p><p>事务中的每个操作都是一个不可分割的单位。</p></li><li><p><strong>一致性</strong></p><p>一致性确保数据库从一个有效的状态转换到另一个有效的状态。</p><p>即银行转账之后，a 和 b 的余额应该是不变的。</p></li><li><p><strong>隔离性</strong></p><p>隔离性确保多个事务并发执行时，一个事务的执行不会受到其他事务的干扰。</p></li><li><p><strong>持久性</strong></p><p>持久性确保一旦事务提交，事务的所有操作对数据库的更改是永久性的，即使系统发生崩溃也不会丢失。</p></li></ul><p>原子性和持久性是靠恢复管理器实现。 隔离性是由并发控制管理器实现的。</p><p>为了保证原子性，经常需要<strong>故障修复</strong>，即将数据库恢复到该失败事务开始执行以前的状态。</p><p>事务管理器包括 <strong>恢复管理器</strong> 和 <strong>并发控制管理器</strong> 组成。</p><h3 id="数据库系统-1"><a href="#数据库系统-1" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>由三个子系统组成，分别是<strong>存储管理器子系统</strong>、<strong>编译管理器子系统</strong>（DDL和DML语句）、<strong>事务管理器子系统</strong>。</p><p>数据库系统的基本特征：数据共享性、独立性和冗余度小。</p><p>数据库系统包括<strong>数据库</strong>和<strong>数据库管理系统</strong>（DBMS）。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>SQL 语言是为做决策而产生的，是<strong>查询密集</strong>。 1980年代的数据库都是<strong>更新密集</strong>的。</p><p>1990年加入对象-关系模型。</p><p>**实体-联系数据模型(E-R)**是广泛用于设计数据库的。</p><p><strong>过程化DML（如PL&#x2F;SQL, T-SQL）</strong></p><p><strong>非过程化DML（如SQL）</strong></p><p>在数据库中存储的是_________。<br>A、数据 B、数据模型<br>C、信息 <strong>D、数据以及数据之间的联系</strong></p><p>正确答案：D</p><p>数据库的_________是指数据的正确性和相容性。<br>A、恢复 B、安全性 C、并发控制 <strong>D、完整性</strong><br>正确答案：D</p><p>数据模型是由<strong>数据结构</strong>、<strong>数据操作</strong>、和<strong>完整性约束</strong>三部分组成的。</p><p>在数据库的三级模式结构中，用来描述数据库中全体数据的全局逻辑结构和特征的是__________。<br>正确答案： 逻辑模式</p><p>数据库系统的核心是____________________。<br>正确答案：数据库管理系统或DBMS</p><p>对DB的数据主要是两个操作：查询和更新。</p><p>SQL server中，每个表最多1024列。</p>     <h2 id="第二章-关系模型介绍"><a href="#第二章-关系模型介绍" class="headerlink" title="第二章 关系模型介绍"></a>第二章 关系模型介绍</h2><h3 id="关系数据库的结构"><a href="#关系数据库的结构" class="headerlink" title="关系数据库的结构"></a>关系数据库的结构</h3><p>关系数据库由<strong>表</strong>构成（实际上就是表的集合）。</p><p>在关系模型中，<strong>关系</strong> 被用来指代 <strong>表</strong>，<strong>元组</strong> 被用来指代 <strong>行</strong>，<strong>属性</strong> 被用来指代 <strong>列</strong>。</p><ul><li>关系实际上是元组的集合。</li></ul><p>对于每个属性的取值都有一个范围，这个范围就是<strong>域</strong>。并且该域中的元素都是<strong>不可再分（原子）</strong>的。</p><p>数据库模式：数据库的逻辑设计；数据库实例：某⼀时刻数据库中的数据的快照。关系模式、关系实例与之类似。</p><ul><li><p>关系模式由<strong>属性列表</strong>和<strong>各属性对应的域</strong>组成（可能包括主码约束）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Students</span>(<span class="hljs-attribute">student_id</span>: INT, <span class="hljs-attribute">name</span>: <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">100</span>), <span class="hljs-attribute">age</span>: INT)<br></code></pre></td></tr></table></figure></li><li><p>模式很少改变，但是实例会随着时间发生改变。</p></li></ul><h3 id="码（妈的）"><a href="#码（妈的）" class="headerlink" title="码（妈的）"></a>码（妈的）</h3><p><strong>超码：</strong>一个或多个属性的集合，这个集合可以唯⼀地区分出⼀个元组（行）。</p><p><strong>候选码：</strong>最小超码，可能有多个。</p><p><strong>主码：</strong>人为选中，作为⼀行的区分标准的<strong>候选码</strong>。</p><p><strong>外码：</strong>：关系 r1 的属性中可能包含了关系 r2 的主码，这个属性在 上称作参照 r1 的外码，r1 称作外码依赖的参照关系， r2 称作外码依赖的被参照关系。（<strong>必须是 r2 的主码！！</strong>）</p><p><strong>参照完整性约束：</strong>参照关系中的任意元组的特定属性的取值必须等于被参照关系中某个元组的特定属性的取值。这个对比外码放松了条件！不需要是主码！</p><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>看那个 pdf，这里没时间写了。</p><p>在关系代数运算中，五种基本运算为<strong>并</strong>、<strong>差</strong>、<strong>选择</strong>、<strong>投影</strong>、<strong>笛卡尔积</strong>。</p><p><strong>关系运算的结果也是关系（表）。</strong></p><p>笛卡尔积运算跟连接不一样！结果一共有 n1 x n2 个元组。</p><p>集合运算 交 并 差的运算，记得是集合！所以并集中重复的部分只会保留一个！需要满足两个关系是<strong>属性数量一</strong>致并且<strong>属性的域相同</strong>。</p><p>这里简单的提下<strong>除法</strong>，除法的定义是如果关系 R 有 ABC 三个属性，关系 S 有 AB两个属性。那么R 除 S的集合结果是在 R 中找出属性 AB 取值跟 S 中的属性 AB 取值一样的元组。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>一个数据库可以有多个关系模式</strong></li><li><strong>每个关系模式可以包含多个表</strong></li></ol><blockquote><p>假设有一个数据库 <code>CompanyDB</code>，该数据库包含多个关系模式，每个关系模式下有多个表：</p><ul><li>**<code>HRSchema</code>**（人力资源模式）：包含 <code>Employees</code>（员工表）、<code>Departments</code>（部门表）、<code>Salaries</code>（薪资表）。</li><li>**<code>FinanceSchema</code>**（财务模式）：包含 <code>Invoices</code>（发票表）、<code>Transactions</code>（交易表）。</li><li>**<code>SalesSchema</code>**（销售模式）：包含 <code>Customers</code>（客户表）、<code>Orders</code>（订单表）、<code>Products</code>（产品表）。</li></ul></blockquote><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>对关系的完整性约束通常包括_________三种。<br>A、实体完整性、属性完整性、关系完整性；<br>B、实体完整性、参照完整性、用户定义完整；<br>C、实体完整性、属性完整性、用户定义完整；<br>D、实体完整性、属性完整性、参照完整性；<br>正确答案：B</p><p>主键应该体现它的<strong>唯一</strong>和<strong>非空</strong>性。</p><p>在关系模式中，使用<strong>二维表</strong>表示数据。</p> <h2 id="第三章-SQL介绍"><a href="#第三章-SQL介绍" class="headerlink" title="第三章 SQL介绍"></a>第三章 SQL介绍</h2><p>建表的时候的 primary key 和 foreign key 都是属于完整性约束，SQL 禁止任何破坏完整性约束的数据库更新。</p><p>一个数据库管理系统的实例可以创建多个数据库，一个数据库可以有多个关系模式，一个关系模式可以由多个表组成。</p><h3 id="sql基本结构与关系代数对应"><a href="#sql基本结构与关系代数对应" class="headerlink" title="sql基本结构与关系代数对应"></a>sql基本结构与关系代数对应</h3><p>关系代数是<strong>集合运算</strong>！sql不是….</p><ol><li><p><strong><code>SELECT</code> 对应 π（投影）</strong></p><p>但是并不等价，因为<code>select</code>会返回重复的行，但$$\pi$$是<strong>集合运算</strong>不会返回重复的行。</p></li><li><p><strong><code>FROM</code> 对应笛卡尔积（×）</strong></p></li><li><p><strong><code>WHERE</code> 对应 σ（选择）</strong></p></li><li><p><strong><code>as</code>对应P</strong></p></li></ol><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li><strong><code>FROM</code></strong><br>执行首先发生在 <code>FROM</code> 子句，确定从哪个表（或视图）中获取数据。如果有多个表，数据库会先执行 <code>JOIN</code> 操作来将它们结合在一起。</li><li><strong><code>ON</code></strong><br>如果查询中涉及连接（<code>JOIN</code>），数据库会首先根据 <code>ON</code> 子句中指定的条件来匹配连接的行。</li><li><strong><code>JOIN</code></strong><br>对于多表查询，数据库在 <code>FROM</code> 中确定了表并处理了 <code>ON</code> 中的连接条件后，会执行连接操作（如 <code>INNER JOIN</code>、<code>LEFT JOIN</code> 等）。</li><li><strong><code>WHERE</code></strong><br>在从表中获取数据后，数据库会通过 <code>WHERE</code> 子句来过滤行，仅保留符合条件的行。</li><li><strong><code>GROUP BY</code></strong><br>接着，数据库会根据 <code>GROUP BY</code> 子句对结果进行分组。如果查询涉及聚合函数（如 <code>COUNT</code>、<code>SUM</code>、<code>AVG</code> 等），它们会在分组之后应用。</li><li><strong><code>HAVING</code></strong><br><code>HAVING</code> 子句与 <code>WHERE</code> 类似，但它是在分组之后对聚合结果进行过滤的。<code>WHERE</code> 是用来过滤行的，而 <code>HAVING</code> 用来过滤分组。</li><li><strong><code>SELECT</code></strong><br>在数据被过滤并分组后，<code>SELECT</code> 子句决定了最终查询返回哪些列。如果查询中有聚合函数（如 <code>SUM</code>、<code>AVG</code> 等），此时会计算聚合值。</li><li><strong><code>DISTINCT</code></strong><br>在选择列后，如果查询使用了 <code>DISTINCT</code> 关键字，数据库会去除重复的行。</li><li><strong><code>ORDER BY</code></strong><br><code>ORDER BY</code> 用于对查询结果进行排序。排序通常是在所有其他操作完成后执行的。</li></ol><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><ul><li><code>INtro%</code>匹配以 INtro 打头的任意字符串。</li><li><code>%comp%</code>匹配任意包含 comp 的字符串。</li><li><code>___</code>匹配只有三个字符的任意字符串</li><li><code>___%</code>匹配至少含有三个字符的任意字符串。</li></ul><h3 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序 order by"></a>排序 order by</h3><p>可以选择多个属性进行排序，例如对salary升序，但是对salary一样的元组进行 name 降序排列。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> *<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">asc</span>, <span class="hljs-type">name</span> <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>SQL 中的 union、intersect、except对应 并、交、差。</p><ol><li><p><code>UNION</code>（并集）：</p><p><code>UNION</code> 用于合并两个查询的结果集，并去除重复的行。</p><p>保留重复的行需要<code>union all</code>！！</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table2;<br></code></pre></td></tr></table></figure></li><li><p><code>INTERSECT</code>（交集）：</p><p><code>INTERSECT</code> 用于返回两个查询结果中的公共部分（交集）。</p><p>保留重复的行需要<code>intersect all</code>！！</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">INTERSECT</span><br><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table2;<br></code></pre></td></tr></table></figure></li><li><p><code>EXCEPT</code>（差集）：</p><p><code>EXCEPT</code> 用于返回第一个查询结果中有而第二个查询结果中没有的行。</p><p>保留重复的行需要<code>except all</code>！！</p><blockquote><p>去除重复项的操作是在集合差运算前，所以假设c1有四个重复的元组a，c2有两个重复的元组a，那么最后a不会有输出。</p><p>若except all ，最终会有两个a输出。</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">EXCEPT</span><br><span class="hljs-keyword">SELECT</span> column1, column2<br><span class="hljs-keyword">FROM</span> table2;<br></code></pre></td></tr></table></figure></li></ol><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>定义 true false 之外的第三种逻辑值 unknown。</p><ul><li><strong>and</strong><ul><li><strong>false</strong> and <strong>unknown</strong> &#x3D; <strong>false</strong></li><li><strong>unknown</strong> and <strong>unknown</strong> &#x3D; <strong>unknown</strong></li></ul></li><li><strong>or</strong><ul><li><strong>true</strong> or <strong>unknown</strong> &#x3D; <strong>true</strong></li><li><strong>false</strong> or <strong>unknown</strong> &#x3D; <strong>unknown</strong></li><li><strong>unknown</strong>  or <strong>unknown</strong>  &#x3D; <strong>unknown</strong></li></ul></li><li><strong>not</strong><ul><li>not <strong>unknown</strong>  &#x3D; <strong>unknown</strong> </li><li>如果 r.a 为空，那么 1 &lt; r.a 和 not(1&lt;r.a) 都为空。</li></ul></li></ul><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>在 SQL 中，聚集函数用于对一组数据进行操作，生成单个结果。常见的聚集函数有 <code>AVG</code>（计算平均值）、<code>SUM</code>（求和）、<code>COUNT</code>（计数）、<code>MAX</code>（最大值）、<code>MIN</code>（最小值）。</p><ul><li><p><strong>平均值</strong></p><p><code>AVG</code> 函数计算一列数据的平均值，即所有数据值的总和除以数据的数量。</p><p>计算平均值的时候，保留重复项是很重要的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> AVG(<span class="hljs-built_in">column_name</span>)<br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span><br><span class="hljs-keyword">WHERE</span> condition;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>AVG</code> 函数忽略 <code>NULL</code> 值，也就是说，如果某一行的该列是 <code>NULL</code>，则该行不会计入总和和计数。</p></li><li><p><strong>计数</strong></p><p><code>COUNT(*)</code> 计算结果集中所有行的数量，不会忽略 <code>NULL</code> 或空值，它包括所有的行。</p><p><code>COUNT(column_name)</code> 与 <code>COUNT(*)</code> 不同，<code>COUNT(column_name)</code> 会忽略该列中的 <code>NULL</code> 值。</p><p><code>COUNT(DISTINCT column_name)</code> 计算特定列中唯一非空值（<code>NOT NULL</code>）的数量，重复值会被去除。</p></li><li><p>求和</p><p><code>SUM</code> 函数是 SQL 中常用的聚集函数之一，用于计算某一列中所有数值的总和。</p><p>跟 <code>count</code>一样，<code>SUM(column_name)</code> 用于对指定列中的所有非空数值进行求和。该函数只适用于数值型数据列，且会忽略 <code>NULL</code> 值。</p></li><li><p>最大最小值</p><p>这个就不讲了。</p></li></ul><p>除了<code>count(*)</code>以外的所有聚集函数都忽略<code>NULL</code>！！</p><h3 id="分组聚集-group-by"><a href="#分组聚集-group-by" class="headerlink" title="分组聚集 group by"></a>分组聚集 group by</h3><p>在 <code>group by</code>中，只有group by 的属性和聚集函数可以被 <code>select</code>。</p><p>搭配<code>having</code>使用。</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="集合比较"><a href="#集合比较" class="headerlink" title="集合比较"></a>集合比较</h4><ul><li><p><code>SOME</code> 会检查子查询返回的多个值，只要<strong>至少有一个</strong>值满足条件，整个条件成立。</p><p>如果我们想查找所有价格大于<strong>至少</strong>有一个订单中的产品的价格的产品，可以使用 <code>SOME</code>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> product_name, price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> price &gt; <span class="hljs-keyword">SOME</span> (<span class="hljs-keyword">SELECT</span> price <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">WHERE</span> Orders.product_id = Products.product_id);<br></code></pre></td></tr></table></figure><ul><li>这里，<code>SOME</code> 检查 <code>Products</code> 中的每个产品的价格是否大于<strong>至少一个</strong>订单中的相应产品价格。</li></ul></li><li><p><code>ALL</code> 会检查子查询返回的所有值，只有<strong>所有值</strong>都满足条件时，整个条件才成立。</p><p>继续使用上面的 <code>Products</code> 和 <code>Orders</code> 表。如果我们想查找价格大于<strong>所有</strong>订单中该产品价格的产品，可以使用 <code>ALL</code>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> product_name, price<br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">WHERE</span> price &gt; <span class="hljs-keyword">ALL</span> (<span class="hljs-keyword">SELECT</span> price <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">WHERE</span> Orders.product_id = Products.product_id);<br></code></pre></td></tr></table></figure><ul><li>这里，<code>ALL</code> 检查 <code>Products</code> 中的每个产品的价格是否大于<strong>所有</strong>订单中的相应产品价格。</li></ul></li><li><p><code>EXISTS</code> 用于判断子查询是否返回结果。如果子查询有结果（即返回至少一行数据），<code>EXISTS</code> 返回 <code>TRUE</code>；如果子查询没有结果，则返回 <code>FALSE</code>。</p><p>假设我们希望查找那些有订单记录的产品，可以使用 <code>EXISTS</code>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> product_name<br><span class="hljs-keyword">FROM</span> Products p<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">FROM</span> Orders o <br>    <span class="hljs-keyword">WHERE</span> o.product_id = p.product_id<br>);<br></code></pre></td></tr></table></figure><ul><li>这里，<code>EXISTS</code> 检查是否存在至少一个订单与 <code>Products</code> 中的产品相关联。如果存在这样的订单，<code>EXISTS</code> 返回 <code>TRUE</code>，因此该产品会被选中。</li></ul></li><li><p><code>with</code>语句用于临时定义一个表。</p></li><li><p>标量子查询，只要<code>select</code>语句的返回值是一个包含单个属性的元组（值），可以出现在<code>select</code>、<code>where</code>、<code>having</code>中。</p></li></ul><p><strong>不相关子查询：</strong>子查询的查询条件不依赖于父查询，由里向外逐层处理。既每一个子查询在上级查询处理之前求解，子查询的结果用于建立其子查询的查找条件。</p><p><strong>相关子查询：</strong>子查询的查询条件依赖于父查询，首先取外层查询中的表的第一个元组，根据它与内层查询相关的属性值的属性值处理查询内层查询，若 where 子句返回的值为真，则取此元组放入查询结果表，然后再取外层表的下一个元组，重复这一过程，直至外层表全部检测完为止。</p><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><ul><li><code>as</code>不能出现在<code>where</code>里面！</li></ul><h2 id="第四章-中级sql"><a href="#第四章-中级sql" class="headerlink" title="第四章 中级sql"></a>第四章 中级sql</h2><ul><li><p><strong>内连接</strong></p><p>内连接只返回两个表中<strong>有匹配的</strong>记录。如果两个表中某一行没有匹配的记录，那么这行数据不会出现在结果中。</p></li><li><p><strong>左外连接</strong></p><p>返回<strong>左表</strong>的所有记录，右表中没有匹配的行会显示为 <code>NULL</code>。</p></li><li><p><strong>右外连接</strong></p><p>返回<strong>右表</strong>的所有记录，左表中没有匹配的行会显示为 <code>NULL</code>。</p></li><li><p><strong>全外连接</strong></p><p>返回<strong>两个表</strong>的所有记录，左右表中没有匹配的行都会显示为 <code>NULL</code>。</p></li></ul><p>以上四种连接输出顺序：公共属性，左边表属性，右边表属性。</p><p>以上的四种连接都只会输出一次进行连接的属性，但是如果使用 on 的话就会输出两个连接的属性。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><blockquote><p>简单来说，就显示表的子集，是虚拟的。</p></blockquote><p><strong>视图</strong>是数据库中的虚拟表，它通过一个<strong>查询</strong>来表示数据，而不存储实际的数据。视图可以帮助简化复杂查询，增强数据的安全性，并提供更直观的接口。</p><p><strong>定义</strong>：视图实际上是一个<strong>存储的查询</strong>。当你访问视图时，数据库会自动执行这个查询并返回结果。视图的内容取决于它所定义的查询，因此它不占用存储空间（除了存储查询本身的定义），只保存查询的结构。</p><ul><li>可以被当成一个表查询</li><li>可以建立视图的视图</li></ul><h4 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h4><p>条件如下：</p><ul><li>视图只涉及一个表</li><li><code>SELECT</code>子句只包含关系的属性名</li><li>没有使用 <code>DISTINCT</code> 或 <code>GROUP BY</code>或<code>having</code></li><li>没有出现在<code>SELECT</code>中的属性都可以取<code>NULL</code>。</li></ul><p><code>with check option</code>可以判断加入视图的元组是否满足创建视图的条件。</p><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><p>单个关系上的约束有：</p><ul><li><p><strong>not null</strong></p></li><li><p><strong>unique</strong></p><p>这意味着，<strong>两个元组（行）中对应 <code>UNIQUE</code> 列的 <code>NULL</code> 值可以同时出现</strong>，因为 SQL 不认为两个 <code>NULL</code> 值是相等的，它们被视为不同的值。</p></li><li><p><strong>check(&lt; 谓词 &gt;)</strong></p><p>只要谓词不为假，check 就成立。为<code>NULL</code>也成立喔！！</p></li></ul><h4 id="引用完整性"><a href="#引用完整性" class="headerlink" title="引用完整性"></a>引用完整性</h4><p><strong>外码</strong></p><p><strong>外键约束</strong>用于确保两个表之间的数据一致性。当我们在表中定义外键时，通常会为外键约束指定不同的级联操作。</p><ul><li><strong>DELETE CASCADE</strong><ul><li><strong>定义</strong>：当父表中的某个记录被删除时，<strong>所有引用该记录的子表中的记录也会被自动删除</strong>。</li></ul></li><li><strong>SET NULL</strong><ul><li><strong>定义</strong>：当父表中的某个记录被删除时，**子表中所有引用该记录的外键列的值会被设置为 <code>NULL</code>**。</li></ul></li><li><strong>RESTRICT</strong><ul><li><strong>定义</strong>：当父表中的某个记录被删除时，如果子表中有任何记录引用该父记录，<strong>删除操作将被拒绝</strong>。</li></ul></li></ul><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>grant select on book to user1 with grant option</p><p>revoke select on book from user1</p><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h3><p>视图是由<strong>基本表</strong>或者<strong>视图</strong>导出的。</p><p>SQL语言中，条件年龄 BETWEEN 18 AND 30表示年龄在18至30之间，且_________。<br>A、包括30岁但不包括18岁 B、包括18岁和30岁<br>C、包括18岁但不包括30岁 D、不包括18岁和30岁<br>正确答案：B</p><p>允许取空值但不允许出现重复值的约束是_________。<br>A、NULL B、PRIMARY KEY<br>C、UNIQUE D、FOREIGN KEY<br>正确答案：C</p><h2 id="第五章-高级sql"><a href="#第五章-高级sql" class="headerlink" title="第五章 高级sql"></a>第五章 高级sql</h2><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p><strong>触发器</strong>是一种数据库对象，它是在数据库操作（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）发生时自动执行的特定操作。触发器能够帮助自动化数据验证、修改、记录日志、执行业务规则等任务。</p><p>触发器通常是在表或视图上的某些事件发生时被触发。常见的触发器事件有：</p><ul><li>**<code>INSERT</code>**：在向表中插入数据时触发。</li><li>**<code>UPDATE</code>**：在更新表中的数据时触发。</li><li>**<code>DELETE</code>**：在删除表中的数据时触发。</li></ul><p><strong>SQL Server 触发器语法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span><br>[ <span class="hljs-keyword">FOR</span> &#123; <span class="hljs-keyword">INSERT</span> | <span class="hljs-keyword">DELETE</span> | <span class="hljs-keyword">UPDATE</span> &#125; ]<br>[ <span class="hljs-keyword">AS</span> ]<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">-- 触发器的逻辑</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p><strong>触发器类型</strong></p><ol><li><p><strong>AFTER 触发器</strong></p><p><strong>定义</strong>：在执行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作后触发。SQL Server 中没有 <code>BEFORE</code> 触发器，因此所有触发器默认在操作之后执行。</p></li><li><p><strong>INSTEAD OF 触发器</strong></p><p><strong>定义</strong>：用于代替 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作。在触发器触发时，原始的操作被替代为触发器定义的逻辑。</p></li><li><p><strong>BEFORE 触发器</strong></p><p><strong>定义</strong>：在进行 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作之前触发。可以用于在操作前检查或修改即将进行的操作数据。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span>&lt;触发器名&gt;<br> &#123;<span class="hljs-keyword">before</span> | <span class="hljs-keyword">after</span>&#125;&lt;触发事件&gt;<br> <span class="hljs-keyword">on</span> &lt;表名&gt;<br> <span class="hljs-keyword">referencing new</span> | <span class="hljs-built_in">old</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">as</span> &lt;变量&gt;<br> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span>&#123;<span class="hljs-keyword">row</span> | <span class="hljs-keyword">statement</span>&#125;<br> [<span class="hljs-keyword">when</span> &lt;触发条件&gt;] &lt;触发动作体&gt;;<br></code></pre></td></tr></table></figure><ul><li><code>FOR EACH ROW</code>子句之后，对于新插入的每一行上面进行迭代。</li><li><code>REFERENCING NEW ROW AS NEW</code>子句创建一个过度变量。</li></ul><p>Before 触发器不是 sql server所支持的，但是课本有，这里就提一下。以及这个触发器格式也不是 sql server的。</p></li></ol><p>在 SQL Server 中，触发器提供了两个伪表来访问 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作中的数据：</p><ul><li>**<code>INSERTED</code>**：在 <code>INSERT</code> 和 <code>UPDATE</code> 操作中，存储新插入或更新的行数据。</li><li>**<code>DELETED</code>**：在 <code>DELETE</code> 和 <code>UPDATE</code> 操作中，存储删除的行数据（或在 <code>UPDATE</code> 中存储更新前的行数据）。</li></ul><p>触发器只能定义在基本表上，不能<strong>定义在视图上</strong>。</p><h3 id="其他（必考）"><a href="#其他（必考）" class="headerlink" title="其他（必考）"></a>其他（必考）</h3><h2 id="第六章-使用E-R模型的数据库设计"><a href="#第六章-使用E-R模型的数据库设计" class="headerlink" title="第六章 使用E-R模型的数据库设计"></a>第六章 使用E-R模型的数据库设计</h2><p>实体 - 联系模型用于表示<strong>概念设计</strong>。逻辑（概念）模式定义了实体、实体的属性、实体间的联系、实体和联系上的约束等。</p><blockquote><p>就是只考虑需要的功能，不需要考虑如何实现。</p></blockquote><p>数据库设计中要避免的缺陷是<strong>冗余</strong>、<strong>不完整</strong>。</p><h3 id="E-R模型的基本概念："><a href="#E-R模型的基本概念：" class="headerlink" title="E-R模型的基本概念："></a><strong>E-R模型的基本概念</strong>：</h3><ul><li><p><strong>实体</strong>：表示现实世界中的对象，具有独立存在的意义，例如学生、课程、员工等。实体通过一组<strong>属性</strong>来描述。</p><p>实体要有<strong>主键</strong>！！</p></li><li><p><strong>实体集</strong>：是相同类型的实体的集合。</p></li><li><p><strong>联系</strong>：表示实体之间的联系或交互，例如学生和课程之间的“选修”关系。</p></li><li><p><strong>联系集</strong>：是相同类型联系的集合。实体集 E1、E2 … 参与联系集 R。</p></li><li><p><strong>弱实体（Weak Entity）</strong>：没有足够的属性来唯一标识的实体，它依赖于其他实体的主键来构成自己的主键。</p><p>类似需要外键（即别人的主码）来描述自己。</p></li></ul><p>联系集的<strong>度</strong>定义为<strong>实体集参与的数量</strong>。</p><p>构成 E-R 模型的三个元素：<strong>实体</strong>、<strong>属性</strong>、<strong>联系</strong>。</p><h3 id="复杂属性"><a href="#复杂属性" class="headerlink" title="复杂属性"></a>复杂属性</h3><ul><li><p>简单和复合。</p><p>简单属性就是<strong>不可再分</strong>的，复合属性就是<strong>可再分</strong>的。</p></li><li><p>单值和多值</p><p>像电话号码这类属性就是多值属性。<code>&#123;&#125;</code></p></li><li><p>派生属性</p><p>可以从其他的属性中计算得到。派生属性的值不存储在数据库中。<code>()</code></p></li></ul><h3 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h3><p>映射基数主要有以下几种类型：</p><ol><li><p><strong>一对一（1:1）</strong></p><p>在一对一关系中，一个实体的每个实例最多只能与另一个实体的一个实例关联，反之亦然。</p></li><li><p><strong>一对多（1:N）</strong></p><p>在一对多关系中，一个实体的每个实例可以与另一个实体的多个实例关联，但另一个实体的每个实例只能与一个实体的实例关联。</p></li><li><p><strong>多对多（M:N）</strong></p><p>在多对多关系中，一个实体的每个实例可以与另一个实体的多个实例关联，反之亦然。</p></li></ol><p>需要记得是可以<strong>为零的</strong>！！如果想要一个实体集在联系集中全部参与，记得<strong>要双线</strong>！！</p><h3 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h3><p>多对多的主码是 两个实体集的主码的并集。</p><p>一对多或者多对一的主码是 “多”那方的主码。</p><p>一对一的主码是 任一实体集的主码。</p><h3 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h3><p>在<strong>实体-关系模型（E-R模型）</strong>中，<strong>弱实体集</strong>是指无法单独唯一标识其实例的实体集。弱实体集通常依赖于另一个实体集来进行标识（称为<strong>标识性实体集</strong>）因此无法独立存在。</p><p><strong>没有完整的主键</strong>：弱实体集没有自己的主键，它需要依赖另一个实体集的主键来唯一标识每个实体。（外键）</p><p>主码由 标识性实体集（主码）和弱实体集的分辨符（即弱实体自己的主码）构成。</p><p>弱实体和联系都是<strong>双边框</strong>的。</p><p>标识性实体集 和 弱实体集 必须是一对多的。</p><h3 id="转换为关系模型"><a href="#转换为关系模型" class="headerlink" title="转换为关系模型"></a>转换为关系模型</h3><h4 id="1-实体集到关系模型"><a href="#1-实体集到关系模型" class="headerlink" title="1. 实体集到关系模型"></a>1. <strong>实体集到关系模型</strong></h4><p>每个<strong>实体集</strong>（Entity Set）转换为一个<strong>关系</strong>（Relation）。实体集中的每个属性都变成关系的一个字段。具体步骤如下：</p><ul><li><strong>实体集</strong>：每个实体集（矩形框）会成为一个关系（表）。</li><li><strong>属性</strong>：实体集中的每个属性都变为关系表中的一列（列名）。</li><li><strong>主键</strong>：实体集中的主键属性在关系中作为<strong>主键</strong>。</li></ul><h4 id="2-联系集到关系模型"><a href="#2-联系集到关系模型" class="headerlink" title="2. 联系集到关系模型"></a>2. <strong>联系集到关系模型</strong></h4><ol><li><p><strong>一对一（1:1）关系</strong>：</p><p>如果联系集是<strong>一对一</strong>（1:1）将其作为两个实体集之一的属性。</p></li><li><p><strong>一对多（1:N）关系</strong>：</p><p>对于一对多的关系，在“多方”实体集的表中加入“单方”实体集的主键作为外键。</p></li><li><p><strong>多对多（M:N）关系</strong>：</p><p>对于多对多的关系集，需要创建一个<strong>关联表</strong>。关联表的字段包括两个实体集的主键作为外键，以及可能的额外属性。</p></li></ol><h4 id="3-弱实体集到关系模型"><a href="#3-弱实体集到关系模型" class="headerlink" title="3. 弱实体集到关系模型"></a>3. <strong>弱实体集到关系模型</strong></h4><p>对于<strong>弱实体集</strong>，需要使用其依赖的<strong>强实体集</strong>的主键以及弱实体集的部分属性来唯一标识弱实体集的实例。</p><h4 id="4-多值属性到关系模型"><a href="#4-多值属性到关系模型" class="headerlink" title="4. 多值属性到关系模型"></a>4. 多值属性到关系模型</h4><p>在关系模型中，每个多值属性转换为一个独立的关系（表）。该表包括原实体集的主键。该关系的所有属性为主码。</p><h3 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a>其他</h3><p>一般动作用联系集。</p><h2 id="第七章-关系数据库设计"><a href="#第七章-关系数据库设计" class="headerlink" title="第七章 关系数据库设计"></a>第七章 关系数据库设计</h2><p>关系数据库设计的⽬的是得到⼀组合适的关系模式，使其不含<strong>冗余</strong>，<strong>结构良好</strong>，便于获取信息。</p><p>用于设计关系数据库的方法是使用一个叫<strong>规范化</strong>的过程。</p><blockquote><p>简单来说判断关系好不好，不好就无损分解，使它变好。</p></blockquote><h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><ul><li><p><strong>有损分解</strong> </p><p>对于分解后的两个模式进行自然连接后，无法完整地得到原有的信息。</p></li><li><p><strong>无损分解</strong> </p><p>对于分解后的两个模式进行自然连接后，能够完整地得到原有的信息。</p></li></ul><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p><strong>函数依赖</strong>是一个形如 $$\alpha \rightarrow \beta$$ 的逻辑推理公式，表示属性集 $$\alpha$$ <strong>决定</strong>（determine）属性集 $$\beta$$，或称 $$\beta$$ <strong>依赖</strong> $$\alpha$$。同一模式中包含的多条函数依赖称为函数依赖集。</p><p>例如，R 上的两个属性 $$\alpha$$ 和 $$\beta$$，如果关系实例中的所有元组对 $$t_1$$, $$t_2$$ 都符合若 $$t_1[\alpha] &#x3D; t_2[\alpha]$$，则$$t_1[\beta] &#x3D; t_2[\beta]$$。也就是说，只要我们知道 $$\alpha$$ 的值，就能唯一确定 $$\beta$$ 的值，称 $$\alpha$$ 决定 $$\beta$$。特别地，如果 $$\beta \subseteq \alpha$$，称为平凡的函数依赖。</p><p>由此，我们得出<strong>超码</strong>的新定义：对于关系 R 和函数依赖集 K，若 $$K \rightarrow R$$ 在 r(R) 上成立，则 K 是 r(R) 的一个超码。</p><p>若$$R_1$$, $$R_2$$ 是 R 的无损分解，则 r(R) 上的函数依赖集闭包 $$F^+$$ 中至少存在以下依赖中的一个：</p><ul><li><p>$$R_1 \cap R_2 \rightarrow R_1 ;$$$$R_1 \cap R_2 \rightarrow R_12 $$;</p></li><li><p>即 $$R_1 \cap R_2$$ 是 $$R_1$$ 或 $$R_2$$ 的超码。连接的属性一定要是某一边的主码，自然连接数量才不会变多。</p></li></ul><h4 id="平凡依赖的例子"><a href="#平凡依赖的例子" class="headerlink" title="平凡依赖的例子"></a>平凡依赖的例子</h4><p>关系模式 <strong>R(A, B, C)</strong></p><ul><li>依赖关系：<ul><li><strong>A → A</strong><br>这是一个平凡依赖，因为被依赖的属性 <strong>A</strong> 已经包含在决定属性 <strong>A</strong> 中。</li><li><strong>AB → A</strong><br>这是一个平凡依赖，因为被依赖的属性 <strong>A</strong> 是决定属性 <strong>AB</strong> 的子集。</li></ul></li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>域是原子的，不可分的，即域只有单一的值。</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>非码属性需要整个主码来推出，不能由主码的一部分推出。</p><h4 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h4><p><strong>比第三范式严格</strong>。</p><p>一个关系模式 <strong>R</strong> 满足 BC 范式，当且仅当：</p><ul><li>对于 R 中的每一个非平凡函数依赖 <strong>X → Y</strong>，<strong>X</strong> 是 <strong>R</strong> 的一个超码。</li></ul><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>比第二范式严格，比 BCNF 放松。</p><p>在 2NF 的基础上，消除了非主属性对码的传递函数依赖。</p><p>简单来说，就是满足：</p><ul><li>对于 R 中的每一个非平凡函数依赖 <strong>X → Y</strong>，当<strong>Y</strong>是非主码属性的时候，<strong>X</strong>一定是超码。</li></ul><h4 id="BCNF与第三范式区别"><a href="#BCNF与第三范式区别" class="headerlink" title="BCNF与第三范式区别"></a>BCNF与第三范式区别</h4><p>若<strong>Y</strong>是主码，则一定满足第三范式！！但不一定满足BCNF范式。</p><p><strong>BCNF分解 不满足 保持依赖 只满足无损分解！第三范式分解满足两个！！</strong></p><ul><li>一个规范化过程是<strong>依赖保持的</strong>，如果在分解后的所有子关系模式中，所有原始关系模式的函数依赖都能够在这些子关系模式中找到相应的依赖，或者通过子关系模式中的依赖推导出来。</li></ul><h4 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h4><p>比 BCNF 严格。</p><p>只能有一个多值依赖，BCNF 可以有多个。 </p><h3 id="Armstrong-公理系统"><a href="#Armstrong-公理系统" class="headerlink" title="Armstrong 公理系统"></a>Armstrong 公理系统</h3><p>反复运用以下三条 Armstrong 公理，就能通过 FFF 求出 F+F^+F+，保证结果是正确有效的。</p><ul><li><strong>自反律</strong>：若 $$\alpha$$ 为一属性集，$$\beta \subseteq \alpha$$，则$$\alpha \rightarrow \beta$$</li><li><strong>增补律</strong>：若 $$\alpha \rightarrow \beta$$，$$\gamma$$ 为一属性集，则$$\gamma\alpha \rightarrow \gamma\beta$$</li><li><strong>传递律</strong>：若 $$\alpha \rightarrow \beta$$ 且$$\beta \rightarrow \gamma$$，则$$\alpha \rightarrow \gamma$$</li><li><strong>合并律</strong>：若$\alpha \rightarrow \beta$  且  $$\alpha \rightarrow \gamma$$ ,则$$\alpha \rightarrow \beta\gamma$$</li><li><strong>分解律</strong>：若$$\alpha \rightarrow \beta\gamma$$,则$\alpha \rightarrow \beta$  且  $$\alpha \rightarrow \gamma$$</li><li><strong>伪传递律</strong>：若$\alpha \rightarrow \beta$  且  $$\gamma\beta \rightarrow \delta$$,则$$\gamma\alpha \rightarrow \delta$$</li></ul><h3 id="属性闭包"><a href="#属性闭包" class="headerlink" title="属性闭包"></a>属性闭包</h3><p>给定一个关系模式 <strong>R</strong> 和一组属性 <strong>X</strong>，属性闭包 <strong>X⁺</strong> 是 <strong>X</strong> 在一组函数依赖 <strong>F</strong> 下能够决定的所有属性的集合。换句话说，<strong>X⁺</strong> 包含了所有可以通过函数依赖从 <strong>X</strong> 推导出的属性。</p><p><strong>确定候选键</strong>：通过计算属性闭包，可以判断一组属性是否能唯一标识关系中的所有元组。</p><h3 id="正则覆盖"><a href="#正则覆盖" class="headerlink" title="正则覆盖"></a>正则覆盖</h3><p>就是精简化 F，同时$$F^+$$不变。</p><h4 id="无关属性"><a href="#无关属性" class="headerlink" title="无关属性"></a>无关属性</h4><p>在函数依赖 $$\alpha \rightarrow \beta$$ 中：</p><ul><li>要证明 $$\alpha$$ 中的属性 A 是无关的，计算 $$(\alpha - A)$$的闭包，如果闭包内属性包含$$\beta$$中所有属性，A 就是无关属性。</li><li>要证明 $$\beta$$ 中的属性 A 是无关的，计算 $$\alpha $$的闭包，如果闭包内属性包含A，A 就是无关属性。</li></ul><p><a href="https://tencentcloud.csdn.net/667e50041116284a36444689.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTIyNTQ5MSwiZXhwIjoxNzM2MzEwMDA4LCJpYXQiOjE3MzU3MDUyMDgsInVzZXJuYW1lIjoidG9ieXRhbTIzIn0.X4-Aj--ACcQR-HBVPi_j793U-dfprfaIBPD5MD_pL6I">【数据库系统原理复习】正则覆盖&#x2F;最小覆盖 canonical&#x2F;minimal cover_sql_真的很拉风-腾讯云开发者社区</a></p><p>这个例子讲的很好</p><p>计算方法：</p><ol><li><p><strong>将右侧复合的函数依赖全部拆开。</strong></p></li><li><p><strong>去掉重复的。</strong></p></li><li><p><strong>看看左边能不能拆开。</strong></p></li><li><p><strong>合并。</strong></p></li></ol><h3 id="分解-1"><a href="#分解-1" class="headerlink" title="分解"></a>分解</h3><h4 id="BCNF分解"><a href="#BCNF分解" class="headerlink" title="BCNF分解"></a>BCNF分解</h4><p>满足无损分解，不满足保持依赖。</p><p><strong>将每个依赖拆开成Ri，将Ri的主码加回去原本的依赖集内</strong></p><h4 id="3NF分解"><a href="#3NF分解" class="headerlink" title="3NF分解"></a>3NF分解</h4><p>满足无损分解和保持函数依赖。</p><p><strong>将每个依赖拆分开成Ri，如果最后所有的Ri都没有候选码，就加上候选码成为最后一个Ri。</strong></p><h4 id="4NF分解（与BCNF类似）"><a href="#4NF分解（与BCNF类似）" class="headerlink" title="4NF分解（与BCNF类似）"></a>4NF分解（与BCNF类似）</h4><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p>一个 a 值对应了多个 b 值。</p><p><strong>固定 a 值，更换 b 值，如果更换之后的元组还存在 R 中，则 a 多值依赖 b。</strong></p><p>函数依赖是一个 a 值只能对应一个 b 值。 </p><p>性质如下：</p>  <p>第一个很明显，多值依赖是一个a对应多个b，那么函数依赖一个a对应一个b当然满足。</p><h3 id="其他-5"><a href="#其他-5" class="headerlink" title="其他"></a>其他</h3><p>在下列关于规范化理论的叙述中，不正确的是_________。<br>A、任何一个关系模式一定有键。<br>B、任何一个包含两个属性的关系模式一定满足3NF。<br>C、任何一个包含两个属性的关系模式一定满足BCNF。<br>D、任何一个包含三个属性的关系模式一定满足2NF。<br>正确答案：D</p><p>在数据库设计中数据流图（DFD）和数据字典(DD)主要用来描述结构化方法中的_________阶段的工具。<br>A、概念结构设计 B、需求分析<br>C、可行性分析 D、逻辑结构设计<br>正确答案：B</p><p>15、关于BC范式下列说法正确的是_________。<br>A、如果R∈3NF ，则R一定是BCNF<br>B、若R∈3NF，且不存在主属性对非码的函数依赖，则其是BCNF<br>C、如果R∈BCNF，则R∈3NF<br>D、以上说法都不对<br>正确答案：C</p><p>答案是一范式。</p><p>上面的第五题原因是关系模式的属性一定是不可分的，刚好满足了第一范式的定义。</p><p>设计一个数据库需要六个流程：需求分析，概念设计，逻辑设计，物理设计，数据库实施，运行数据库和维护数据库。</p> <h2 id="第十二章-物理存储系统"><a href="#第十二章-物理存储系统" class="headerlink" title="第十二章 物理存储系统"></a>第十二章 物理存储系统</h2><h3 id="物理存储介质"><a href="#物理存储介质" class="headerlink" title="物理存储介质"></a>物理存储介质</h3><p>分为三层，头两层是主存储器，然后是辅助存储器，最后是三级存储器。</p><p>主存储器都是<strong>易失去</strong>的，其余的都是<strong>不易失去</strong>。</p><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><ul><li>易失。</li><li>读写速度很块。</li><li>随机访问。</li></ul><h4 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘 SSD"></a>固态硬盘 SSD</h4><ul><li>不易失。</li><li>用闪存实现。</li><li>随机访问。</li></ul><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><ul><li>不易失。</li><li>随机访问。</li></ul><h4 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h4><ul><li>随机访问。</li><li><strong>顺序访问</strong>。</li></ul><p>以上四种存储器从上到下容量增大，访问时间越长。</p><h3 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h3><p>分为多个磁盘面，每个磁盘面有多个磁道，每个磁道有多个扇区。</p><h4 id="存取时间模型"><a href="#存取时间模型" class="headerlink" title="存取时间模型"></a>存取时间模型</h4><ol><li><p><strong>寻道时间</strong></p><p>寻道时间是指磁头从当前磁道移动到目标磁道所需的时间。</p></li><li><p><strong>旋转延迟</strong></p><p>旋转延迟是指盘片旋转到磁头所在扇区的时间，即磁头等待数据扇区旋转到其下方的时间。</p></li><li><p><strong>数据传输时间</strong></p><p>数据传输时间是指从磁头读取数据到数据传输到系统的时间，或者将数据从系统传输到磁头的时间。</p></li></ol><p><strong>访问时间</strong>是发出请求到数据开始传输之间的时间，即<strong>寻道时间</strong>加<strong>旋转延迟</strong>。</p><h2 id="第十三章-数据存储结构"><a href="#第十三章-数据存储结构" class="headerlink" title="第十三章 数据存储结构"></a>第十三章 数据存储结构</h2><h3 id="文件组织（记录格式）"><a href="#文件组织（记录格式）" class="headerlink" title="文件组织（记录格式）"></a>文件组织（记录格式）</h3><h4 id="定长记录"><a href="#定长记录" class="headerlink" title="定长记录"></a>定长记录</h4><p>定长记录是指每条记录的长度（即所占用的存储空间）相同的记录组织方式。在这种组织方式下，所有字段的字节数预先确定，且每条记录严格按照固定长度存储。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Fixed<br>(<br>col1 <span class="hljs-type">int</span>              <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>col2 <span class="hljs-type">char</span>(<span class="hljs-number">5</span>)          <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>col3 <span class="hljs-type">char</span>(<span class="hljs-number">3</span>)          <span class="hljs-keyword">NULL</span>,<br>col4 <span class="hljs-type">float</span>            <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)<br></code></pre></td></tr></table></figure><h4 id="不定长记录"><a href="#不定长记录" class="headerlink" title="不定长记录"></a>不定长记录</h4><p>不定长记录是指每条记录的长度可以变化的记录组织方式。在这种组织方式下，记录中的字段长度不固定，可以根据实际数据的需求动态调整。</p> <h3 id="文件中记录的组织"><a href="#文件中记录的组织" class="headerlink" title="文件中记录的组织"></a>文件中记录的组织</h3><ul><li><p><strong>堆文件组织</strong></p><p>堆文件组织是指记录在文件中无特定顺序地存储，每条记录可以存放在文件的任何位置。通常，一个关系对应一个单独的文件，记录插入时只需在文件末尾添加新记录。</p></li><li><p><strong>顺序文件组织</strong></p><p>记录根据搜索码的值顺序存储，搜索码是任意属性或属性的集合（不必是超码） 。</p></li><li><p><strong>散列文件组织</strong></p><p>散列文件组织是通过对记录的某些属性应用散列函数，来确定记录存储的位置（即存储块）。散列函数将搜索码映射到文件的某个存储块中，实现<strong>快速的随机访问</strong>。</p></li><li><p><strong>多表聚簇文件组织</strong></p><p>多表聚簇文件组织是指在同一个存储块中存储两个或多个关系中相关的记录。这种组织方式可以高效地处理连接操作，因为相关记录被存储在一起，减少了磁盘I&#x2F;O操作。</p><p><strong>join 操作的时候会很方便，但是如果平时的简单查询则需要访问更多的块。</strong></p></li></ul><h3 id="缓冲区管理（LRU-MRU）"><a href="#缓冲区管理（LRU-MRU）" class="headerlink" title="缓冲区管理（LRU MRU）"></a>缓冲区管理（LRU MRU）</h3><p>缓冲区是主存用于存储磁盘块拷贝的那部分。</p><p>当数据库中的程序需要磁盘中的块，首先先看缓冲区，如果没有的话就将要访问的块调入缓冲区内，使用（MRU或者LRU）算法决定调出的块。</p><ol><li><p><strong>最近最少使用（LRU）</strong></p><p>最近最少使用（LRU）策略选择在最近一段时间内最少被访问的数据块进行替换。即，最久未被使用的数据块优先被淘汰。</p><ul><li><strong>符合时间局部性原理</strong>：大多数应用程序具有时间局部性，即最近访问的数据块可能在不久的将来再次被访问。LRU策略能够有效利用这一特性，保留频繁访问的数据块。</li><li><strong>适用于事务处理系统中频繁访问相同数据块。</strong></li></ul></li><li><p><strong>最近最常使用（MRU）</strong></p><p>最近最常使用（MRU）策略选择在最近一段时间内最频繁被访问的数据块进行替换。即，最近被频繁访问的数据块优先被淘汰。</p><ul><li><strong>适用于批量处理或一次性访问大量数据后不再访问。</strong></li></ul></li></ol><h2 id="第十四章-索引"><a href="#第十四章-索引" class="headerlink" title="第十四章 索引"></a>第十四章 索引</h2><p>用于在文件中查找记录的属性为<strong>搜索码</strong>。</p><blockquote><p><strong>不一定是主码！！！</strong></p></blockquote><p>索引分为<strong>顺序索引</strong>和<strong>散列索引</strong>。</p><h3 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h3><p>顺序索引是一种索引方式，其中索引项按照搜索码的顺序排列。</p><p>每个索引记录包含搜索码值及其对应的数据记录的存储地址。</p><ul><li><p><strong>聚集索引（主索引）</strong></p><p>搜索码在顺序索引的基础上，还定义了文件存储的次序。<strong>可以是稠密或者稀疏的</strong>。</p></li><li><p><strong>非聚集索引（辅助索引）</strong></p><p>搜索码指定的次序和文件存储的次序不同。<strong>一定要是稠密的！</strong></p></li></ul><p>常常使用的顺序索引有<strong>稠密索引</strong>和<strong>稀疏索引</strong>两类。</p><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p>在稠密索引中，对于文件的<strong>每个搜索码值都有一个索引项</strong>。</p><ul><li><p><strong>稠密聚集索引</strong></p><p>索引记录包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。</p></li><li><p><strong>稠密非聚集索引</strong></p><p>索引记录必须指向具有相同搜索码值的所有记录的指针列表。</p></li></ul><h4 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h4><p>在稀疏索引中，<strong>只为某些搜索码值建立索引</strong>。</p><p><strong>一定要搭配聚集索引使用！！</strong>否则根本找不到对应的数据记录。</p><h4 id="稠密索引和稀疏索引比较"><a href="#稠密索引和稀疏索引比较" class="headerlink" title="稠密索引和稀疏索引比较"></a>稠密索引和稀疏索引比较</h4><p>稠密索引访问速度更快，但是稀疏索引占据内存更小。</p><h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>发现我书本上关于这部分内容是完全没写笔记的，应该不重要。</p> <h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p><strong>聚集索引 可以是 稠密或者稀疏的。</strong></p><p><strong>非聚集索引一定是稠密的。</strong></p><p><strong>所以稀疏索引一定是 聚集的。</strong></p><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><p>本质上是多级索引。</p><ul><li><p><strong>根节点</strong></p><p><strong>指针数量</strong>：根节点至少有<strong>两个指针</strong>（除非树中只有一个节点，即根节点本身也是叶节点）。</p></li><li><p><strong>内部节点</strong></p><p><strong>关键字存储</strong>：仅存储用于引导搜索的关键字，不存储实际的数据记录。</p><p><strong>指针数量</strong>：每个内部节点至少有⌈n&#x2F;2⌉个子节点指针（其中n为B+树的阶数），最多有n个子节点指针。</p><p><strong>稀疏索引</strong>：内部节点的关键字是稀疏的，仅涵盖了叶节点关键字的子集，减少了索引的大小。</p></li><li><p><strong>叶节点</strong></p><p><strong>关键字和数据指针</strong>：每个叶节点存储键值及其对应的数据记录指针。</p><p><strong>链表连接</strong>：所有叶节点通过链表按关键字顺序相连，支持顺序遍历。</p><p><strong>指针数量</strong>：每个叶节点至少有⌈m&#x2F;2⌉ - 1个关键字，最多有m - 1个关键字（其中m为B+树的阶数）。</p></li></ul><blockquote><p>关键字就是搜索码值!!</p></blockquote><p>特点如下：</p><ol><li><strong>所有实际数据记录存储在叶节点</strong></li><li><strong>内部节点仅存储关键字，用于导航</strong></li><li><strong>叶节点通过链表相连，支持高效的范围查询</strong></li><li><strong>高度平衡，所有叶节点在同一层</strong></li></ol><h4 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B+树插入"></a>B+树插入</h4><ul><li><p>叶子节点拆分</p><p>拆分完后将右边最小的那个搜索码值加入到父节点中。</p></li><li><p>内部节点拆分</p><p>将拆出来右边最小的搜索码值从该层去掉并加入到父节点中。</p></li></ul><h4 id="B-树删除"><a href="#B-树删除" class="headerlink" title="B+树删除"></a>B+树删除</h4><p>分成两种情况讨论：</p><h5 id="问兄弟节点能不能借一个搜索码值："><a href="#问兄弟节点能不能借一个搜索码值：" class="headerlink" title="问兄弟节点能不能借一个搜索码值："></a>问兄弟节点能不能借一个搜索码值：</h5><ul><li><p><strong>叶子节点</strong></p><p>将从兄弟那借到的搜索码值 A 写到父节点上。</p>   </li><li><p><strong>内部节点</strong></p><p>将从兄弟那借来的搜索码值 A 放到父节点，将原本的父节点值 B 加入到叶子节点中。</p></li></ul><h5 id="借不到搜索码值，需要合并"><a href="#借不到搜索码值，需要合并" class="headerlink" title="借不到搜索码值，需要合并"></a>借不到搜索码值，需要合并</h5><ul><li><p><strong>叶子节点合并</strong></p><p>合并后删除原父节点，并重新分配父节点。</p> </li><li><p><strong>内部节点合并</strong></p><p>这种情况通常是内部节点已经为空了。</p><p>需要将父节点的搜索码值拉下来。</p></li></ul><h4 id="B-树高度"><a href="#B-树高度" class="headerlink" title="B+树高度"></a>B+树高度</h4><p>B+树的高度即它的最坏情况下查询复杂度，最坏情况下，每个内层的指针数为$$⌈\frac{n}{2}⌉$$。<br>$$<br>h &#x3D; \log_{⌈\frac{n}{2}⌉}(k)<br>$$</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引通过将关键字通过哈希函数映射到特定的位置，从而实现快速的数据定位和访问。</p><p><strong>与B+树索引不同，哈希索引主要优化等值查询（如<code>=</code>操作），而不支持范围查询（如<code>BETWEEN</code>或<code>&lt;</code>, <code>&gt;</code>等操作）</strong></p><p>感觉不会考。</p><h2 id="第十五章-查询处理"><a href="#第十五章-查询处理" class="headerlink" title="第十五章 查询处理"></a>第十五章 查询处理</h2><p>因为老师这部分讲的太烂了，我实在找不到重点。</p><p>查询处理：指从数据库中提取数据所做的一系列活动。这些活动包括：<strong>将 SQL 语句编译成在文件系统的物理层上使用的表达式</strong>、<strong>查询优化</strong>、<strong>查询执行</strong>。</p> <p>要全面说明如何执行一个查询，不仅要提供关系代数表达式，还要对表达式加上注释来说明如何执行每个操作。注释可以声明某个具体操作所采用的算法，或将要使用的一个或多个特定的索引。</p><p><strong>执行原语</strong>是数据库管理系统（DBMS）中最基本的操作单元，用于实现关系代数中的各类操作。</p><p>用于执行一个查询的原语操作序列称为<strong>查询执行计划</strong>。</p><p><strong>常见的查询执行计划有下面所讲的四种连接运算。</strong></p> <p><strong>查询执行引擎</strong>接受一个查询执行计划，执行该计划并把结果返回给查询。</p><p>构造最小查询代价的查询执行计划是系统的责任，这项工作叫<strong>查询优化</strong>。</p><p>优化器通常努力去尽可能<strong>降低查询计划总的资源消耗</strong>，而不是<strong>尽可能缩低响应时间</strong>。</p><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><p>定义$$t_s$$为磁盘访问时间（寻道加旋转延迟），$$t_T$$为块传输时间。</p><h4 id="线性搜索"><a href="#线性搜索" class="headerlink" title="线性搜索"></a>线性搜索</h4><ul><li><p><strong>A1</strong></p><p>假设文件的块是<strong>顺序</strong>存储。即我们只需要在磁盘中访问第一个文件块，然后一直顺着一直读下去即可。</p></li><li><p><strong>A1</strong></p><p>因为等值成立就可以返回了，平均需要扫描一半的文件块。</p></li></ul><h4 id="B-树聚集索引"><a href="#B-树聚集索引" class="headerlink" title="B+树聚集索引"></a>B+树聚集索引</h4><ul><li><p><strong>A2</strong></p><p>假设树高为$$h_i$$，那么需要从上到下访问$$h_i$$个块（读索引时间），然后获得最终的记录的地址，再去访问。</p></li><li><p><strong>A3</strong></p><p>因为搜索码不是主码，所以最终的索引会有多条记录，但是因为是聚集索引，所以它们是连续存储的。</p></li></ul><h4 id="B-树辅助索引"><a href="#B-树辅助索引" class="headerlink" title="B+树辅助索引"></a>B+树辅助索引</h4><ul><li><p><strong>A4</strong></p><p>搜索码为主码的等值比较跟 A2 一样。</p></li><li><p><strong>A4</strong></p><p>因为搜索码不是码，所以最终的索引会有多条记录，并且因为是辅助索引，所以这些记录不是连续存储的。</p></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>对不能全部放入内存中的关系进行的排序称为<strong>外排序</strong>。</p><p>其实只介绍了<strong>归并算法</strong>。</p><p>基本流程：假设内存最多可存 M 个块</p><ul><li>第一步初始化（创建归并段），每次读入 M 个块进行排序（下图第二列）</li><li>第二步分一个内存块给每一个段（最多分 M - 1个），剩下一个作为比较输出。</li><li>不断重复第二步，直到归并段数小于 M（此时可以一次性排序）</li></ul><p>每执行一趟归并，归并段就会减少为原来的$$\frac{1}{M-1}$$。</p><h4 id="嵌套循环连接"><a href="#嵌套循环连接" class="headerlink" title="嵌套循环连接"></a>嵌套循环连接</h4><p>最坏情况下：(R 外 S 内)</p><ul><li><p>块传输：$$n_r*b_s + b_r$$</p><p>因为一旦确定一个关系 r 的元组，就需要传输$$b_s$$次块进行一次循环，然后外循环本来也需要传输”自己”进内存$$b_r$$块。</p></li><li><p>寻道次数：$$n_r+b_r$$</p><p>因为一旦确定关系 r 的元组，就需要寻道一次（for 内循环 s），一共需要寻道 $$n_r$$次。外循环需要寻道$$b_r$$次。</p></li></ul><p>最好情况下：即两个关系可以同时读入内存</p><ul><li>只需要一次读全部的关系进内存，需要两次寻道（分别找关系 r 和关系 s 的第一个块），要传输$$b_r+b_s$$次块。</li></ul><h4 id="块嵌套循环连接"><a href="#块嵌套循环连接" class="headerlink" title="块嵌套循环连接"></a>块嵌套循环连接</h4><p>分析跟上面一样，只不过外层循环以块做单位进行循环，而不是元组。</p><p>最坏情况下：(R 外 S 内)</p><ul><li><p>块传输次数：$$b_r*b_s + b_r$$</p><p>因为一旦确定一个关系 r 的块，就需要传输$$b_s$$次块进行一次循环，然后外循环本来也需要传输”自己”进内存$$b_r$$块。</p></li><li><p>寻道次数：$$b_r+b_r$$</p><p>因为一旦确定关系 r 的块，就需要寻道一次（for 内循环 s），一共需要寻道 $$n_r$$次。外循环需要寻道$$b_r$$次。</p></li></ul><p>最好情况分析跟上面类似。</p><h4 id="归并连接"><a href="#归并连接" class="headerlink" title="归并连接"></a>归并连接</h4><p>简单来说，就是和两个已经排好序的关系进行归并。</p><ul><li><p>块传输次数：$$b_r+b_s$$</p><p>只需要将两个关系的块放进内存一次即可。</p></li><li><p>寻道次数：$$\frac{b_r}{b_b} + \frac{b_s}{b_b}$$</p><p>如果分配给每个关系的缓冲块是$$b_b$$，则每次只需要$$\frac{b_r}{b_b}$$次就可以将整个关系 r 读入内存。</p></li></ul><h4 id="散列连接"><a href="#散列连接" class="headerlink" title="散列连接"></a>散列连接</h4><p>基本思想：假设一个 r 元组和一个 s 元组满足连接条件，那么它们对于连接属性就会取相同的值。若该值被散列成某个值 i ，则 r 元组必在 ri 中且 s元组必在 si 中。因此，只需要 ri 中的元组和 si 中的元组进行比较即可。   </p><ul><li><p>块传输次数：$$3(b_r+b_s)$$</p><p>先将两个关系读入内存，需要一个$$(b_r+b_s)$$；分区完之后写回磁盘，需要一个$$(b_r+b_s)$$；然后每一个拿出来比较，需要一个$$(b_r+b_s)$$。</p></li><li><p>寻道次数为：$$2(\frac{b_r}{b_b}+\frac{b_s}{b_b})+2*n_h$$</p><p>如果分配给每个关系的缓冲块是$$b_b$$，一共有$$n_h$$个分区。</p><p>将两个关系完整的读入内存并写回需要$$2(\frac{b_r}{b_b}+\frac{b_s}{b_b})$$次寻道机会。每一个分区元组拿出来比较的时候，默认每个关系在每个分区都只需要一次寻道。</p></li></ul><h2 id="第十六章-查询优化"><a href="#第十六章-查询优化" class="headerlink" title="第十六章 查询优化"></a>第十六章 查询优化</h2><p>目标是尽早执行选择和投影运算。</p><h3 id="关系表达式的转换"><a href="#关系表达式的转换" class="headerlink" title="关系表达式的转换"></a>关系表达式的转换</h3><p>如果两个关系代数表达式在每个合法的数据库实例上都会产生相同的元组集，则这两个表达式是<strong>等价</strong>的。</p><blockquote><p>一个合法的数据库实例是满足数据库模式中设定的完整性约束的数据库实例。</p></blockquote><h4 id="等价规则"><a href="#等价规则" class="headerlink" title="等价规则"></a>等价规则</h4><p>这里我就强调几个感觉挺重点的（个人感觉）：</p><ul><li><p><strong>连接运算满足交换律</strong></p><p>连接运算（Join Operation）满足<strong>交换律</strong>，即两个关系的连接顺序可以互换，结果不变。<br>$$<br>R \bowtie S &#x3D; S \bowtie R<br>$$</p></li><li><p><strong>自然连接满足结合律</strong></p><p>自然连接（Natural Join）满足<strong>结合律</strong>，即多个自然连接的组合顺序不会影响最终结果。<br>$$<br>(R \bowtie S) \bowtie T &#x3D; R \bowtie (S \bowtie T)<br>$$</p></li><li><p><strong>选择条件只涉及左侧关系的属性</strong><br>$$<br>\sigma_{\theta}(R \bowtie S) &#x3D; \sigma_{\theta}(R) \bowtie S<br>$$<br><strong>前提</strong>：选择条件 $$\theta$$ 只涉及关系 R 的属性。</p></li><li><p><strong>选择条件 $$\theta_1$$ 只涉及左侧关系的属性 和 选择条件 $$\theta_2$$ 只涉及右侧关系的属性</strong><br>$$<br>\sigma_{\theta_1 \cap \theta_2}(R \bowtie S) &#x3D; \sigma_{\theta_1}(R) \bowtie \sigma_{\theta_2}(S)<br>$$</p></li><li><p><strong>令$$L1$$和$$L2$$分别代表$$E1$$和$$E2$$的属性，假设连接条件$$\theta$$只涉及$$L1 \cup L2$$的属性</strong><br>$$<br>\pi_{L1 \cup L2}\left(E_1\bowtie_{\theta} E_2\right) &#x3D; \pi_{L_1}(E_1) \bowtie_{\theta} \pi_{L2}(E_2)<br>$$</p></li></ul><p>感觉等价优化就是看能不能在<strong>连接前把选择和投影执行了</strong>。</p><h3 id="规模估计"><a href="#规模估计" class="headerlink" title="规模估计"></a>规模估计</h3><p>数据库目录存储了数据库的统计信息。</p><p>$$V(A,r)$$代表关系 r 中属性 A 的可取值数量。即域的大小。</p><p>假设 A 是性别，则$$V(A,r)$$是 2 ，因为只有男女。</p><h4 id="选择规模估计"><a href="#选择规模估计" class="headerlink" title="选择规模估计"></a>选择规模估计</h4><ul><li><p>$$σ_{A&#x3D;a}(r)$$：</p><p>估计为$$n_r*\frac{1}{V(A,r)}$$。</p><p>就是总元组数量 乘以 属性 A 等于 a 的概率。</p></li><li><p>$$σ_{A&lt;a}(r)$$：</p><p>估计为$$n_r * \frac{v-min(A,r)}{max(A,r)-min(A,r)}$$</p></li></ul><h4 id="合取估计"><a href="#合取估计" class="headerlink" title="合取估计"></a>合取估计</h4><p>$$\sigma_{\theta_{1} \wedge \theta_{2} \cdots \wedge \theta_{n}}(r)$$</p><p>假设一个条件满足的概率（中选率）数记为$$s_i&#x2F;n_r$$，那么估计的元组数量为$$n_{r} \cdot \frac{s_{1} \cdot s_{2} \cdot \ldots \cdot s_{n}}{n_{r}^{n}}$$</p><h4 id="析取估计"><a href="#析取估计" class="headerlink" title="析取估计"></a>析取估计</h4><p>$$\sigma_{\theta_{1} \vee \theta_{2} \vee \cdots \vee \theta_{n}}(r)$$</p><p>概率估计为$$1 - \left(1 - \frac{s_{1}}{n_{r}}\right) \cdot \left(1 - \frac{s_{2}}{n_{r}}\right) \cdot \cdots \cdot \left(1 - \frac{s_{n}}{n_{r}}\right)$$</p><h4 id="连接估计"><a href="#连接估计" class="headerlink" title="连接估计"></a>连接估计</h4><ol><li><p><strong>R 和 S 没有交集</strong></p><p>当 R 和 S 没有交集时，表示没有共同的属性用于连接操作。在这种情况下，连接条件不涉及任何公共属性，因此连接操作将形成笛卡尔积（Cartesian Product），每个 R 中的元组都会与每个SS 中的元组连接。</p><p>例如，假设 R 有 1000 个元组，S 有 500 个元组，则连接结果有 500,000 个元组。</p></li><li><p><strong>R 和 S 的交集是主码</strong></p><p>若交集是 R 的码，那么 S 中的每个元组最多只能跟一个 R 中的元组相连，所以连接后数量不会超过 S 中元组数量（因为可能 S 中的属性值在 R 中没有）；反之也一样。</p><p>若交集是 S 中引用 R 的外码，则连接后数量与关系 S 元组数量一样。</p></li><li><p><strong>R 和 S 的交集不是主码</strong></p><p>假设交集的属性为 A ，考虑 R 中的元组 r，估计单个元组 r 能在连接中产生$$\frac{n_s}{V(A,s)}$$个元组。</p><p>一共有 $$n_r$$个元组，所以一共能产生$$\frac{n_s*n_r}{V(A,s)}$$个元组。</p><p>或者产生$$\frac{n_s*n_r}{V(A,r)}$$个元组。</p><blockquote><p>简单来想，就是数量相乘然后除以V(A,r)或者V(A,s)，取小的那个值。</p></blockquote></li></ol><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul><li><p>左、右外连接</p><p>就是自然连接的估计再加上左或者右的关系规模。</p></li><li><p>全外连接</p><p>自然连接的估计加上左和右的关系规模。</p></li></ul><h2 id="第十七章-事务"><a href="#第十七章-事务" class="headerlink" title="第十七章 事务"></a>第十七章 事务</h2><h3 id="事务的四个性质"><a href="#事务的四个性质" class="headerlink" title="事务的四个性质"></a>事务的四个性质</h3><p><strong>ACID 属性</strong>是数据库事务管理的核心原则，确保事务执行的可靠性和数据库的完整性：</p><ul><li><strong>原子性</strong>：事务的操作要么全部完成，要么全部不做。</li><li><strong>一致性</strong>：事务执行前后，数据库始终处于一致状态。</li><li><strong>隔离性</strong>：并发事务之间相互隔离，互不干扰。</li><li><strong>持久性</strong>：事务一旦提交，其结果永久保存在数据库中。</li></ul><h3 id="抽象事务模型"><a href="#抽象事务模型" class="headerlink" title="抽象事务模型"></a>抽象事务模型</h3><p>如果一个事务是<strong>已提交（commit）</strong>或者<strong>中止（rollback回滚之后）</strong>，才能称这个事务是<strong>终止</strong>的。</p><p>当事务执行完最后⼀条语句，会进入部分提交状态。此时实际输出可能仍驻留在主存中，硬件故障可能会导致中止。</p><h3 id="事务的并发调度"><a href="#事务的并发调度" class="headerlink" title="事务的并发调度"></a>事务的并发调度</h3><p>并发的好处：</p><ul><li>提高吞吐量和资源利用率</li><li>减少等待时间</li></ul><p><strong>当多个事务并发执行时，隔离性可能被违背，这导致即使每个单独的事务都是正确的，但数据库的一致性还是会被破坏。</strong></p><p><strong>调度：</strong>描述的执行顺序，定义了指令在系统中的执行的时间顺序。必须包含所有事务的全部指令，并且这些指令必须保持它们原本事务的顺序。</p><p>串行调度和并发调度这里就不写了…</p><p><strong>结论：并非所有的并发执行都能得到正确的状态（即保证了数据库的一致性）。</strong></p><h4 id="并发的一些问题"><a href="#并发的一些问题" class="headerlink" title="并发的一些问题"></a>并发的一些问题</h4><ol><li><strong>脏读</strong>： 一个事务读取了另一个事务尚未提交的数据。如果第二个事务回滚，第一事务读取到的数据就会无效。这会导致数据不一致。</li><li><strong>不可重复读</strong>： 在同一事务中，两次读取同一数据得到的结果不同，原因是另一事务在期间修改了数据。</li><li><strong>幻读</strong>：是指在一个事务内，多次查询同一范围的数据时，得到的结果集不一致。这种现象通常发生在并发事务中，当一个事务在读取数据时，另一个事务插入了新的数据行，导致第一个事务在后续读取时发现了新的行。</li></ol><p>我们想要并发调度在某种意义上等价于一个串行调度，这个调度就是<strong>可串行化调度</strong>。</p><h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><p>主要考虑的是<strong>冲突可串行化</strong>调度。</p><p><strong>冲突可串行化</strong>指的是一个并发事务调度可以通过交换不冲突的操作顺序，转化为某个<strong>串行调度</strong>，且两个调度的执行结果完全相同。</p><p><strong>冲突的操作顺序</strong>：</p><ul><li><strong>读-写冲突</strong>：事务 $$T_1$$读取 X，事务 $$T_2$$ 写入 X。</li><li><strong>写-读冲突</strong>：事务 $$T_1$$ 写入 X，事务 $$T_2$$ 读取 X。</li><li><strong>写-写冲突</strong>：事务 $$T_1$$ 写入 X，事务 $$T_2$$ 写入 X。</li></ul><p>如果调度 S 经过一系列非冲突指令的交换转换成调度 S’，则称 S 和 S‘ 是<strong>冲突等价</strong>的。</p><p>如果调度 S 经过一系列非冲突指令的交换转换成串行调度，则称 S 和 S‘ 是<strong>冲突可串行化</strong>的。</p><h4 id="优先图"><a href="#优先图" class="headerlink" title="优先图"></a>优先图</h4><p>结论：如果优先图中无环，则该调度是可冲突串行化的。</p><p>边：考虑上面的三种冲突的操作顺序，若满足这三个条件其中之一：</p><ul><li><strong>读-写冲突</strong>：事务 $$T_1$$读取 X 之前，事务 $$T_2$$ 写入 X。</li><li><strong>写-读冲突</strong>：事务 $$T_1$$ 写入 X 之前，事务 $$T_2$$ 读取 X。</li><li><strong>写-写冲突</strong>：事务 $$T_1$$ 写入 X 之前，事务 $$T_2$$ 写入 X。</li></ul><p>则插入由$$T_2$$为起点，$$T_1$$为终点的有向边进入优先图。代表$$T_2$$执行完后，$$T_1$$才能执行。</p> <p><strong>要记得起点是先执行的！！</strong></p><h3 id="事务的可恢复性"><a href="#事务的可恢复性" class="headerlink" title="事务的可恢复性"></a>事务的可恢复性</h3><p><strong>可恢复调度</strong>是指一种事务调度方式，其中如果一个事务 $$T_i$$ 依赖于另一个事务 $$T_j$$的修改（即 $$T_i$$读取了 $$T_j$$修改的数据），那么 $$T_j$$ 必须在 $$T_i$$提交之前先提交。</p><p>这确保了如果 $$T_j$$ 发生故障并回滚，依赖于它的事务 $$T_i$$ 也可以安全地回滚，避免数据不一致。</p><p><strong>无级联调度</strong>是一种更加严格的可恢复调度。在无级联调度中，一个事务只读取已经提交事务的数据。这意味着，如果一个事务 $$T_i$$  读取了事务 $$T_j$$ 的数据，那么 $$T_j$$必须在 $$T_i$$ 读取数据之前已经提交。这样，即使$$T_j$$失败，$$T_i$$ 也不会受到影响，因为 $$T_i$$  只依赖于已提交的数据。</p><h3 id="事务的隔离性级别"><a href="#事务的隔离性级别" class="headerlink" title="事务的隔离性级别"></a>事务的隔离性级别</h3><ul><li>可串行化</li><li>可重复读</li><li>已提交读</li><li>未提交读</li></ul><h3 id="其他-6"><a href="#其他-6" class="headerlink" title="其他"></a>其他</h3><p>一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的何种特性而引起的<br>A、隔离性 B、 一致性 C、原子性 D、 持久性<br>正确答案：A</p><p>在数据库恢复时，对尚未做完的事务执行（ ）。<br>A. REDO处理<br>B. UNDO处理<br>C. ABORT处理<br>D. ROLLBACK处理<br>正确答案： B</p><p>若事务中有表达式a&#x2F;b，如果b&#x3D;0时会产生的故障属于（ ）。<br>A. 事务故障<br>B. 系统故障<br>C. 介质故障<br>D. 死机<br>正确答案： A</p><p>若系统在运行过程中，由于某种硬件故障，使存储在外存上的数据部分损失或全部损失，这种情况称为（ ）。<br>A. 事务故障<br>B. 系统故障<br>C. 介质故障<br>D. 运行故障<br>正确答案： C</p><p>数据库恢复的基本原理是利用冗余数据。<br>A. 正确<br>B. 错误<br>正确答案： A</p><h2 id="第十八章-并发控制"><a href="#第十八章-并发控制" class="headerlink" title="第十八章 并发控制"></a>第十八章 并发控制</h2><p>悲观的并发控制就是一检测到出事就立马回滚。</p><blockquote><p>跟我的人生一样…</p></blockquote><h3 id="封锁协议（悲观）"><a href="#封锁协议（悲观）" class="headerlink" title="封锁协议（悲观）"></a>封锁协议（悲观）</h3><p>锁有两种：</p><ul><li><strong>共享锁（S）</strong>：是读取数据用的。</li><li><strong>排他锁（X）</strong>：是写数据用的。</li></ul><p>只有共享锁和共享锁之间是相容的，其他情况都不相容。</p><p>数据项上可同时被多个事务持有共享锁（S），此时的排他锁必须一直等到这些事务都释放共享锁才能获得。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>若假设事务$$T_i$$在等待事务$$T_j$$释放关于数据 X 的锁，与此同时，事务$$T_j$$在等待事务$$T_i$$释放关于数据 Y 的锁，<strong>两个事务之间互相等待，就发生了死锁。</strong></p><p>一旦死锁发生时，就必须在这两个事务中选择一个牺牲者进行回滚。一旦其中一个事务被回滚，另一个事务就可以获得正在等待的锁了。</p><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>可以利用等待图来检测是否产生死锁（有环）。</p><p>若假设事务$$T_i$$在等待事务$$T_j$$释放关于数据 X 的锁，那么在等待图内就有起点在$$T_i$$终点在$$T_j$$的有向边。</p><blockquote><p>注意：等待图和前面讲的优先图的方向其实是反的… 优先图是等待的事务在有向边终点，而等待图是等待的事务在起点。</p></blockquote><h4 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h4><p>选择牺牲者，回滚牺牲者的事务…</p><p>因为选择牺牲者可能基于某个指标，所以可能存在某个事务一直被牺牲，可能会产生饥饿现象。</p><p>死锁不太像会考…</p><h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>事务分成<strong>增长阶段（获得锁）</strong>和<strong>缩减阶段（释放锁）</strong>。</p><p>事务最后一次获得锁的位置称为<strong>封锁点</strong>。</p><p>即事务不可以<code>lock -- unlock -- lock --unlock</code>，只可以<code>lock -- lock -- unlock --unlock</code>。</p><p>两阶段封锁协议保证了冲突可串行化，因为假设冲突不可串行化，则优先图存在环，证明如下图：</p><p>但是两阶段封锁协议<strong>不保证死锁</strong>，例如在两个事务的增长阶段就可以发生死锁了…</p><p>并且也<strong>不保证无级联调度</strong>，因为两阶段协议没有对于提交有限制。</p><blockquote><p>无级联调度其实就是已提交读。就是只能读取提交之后的数据（写到磁盘内），否则该数据若回滚则读取该数据的事务也需要回滚。</p></blockquote><h4 id="严格两阶段封锁协议"><a href="#严格两阶段封锁协议" class="headerlink" title="严格两阶段封锁协议"></a>严格两阶段封锁协议</h4><p>为了保证无级联调度，严格两阶段封锁协议<strong>要求事务只能在提交之后释放排他锁</strong>。以满足已提交读。</p><h3 id="基于时间戳的协议（悲观）"><a href="#基于时间戳的协议（悲观）" class="headerlink" title="基于时间戳的协议（悲观）"></a>基于时间戳的协议（悲观）</h3><p>这个协议保证了<strong>冲突可串行化</strong>和<strong>无死锁（因为不会发生等待）</strong>。</p><p>但是可能会发生不必要的回滚操作和饿死。</p><p>对于每个事务，根据<strong>系统时钟</strong>或者<strong>逻辑计数器</strong>分配一个时间戳。</p><p>基本思想：</p><ul><li>开始早的事务<strong>不能读</strong>开始晚的事务写的数据。</li><li>开始早的事务<strong>不能写</strong>开始晚的事务已经读过或写过的数据。</li></ul><h4 id="读操作（Read-Operation）"><a href="#读操作（Read-Operation）" class="headerlink" title="读操作（Read Operation）"></a><strong>读操作（Read Operation）</strong></h4><p>当事务 $$T_i$$ 试图读取数据项 X 时：</p><ul><li>检查 X 的最后<strong>写时间戳</strong> W(X)。</li><li>如果 $$W(X) &gt; TS(T_i)$$，表示有一个较晚的事务已经修改了 X，此时 $$T_i$$读取到的数据可能是不一致的，因此 <strong>拒绝</strong> $$T_i$$ 的读操作，并 <strong>回滚</strong> $$T_i$$。</li><li>否则，允许 $$T_i$$ 读取 X，并更新 X 的读时间戳 $$R(X) &#x3D; \max(R(X), TS(T_i))$$。</li></ul><h4 id="写操作（Write-Operation）"><a href="#写操作（Write-Operation）" class="headerlink" title="写操作（Write Operation）"></a><strong>写操作（Write Operation）</strong></h4><p>当事务 $$T_i$$ 试图写入数据项 X 时：</p><ul><li>检查 X 的最后读时间戳 R(X) 和最后写时间戳 W(X)。</li><li>如果 $$R(X) &gt; TS(T_i)$$ 或 $$W(X) &gt; TS(T_i)$$，表示有一个较晚的事务已经读取或修改了 X，此时 <strong>拒绝</strong> $$T_i$$ 的写操作，并 <strong>回滚</strong> $$T_i$$。</li><li>否则，允许 $$T_i$$ 写入 X，并更新 X 的写时间戳 $$W(X) &#x3D; TS(T_i)$$。</li></ul><h4 id="Thomas-写规则"><a href="#Thomas-写规则" class="headerlink" title="Thomas 写规则"></a>Thomas 写规则</h4><p>大部分都跟时间戳排序一样，不过在<strong>写操作</strong>中，如果$$W(X) &gt; TS(T_i)$$，则不选择回滚，而是忽略。</p><h3 id="基于有效性检查的协议（乐观）"><a href="#基于有效性检查的协议（乐观）" class="headerlink" title="基于有效性检查的协议（乐观）"></a>基于有效性检查的协议（乐观）</h3><blockquote><p>tmd ppt就三页，而且我书上没有画任何笔记。</p></blockquote><p><strong>可串行化</strong>和<strong>避免级联回滚</strong>。</p><p><strong>基于有效性检查的协议</strong>假设事务之间很少发生冲突，因此允许事务自由执行，直到提交阶段才进行冲突检测和验证。</p><p>为了判断有效性，需要增加三个时间戳：</p><ol><li>**StartTS(Ti)**：事务Ti开始的时间。</li><li>**ValidationTS(Ti)**：事务Ti进行有效性检查的时间。</li><li>**FinishTS(Ti)**：事务Ti完成其写阶段的时间。</li></ol><p>通常分为三个阶段：</p><ol><li><p><strong>读阶段</strong></p><p>读取各项数据，并且将其保存在局部变量中。这时候执行的 write 操作都是对局部变量进行的。</p></li><li><p><strong>有效性检查阶段</strong></p><p>判断读阶段的 write 操作是否满足有效性，满足的话进入写阶段；不满足则回滚。</p><p>事务 Ti 的有效性检查时对于满足 TS(Tk) &lt; TS(Ti) 的所有事务 Tk 需满足下列条件的其中一个：</p><ol><li><p><strong>FinishTS(Tk) &lt; StartTS(Ti)</strong></p><p>即事务 Tk 在事务 Ti 开始之前已经完成执行了。</p></li><li><p>Tk 所写的数据项集合和 Ti 所读的数据项集合并不相交，并且在 Ti 开始有效性检查之前，Tk 已经完成写阶段了，即**(StartTS(Ti) &lt; FinishTS(Tk) &lt; Validation(Ti))**。</p></li></ol></li><li><p><strong>写阶段</strong></p><p>将局部变量的 write 操作结果拷入到数据库中。</p></li></ol><h3 id="多版本机制"><a href="#多版本机制" class="headerlink" title="多版本机制"></a>多版本机制</h3><p>每个 write (Q) 的操作<strong>就创建一个 Q 的新版本</strong>。</p><p>感觉不太重要。</p><h3 id="其他-7"><a href="#其他-7" class="headerlink" title="其他"></a>其他</h3><h2 id="第十九章-恢复系统"><a href="#第十九章-恢复系统" class="headerlink" title="第十九章 恢复系统"></a>第十九章 恢复系统</h2><h3 id="恢复与原子性"><a href="#恢复与原子性" class="headerlink" title="恢复与原子性"></a>恢复与原子性</h3><p>使用最广泛的数据库修改的结构就是<strong>日志</strong>。</p><p>日志是<strong>日志记录</strong>的序列。</p><p><strong>更新日志记录</strong>具有以下字段：&lt;$$T_i$$, $$X_j$$,$$V_1$$,$$V_2$$&gt;。</p><ul><li>事务标识$$T_i$$</li><li>数据项标识$$X_j$$</li><li>旧值$$V_1$$</li><li>新值$$V_2$$</li></ul><p>以下是其他的日志记录类型：</p><ul><li><strong>&lt;$$T_i$$ start&gt;</strong></li><li><strong>&lt;$$T_i$$ commit&gt;</strong></li><li><strong>&lt;$$T_i$$ abort&gt;</strong></li></ul><p>每次事务执行写操作时，必须在数据库修改前建立该次写操作的日志记录并把它加到日志中。再实际执行写数据库。</p><p>利用日志来恢复数据。</p><p>日志的恢复原理是<strong>利用了冗余</strong>数据。</p><h3 id="使用日志重做和撤销事务"><a href="#使用日志重做和撤销事务" class="headerlink" title="使用日志重做和撤销事务"></a>使用日志重做和撤销事务</h3><h4 id="重做（redo-T-i-）"><a href="#重做（redo-T-i-）" class="headerlink" title="重做（redo($$T_i$$)）"></a>重做（redo($$T_i$$)）</h4><p>这个过程将事务$$T_i$$更新过的数据项的值都设为<strong>新值</strong>。</p><ul><li>如果日志中只有&lt;$$T_i$$​ start&gt;语句并且有&lt;$$T_i$$ commit&gt;或&lt;$$T_i$$ abort&gt;语句，需要<strong>重做</strong>。</li></ul><h4 id="撤销（undo-T-i-）"><a href="#撤销（undo-T-i-）" class="headerlink" title="撤销（undo($$T_i$$)）"></a>撤销（undo($$T_i$$)）</h4><p>该过程将事务$$T_i$$更新过的数据项的值都设为<strong>旧值</strong>。</p><ul><li><p>撤销过程需要写日志记录！这个特殊的日志记录是 read-only 记录。</p><p>类似&lt;$$T_i$$, $$X_j$$, $$V_1$$&gt;，这种日志也叫<strong>补偿日志记录</strong>。</p></li><li><p>完成撤销操作之后需要增加&lt;$$T_i$$, abort&gt;语句，表示 undo 完成了。</p></li><li><p>如果日志中只有&lt;$$T_i$$ start&gt;语句并且没有&lt;$$T_i$$ commit&gt;或&lt;$$T_i$$ abort&gt;语句，需要<strong>撤销</strong>。</p></li></ul><p>每个事务在日志中，一定会以 &lt;$$T_i$$, commit&gt;或者&lt;$$T_i$$, abort&gt;终止。</p><h3 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h3><p>在执行检查点的过程中将所有修改过的缓冲块（存在内存）全部写入磁盘（永久保存）。</p><p>然后在日志中加入&lt; check point &gt;语句。</p><p>提高了<strong>数据恢复</strong>的效率。</p><p>假设事务$$T_i$$在日志中的&lt; check point &gt;语句前已经有&lt;$$T_i$$, commit&gt;或者&lt;$$T_i$$, abort&gt;语句，则数据恢复的时候可以不用对事务$$T_i$$进行 redo 操作。</p><h3 id="恢复算法（感觉本章重点）"><a href="#恢复算法（感觉本章重点）" class="headerlink" title="恢复算法（感觉本章重点）"></a>恢复算法（感觉本章重点）</h3><h4 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h4><p>正常情况下的事务$$T_i$$回滚流程：</p><ol><li>从后往前检查日志，对于发现的&lt;$$T_i$$, $$X_j$$,$$V_1$$,$$V_2$$&gt;语句记录：<ul><li>将值$$V_1$$写入数据项$$X_j$$。</li><li>往日志中写入&lt;$$T_i$$, $$X_j$$, $$V_1$$&gt;这种 read-only 记录（也叫<strong>补偿日志记录</strong>）。</li></ul></li><li>一旦发现&lt;$$T_i$$ start&gt;语句，就停止算法，并且往日志中写入&lt;$$T_i$$, abort&gt;语句。</li></ol><h4 id="系统崩溃后的恢复"><a href="#系统崩溃后的恢复" class="headerlink" title="系统崩溃后的恢复"></a>系统崩溃后的恢复</h4><p>分为<strong>重做阶段</strong>（从上到下）和<strong>撤销阶段</strong>（从下到上）。</p><ol><li><p><strong>重做阶段</strong></p><p>系统通过从最后一个检查点开始从上到下扫描日志来重演所有事务的更新。</p><ul><li>初始化 undo-list ，将检查点时刻未终止的事务加入 undo-list。</li><li>从检查点从上到下扫描日志，遇到形如 &lt;$$T_i$$, $$X_j$$, $$V_1$$&gt;或者&lt;$$T_i$$, $$X_j$$,$$V_1$$,$$V_2$$&gt;的语句就执行重做。</li><li>一旦发现&lt;$$T_i$$ start&gt;语句就将$$T_i$$加入 undo-list。</li><li>遇到&lt;$$T_i$$, commit&gt;或者&lt;$$T_i$$, abort&gt;语句就将该事务从undo-list中去除。</li></ul><p>此时 undo-list 中的事务是发生故障时还没终止的事务。</p></li><li><p><strong>撤销阶段</strong></p><p>系统回滚 undo-list 中的事务。</p><ul><li>一旦发现 undo-list 中的事务的日志记录，就执行撤销操作。</li><li>如果遇到&lt;$$T_i$$ start&gt;语句就将该事务从 undo-list 中去除。</li><li>当 undo-list 为空时即完成恢复。</li></ul></li></ol><p>重做阶段就是从检查点开始重演了所有的日志记录，包括未完成事务的动作和回滚失败事务而执行的动作。</p><p>感谢名单：nn。</p><p><a href="https://blog.csdn.net/Dustinthewine/article/details/129072315">数据库原理及应用期末复习汇总(附某高校期末真题试卷)_数据库原理期末考试题-CSDN博客</a></p><p><a href="https://blog.csdn.net/lgldl/article/details/121621417">数据库恢复技术-数据库习题_数据库恢复技术例题-CSDN博客</a></p><p><a href="https://wenku.baidu.com/view/63fc98629b6648d7c1c74636.html?_wkts_=1735808748910">数据库期末考试复习题库(非常全面) - 百度文库</a></p><p>连接代价</p><p><strong>数据模型</strong>是数据库的核心</p><p>数据模型是<strong>数据结构</strong> <strong>数据操作</strong> <strong>完整性约束</strong></p><p>关系模型的完整性是<strong>实体完整性</strong> <strong>用户自定义完整性</strong> <strong>参照完整性</strong> </p><p>物理数据独立性</p><p><strong>逻辑层的简单实现可能在物理层很复杂，但是逻辑层的用户并不清楚。</strong></p><p>逻辑数据独立性</p><p>锁</p><p>可恢复调度 无级联调度</p><p>锁的调度</p><p>什么是调度</p><p>冲突可串行化解释</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2025/01/24/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/24/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络温习资料"><a href="#计算机网络温习资料" class="headerlink" title="计算机网络温习资料"></a>计算机网络温习资料</h1><p>作者：哈利波特👑</p><p>相信自己，I can do it！</p><p>希望可以帮助到大家，祝大家都考100！</p><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><h3 id="什么是因特网？"><a href="#什么是因特网？" class="headerlink" title="什么是因特网？"></a>什么是因特网？</h3><p><strong>定义：</strong>因特网是一个世界范围的计算机网络，，即一个互联了全世界的数十亿计算设备的网络。</p><p><strong>组成结构：</strong>端系统（主机）、通信链路、分组交换机（路由器、链路层交换机）、因特网服务提供商（ISP）。</p><ul><li><strong>端系统（主机）：</strong>例如个人电脑、智能手机、服务器等，通过通信协议相互连接，形成因特网的终端。根据功能可分成<strong>客户</strong>和<strong>服务器</strong>。</li><li><strong>通信链路：</strong>包括光纤、电缆、无线信号等，用于在端系统之间传输数据。负责在两点之间传输数据，提供基础的物理连接。</li><li><strong>分组交换机：</strong>包括路由器和链路层交换机，用于在网络中转发分组数据，确保数据从源端传递到目的端。负责将传输数据从一个通信链路转发到另一通信链路，实现数据的路由和中转。</li><li><strong>因特网服务提供商：</strong>帮助端系统连接入因特网。</li></ul><blockquote><p>可以发现因特网是网络的网络。</p></blockquote><p><strong>其他概念：</strong></p><ul><li><strong>分组：</strong>发送端将数据分段，并为每个数据段增加新的头部成为数据包。这个操作叫做分组。</li></ul><h3 id="什么是协议-（感觉会考）"><a href="#什么是协议-（感觉会考）" class="headerlink" title="什么是协议?（感觉会考）"></a>什么是协议?（感觉会考）</h3><p><strong>定义：</strong>确定多个通信实体之间交换报文的格式以及顺序和收到报文后执行的操作。</p><p>网络协议的三要素：<strong>语法、语义和同步</strong>。</p><h3 id="什么是网络边缘？"><a href="#什么是网络边缘？" class="headerlink" title="什么是网络边缘？"></a>什么是网络边缘？</h3><p><strong>网络结构</strong> &#x3D; <strong>网络边缘</strong>（应用、主机）+ <strong>网络核心</strong>（路由器）+ 接入网和通信链路</p><ul><li><strong>接入网：</strong>将端系统物理连接至<strong>边缘路由器</strong>的网络。</li><li><strong>边缘路由器：</strong>端系统到其他远程端系统路径上经过的第一个路由器。</li></ul><blockquote><p>计算机网络设计的理念：尽量让复杂的事情在网络边缘处理，使得网络核心越简单越好！</p></blockquote><h3 id="什么是网络核心？"><a href="#什么是网络核心？" class="headerlink" title="什么是网络核心？"></a>什么是网络核心？</h3><p><strong>定义：</strong>由<strong>分组交换机</strong>和<strong>数据链路</strong>组成的网状结构。</p><p><strong>功能：</strong>实现数据交换。</p><ul><li><p><strong>存储转发传输</strong></p><p><strong>定义：</strong>交换机开始向输出链路传输该分组的第一个比特之前，必须先接收到整个分组，即将前面该分组的比特都缓存起来。</p><p><strong>链路的传输时间：</strong>假设一条链路发送$$L $$ bit 的分组，链路的传输速率为$$R$$ bps，则链路传输该分组的时间为$$\frac{L}{R}$$ s。 （是将数据包从路由器传向链路）</p><blockquote><p>记得区分传输时间和传播时间的定义！</p></blockquote><p>通过$$ N$$条速率为$$R$$的链路组成的路径（所以一共有$$N-1$$个路由器），从源到目的地发送一个分组，端对端时延为。<br>$$<br>d_{end-end}&#x3D;N\frac{L}{R}<br>$$</p></li><li><p><strong>排队时延和分组丢失</strong></p><p><strong>排队时延：</strong>由于节点存储有限，如果不能及时转发出去，会导致收到的信息等一段时间才能转发出去。</p><p><strong>分组丢失：</strong>大概率由于缓存满了，导致新接收的包被丢弃。</p></li><li><p><strong>转发表和路由选择协议</strong></p><p>转发表可以看成路牌，告诉分组交换机（路由器）将该分组传向哪个分组交换机。</p><p>路由选择协议看成 GPS，告诉你源端系统到目的端系统的最佳路径。</p></li></ul><h3 id="互联网络结构与ISP"><a href="#互联网络结构与ISP" class="headerlink" title="互联网络结构与ISP"></a>互联网络结构与ISP</h3><p>ISP的中心目标：使所有端系统能够彼此发送分组。</p><ul><li><strong>多层等级结构</strong>：接入（本地）ISP，区域（地区）ISP，第一层（主干）ISP（层级由低到高）。</li><li><strong>对等</strong>：同一层相互连接，降低成本。</li><li><strong>IXP</strong>：提供多个ISP的对等。</li></ul><p>为了更快地转发分组，<strong>IXP</strong> 允许两个网络直接连接并交换分组，而不需要通过第三个网络来转发分组。例如上图中，主机 A 和主机 B 通过2个<strong>地区ISP</strong>连接起来了，就不必经过最上层的的<strong>主干ISP</strong>来转发分组。</p><h3 id="分组交换网络中的延迟与丢失（本章重点）"><a href="#分组交换网络中的延迟与丢失（本章重点）" class="headerlink" title="分组交换网络中的延迟与丢失（本章重点）"></a>分组交换网络中的延迟与丢失（本章重点）</h3><h4 id="总时延定义"><a href="#总时延定义" class="headerlink" title="总时延定义"></a>总时延定义</h4><p>节点总时延 &#x3D; 处理时延 + 排队时延 + 传输时延 + 传播时延</p><ul><li><p><strong>处理时延</strong></p><p>决定将该分组导向何处所需要的时间（即查看路由转发表），基本上不会考虑。</p></li><li><p><strong>排队时延</strong></p><p>分组在链路上等待被传输的时间。</p></li><li><p><strong>传输时延</strong></p><p>假设用$$L$$表示该分组的长度，对于 $$10Mbps$$ 的以太网链路，速率$$R&#x3D;10Mbps$$，传输时延为$$\frac{L}{R}$$。</p><p>简单理解就是，传输时延是路由器将分组推向链路的时间。</p><p>与<strong>分组大小</strong>和<strong>传输速率</strong>有关。</p></li><li><p><strong>传播时延</strong></p><p>从链路的起点到达链路终点的所需时间。假设链路长度为$$d$$，传播速率为$$s$$，传播时延为$$\frac{d}{s}$$。</p><p>与<strong>链路长度</strong>与<strong>链路的物理媒介</strong>（光纤）有关。</p></li></ul><h4 id="流量强度与排队时延的关系"><a href="#流量强度与排队时延的关系" class="headerlink" title="流量强度与排队时延的关系"></a>流量强度与排队时延的关系</h4><p>假设$$\alpha$$为分组到达队列的平均速率（即每秒到达$$\alpha$$个分组），所有分组的长度为$$L bit$$，传输速率为$$R$$。</p><p>定义**流量强度为$$\frac{L\alpha}{R}$$**。($$L\alpha$$为每秒到达队列的比特总数，$$R$$为每秒分组交换机向链路推送的比特总数)</p><blockquote><p>流量强度一定不能大于1，大于1则表示到达队列的比特数量大于交换机处理的比特数量，即永远处理不完分组，排队时延接近无穷！</p></blockquote><p>如果流量强度接近 0，排队时延接近 0；当流量强度接近 1，排队时延迅速增加，甚至接近无穷。</p><p>当到达速率小于传输速率时，队列中的分组数量将会减少。</p><h4 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h4><p>因为排队容量是有限的，如果到达的分组发现排队容量已满，则<strong>路由器会丢弃该分组</strong>。</p><p>所以实际上，当流量强度接近 1 时，<strong>排队时延并不会真正的趋向无穷</strong>，因为会丢包。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>瞬时吞吐量：主机 B 接收到文件的速率。</li><li>平均吞吐量：主机 B 接收所有$$F bit$$用去$$Ts$$，平均吞吐量为$$\frac{F}{T}$$。</li><li><strong>瓶颈链路定义：</strong>一个路径中带宽（传输速率）最小的链路。</li></ul><p>考虑下列情况：</p><p>在一个服务器和一个客户之间具有 $$N $$条链路的网络，这N条链路的传输速率分别是$$R_1, R_2, … , R_N$$。应用短板效应（瓶颈链路）的分析方法，在理想状态下从服务器到客户的文件传输吞吐量是$$min{R_1, R_2, … , R_N}$$。</p><p>再考虑下列情况：</p><img src="/2025/01/24/复习笔记/35a9d5218c094ab830cebaeff974e223.png" alt="img" style="zoom:67%;"><p>在例子中有 10 台服务器和 10 个客户与计算机网络连接。在该核心中有一条所有 10 个下载通过的链路$$R$$，设其传输速率为 $$R$$。假定所有服务器的接入链路具有相同的速率$$R_s$$，所有客户接入链路具有相同的速率$$R_C$$。求该例子的下载吞吐量是多少？<br>**如果$$R$$比$$R_s$$和$$R_C$$要大的太多（而事实上往往如此），那么吞吐量为 $$min {Rs,RC}$$**；而假如$$R$$并不大，假定$$RS&#x3D;2Mbps，RC&#x3D;1Mbps，R&#x3D;5Mbps$$，那么下载的吞吐量则不再是由$$ min {R_S,R_C} $$决定，而是为$$500kbps$$。</p><blockquote><p>吞吐量与带宽的比较：带宽是单位时间内，链路能传输的最大比特数量；吞吐量是单位时间内，链路传输的真实比特数量。</p></blockquote><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换有<strong>分组交换</strong>和<strong>电路交换</strong>两种方式。</p><h3 id="协议层次及其服务类型（感觉也重点）"><a href="#协议层次及其服务类型（感觉也重点）" class="headerlink" title="协议层次及其服务类型（感觉也重点）"></a>协议层次及其服务类型（感觉也重点）</h3><p>协议层次(5层因特网协议栈)</p><table><thead><tr><th align="center">层次</th><th align="center">协议</th><th align="center">封装</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">HTTP、DNS、SMTP等</td><td align="center">报文</td></tr><tr><td align="center">传输层</td><td align="center">TCP、UDP</td><td align="center">报文段</td></tr><tr><td align="center">网络层</td><td align="center">IP</td><td align="center">数据报</td></tr><tr><td align="center">链路层</td><td align="center">Ethernet、802.11</td><td align="center">帧</td></tr><tr><td align="center">物理层</td><td align="center">~</td><td align="center">~</td></tr></tbody></table><ul><li><p><strong>链路层交换机：</strong> 实现了链路层协议（第二层协议），在局域网中通过 MAC 地址进行数据转发，因此不需要解析网络层的 IP 地址。</p><p><strong>路由器：</strong> 实现了网络层协议（第三层协议），需要解析 IP 地址以确定数据分组的转发目标，从而实现跨网段的通信。</p></li><li><p><strong>封装：</strong>是指当数据从发送端应用层向下传输到物理层时，每一层都会在数据前或后添加的控制信息。</p><blockquote><p>对每一层而言，上一层的整个分组被视为有效载荷字段，再加上这一层的首部字段，形成新的数据单元。</p></blockquote></li><li><p><strong>解封装：</strong>当数据到达接收端时，数据从物理层向上传输到应用层的过程中，每一层会<strong>移除</strong>对应的控制信息，并将处理后的数据交给上一层，直到应用层获得原始数据。</p></li><li><p><strong>分组结构：</strong><br>在每一层，一个数据单元由两部分组成：</p><ol><li><strong>首部字段：</strong> 包含与该层相关的控制信息。</li><li><strong>有效载荷字段：</strong> 即从上一层传递过来的数据。</li></ol></li></ul><blockquote><p>注意主机实现了整个5层协议，链路交换机和路由器分别实现了2层与3层。这与：网络体系结构把更多的复杂性放在了网络的边缘的观点 不谋而合。</p></blockquote><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><p>研发网络应用的核心是写出能够<strong>运行在不同的端系统</strong>和<strong>通过网络彼此进行通信</strong>的程序。</p><h3 id="网络应用原理"><a href="#网络应用原理" class="headerlink" title="网络应用原理"></a>网络应用原理</h3><h4 id="应用体系结构"><a href="#应用体系结构" class="headerlink" title="应用体系结构"></a><strong>应用体系结构</strong></h4><p>由应用程序开发者所设计，规定了如何在各种端系统上运行程序。</p><p>主要使用的两种应用体系结构是<strong>客户-服务器</strong>和<strong>对等（P2P）体系结构</strong>。</p><ul><li><p><strong>客户-服务器体系结构</strong></p><p>有一个总是打开的主机，称为<strong>服务器</strong>，总是接收很多称为<strong>客户</strong>的其他主机的请求。</p><p><strong>特征：</strong></p><ul><li>服务器具有固定的、<strong>周知的</strong> IP 地址，并且总是打开，所以客户通过向服务器周知的 IP 位置发送分组来表示请求。</li><li>客户之间不会进行直接通信，集中式服务，可扩展性差。</li></ul></li><li><p>对等（P2P）体系结构</p><p>任何主机都可以作为<strong>服务器方</strong>和<strong>客户方</strong>。</p><p><strong>特征：</strong></p><ul><li><p>基本没有专门作为服务器的主机。</p></li><li><p>分布式服务，可扩展性好和成本低。</p></li></ul></li></ul><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h4><p>发送端和接收端通过计算机网络<strong>交换报文</strong>进行通信。</p><blockquote><p>主要考虑的是运行在不同端系统的进程（程序）进行通信。发起通信的进程称为客户，接收通信的进程是服务器。</p></blockquote><p>进程通过<strong>套接字</strong>（Socket）向网络<strong>发送报文</strong>和<strong>接收报文</strong>。</p><p>类似于寄信，<strong>进程可类比于一座房子</strong>，而它的<strong>套接字可以类比于它的门</strong>。当一个进程想向位于另一套主机上的进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施（下层网络结构），该设施将报文传送到目的进程（另一座房子）的门口。一旦该报文抵达目的主机，它通过接收进程的门（接收进程的套接字）传递，然后接收进程对该报文进行处理。</p><h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>在一台主机上运行的客户进程为了向另一台主机运行的进程发送分组，需要得知接收进程的地址。接收进程的地址由<strong>主机地址</strong>和该<strong>接收进程在目的主机上的标识符</strong>（因为一个主机可能同时运行多个网络应用）。</p><ul><li>主机地址：即主机的 IP 地址。</li><li>接收进程在目的主机上的标识符：即目的端口号。</li></ul><p>即通过 <strong>IP地址 + 端口号</strong> 来唯一地标识网络上的进程。</p><h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><p>因特网为应用程序提供 TCP 和 UDP 两个运输层协议。</p><ul><li>TCP协议：提供<strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong>。</li><li>UDP协议：只提供最低限度的服务，提供一种不可靠数据传输服务。开销比TCP协议小。</li></ul><p>当一个运输层协议不提供可靠数据传输服务，可能会导致从发送进程发送的某些分组不能到达接收进程。</p><ul><li><strong>容许丢失的应用：</strong>某些应用允许丢包的情况，例如打电话。容许丢失的应用可以使用 UDP 协议。</li></ul><p>具有吞吐量要求的应用程序称为<strong>带宽敏感的应用</strong>，能够根据当前可用的带宽或多或少的利用可使用的吞吐量的应用程序称为<strong>弹性应用</strong>。</p><ul><li>带宽敏感的应用：视频会议的音频和视频、交互式游戏。</li><li>弹性应用：文件传输、电子邮件、Web文档、智能手机讯息。</li></ul><h4 id="应用层协议内容"><a href="#应用层协议内容" class="headerlink" title="应用层协议内容"></a>应用层协议内容</h4><ul><li>交换的报文类型（请求&#x2F;响应报文）</li><li>各种报文之间的语法（报文内包括了哪些字段）</li><li>报文中字段的含义（字段如何解读）</li><li>报文的响应规则（何时以及如何发送报文）</li></ul><h3 id="Web和HTTP（本章重点）"><a href="#Web和HTTP（本章重点）" class="headerlink" title="Web和HTTP（本章重点）"></a>Web和HTTP（本章重点）</h3><p>Web 可以想象成是一个应用，HTTP 是 Web 的应用层协议。</p><h4 id="Web（不重要）"><a href="#Web（不重要）" class="headerlink" title="Web（不重要）"></a>Web（不重要）</h4><p>首先先介绍 Web 的组成：</p><ul><li><p><strong>Web页面：</strong>由<strong>对象</strong>组成，对象可以是 HTML文件，JP、EG图像 等，Web页面包含一个基本的 HTML文件 和多个引用对象。通过<strong>URL</strong>对每个对象进行引用。</p></li><li><p><strong>URL地址</strong> ：存放该对象的服务器名（主机名）+ 对象在该服务器中的路径名。</p><p>例如<code>URL：http://www.someschool.edu/somedepartment/picture.gif</code>，其中的<code>www.someschool.edu</code>就是主机名，<code>/somedepartment/picture.gif</code> 就是路径名。</p></li></ul><h4 id="HTTP（非常重要）"><a href="#HTTP（非常重要）" class="headerlink" title="HTTP（非常重要）"></a>HTTP（非常重要）</h4><p>Web的应用层协议就是<strong>HTTP协议</strong>(超文本传输协议)，它是Web的核心。</p><ul><li><p>Web浏览器实现了 <strong>HTTP 客户端</strong>，Web服务器实现了 <strong>HTTP 服务器端</strong>，用于存储 Web 对象。</p></li><li><p>HTTP使用了<strong>TCP</strong>作为它的支撑运输协议。</p><blockquote><p>这里我们看到分层结构的优点，即HTTP不用担心分组会丢失，也不关心TCP协议如何处理丢失的分组如何恢复。</p></blockquote></li><li><p>HTTP是一个<strong>无状态协议</strong>，即服务器不会记录任何有关客户的状态信息。</p></li><li><p>端口号为<strong>80</strong>。</p></li></ul><h4 id="非持续连接和持续链接"><a href="#非持续连接和持续链接" class="headerlink" title="非持续连接和持续链接"></a>非持续连接和持续链接</h4><p>首先先介绍<strong>RTT（往返时间）：</strong>是指一个分组从客户发送到服务器然后再从服务器到达客户所用的时间。</p><ul><li><p><strong>非持续连接</strong>：每个请求\响应报文都经一个单独的TCP连接进行传送。</p><p>假设采用<strong>非持续连接</strong>的情况从服务器向客户发送一个Web页面：</p><ul><li>一个Web页面有1个HTML基本文件和10个其他对象，每次都建立TCP连接、请求响应，共11次。</li></ul><p>粗略的讲，<strong>传输一个对象所用的时间 &#x3D; 两个RTT + 服务器传输对象文件所用的时间</strong>。</p><blockquote><p>TCP建立连接需要三次握手，前两次握手算作一个RTT，第三次握手时客户实际上已经向服务器发送 HTTP请求了，所以一共是两个RTT。</p></blockquote></li><li><p><strong>持续链接</strong>：所有的请求\响应报文都经同一个TCP连接进行传送。</p><p>减少了TCP连接<strong>创建</strong>和<strong>关闭</strong>的开销。</p></li></ul><h4 id="HTTP报文格式（这里简单看看）"><a href="#HTTP报文格式（这里简单看看）" class="headerlink" title="HTTP报文格式（这里简单看看）"></a>HTTP报文格式（这里简单看看）</h4><p>HTTP报文格式分为两种，<strong>请求报文</strong>和<strong>响应报文</strong>。</p><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p>请求报文的第一行叫做<strong>请求行</strong>，其后续的行叫做<strong>首部行</strong>，最后的是<strong>实体体</strong>（实体体和首部行中有一个空行）。</p><p>请求行由三个字段组成：<strong>方法字段</strong>、<strong>URL字段</strong>、<strong>HTTP版本字段</strong>。</p><ul><li><p>方法字段：可以取很多不同的值（不单单只是 GET）。</p><img src="/2025/01/24/复习笔记/178a072a39d6a45accbccefd7e2b75af.png" alt="在这里插入图片描述" style="zoom:67%;"><blockquote><p>使用GET方法时，实体体（即回车换行符右边的部分）是全空的。</p><p>当使用POST方法才会使用实体体，例如用户在搜索引擎打出关键字搜索时，（如果使用POST方法）客户的HTTP请求报文的实体体内容是该关键词。</p><p>用户在搜索引擎打出关键字搜索时，也可以使用GET方法，不过要更改请求行中URL结构，例如输入关键词banana，monkey，则URL &#x3D; 原本URL?name1&#x3D;banana&amp;name2&#x3D;monkey，如果输入重要信息可能会泄露！</p></blockquote></li><li><p>URL字段：请求对象的标识。</p></li><li><p>HTTP版本字段：表示 HTTP 使用的版本。</p></li></ul><p>首部行由 <strong>Host字段</strong>、<strong>Connection字段</strong>、<strong>User-agent字段</strong>、<strong>Accept-language字段</strong>组成。</p><ul><li><p>Host字段：表示所请求对象在的主机。</p></li><li><p>Connection字段：表示是否持续连接。</p></li><li><p>User-agent字段：向服务器发送的浏览器的类型。</p><blockquote><p>User-agent字段可以让服务器根据不同的浏览器，返回相同对象的不同版本。即类似iphone和电脑浏览相同网页，但是网页的输出大小肯定不一样。</p></blockquote></li><li><p>Accept-language字段：表示客户想得到该对象的语言版本。</p></li></ul><h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p>由三个字段：<strong>初始状态行</strong>、<strong>首部行</strong>、<strong>实体体</strong>组成。</p><p>状态行由三个字段组成：<strong>协议版本字段</strong>、<strong>状态码</strong>、<strong>相应状态信息</strong>。</p><ul><li>一些常见的状态码：<strong>200</strong>（请求成功，信息在返回的报文内）、<strong>404</strong>（被请求的文档不在服务器上）、<strong>301</strong>（请求的对象被永久转移了，新的URL定义在响应报文的<code>Location</code>字段中）…</li></ul><p>首部行由<strong>Connection字段</strong>、<strong>Date字段</strong>、<strong>Server字段</strong>、<strong>Last-Modified字段</strong>、<strong>Content-Length字段</strong>、<strong>Content-Type字段</strong>组成。</p><ul><li>Date字段：表示服务器检索到请求对象并加入到响应报文发送的时间。</li><li>Server字段：表示这份报文由哪个类型的服务器产生。</li><li>Last-Modified字段：表示该请求对象最后更改的日期。</li><li>Content-Length字段：表示该请求对象的字节数。</li><li>Content-Type字段：表示请求对象的类型。（例如Html文本之类的）</li></ul><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>HTTP服务器是<strong>无状态</strong>的，但是一个Web网站希望去识别一个用户，就出现了cookie，可以对用户进行跟踪。</p><blockquote><p>cookie被认为是一种对用户隐私的侵害！</p></blockquote><p>cookie有以下四个组件：</p><ol><li>在HTTP请求报文中有一个cookie首部行。</li><li>在HTTP的响应报文中有一个cookie首部行。</li><li>在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理。</li><li>位于Web服务器的一个后端数据库。</li></ol><p>注意客户端系统中<strong>保留一个cookie文件</strong>，由<strong>客户端系统的浏览器进行管理</strong>，发现客户主机的cookie文件中一开始有<code>ebay</code>表项，说明该客户主机之前已经访问过<code>ebay</code>网站。</p><p>当第一次访问<code>amazon.com</code>网站时，服务器为它创建一个ID，并携带在HTTP响应报文中，客户端浏览器收到HTTP响应报文后，该浏览器会在它管理的cookie文件中添加一个新表项，用以记录该ID的访问记录。</p><p>过了一段时间之后，再次使用该浏览器访问<code>amazon.com</code>网站时，浏览器首先在cookie文件下找到了记录访问<code>amazon.com</code>的数据表项，将ID携带在HTTP的请求报文中发送给服务器，服务器后端数据库查找到这个ID的记录，假如这个ID之前收藏了什么想要购买的物品（购物车），那么后端服务器都有记录，当用户想要查询之前的收藏记录时，服务端自然能把该id对应的收藏的物品信息发送过去。</p><h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><p><strong>目的：不访问原始服务器，就满足客户的请求。</strong></p><p>Web缓存器也被称为<strong>代理服务器</strong>。</p><p>Web缓存器有自己的存储空间，可以<strong>记录最近请求过的对象的副本</strong>。</p><p>Web缓存访问流程如下：</p><ol><li>浏览器(HTTP客户端)向Web缓存器建立一个TCP连接，并向Web缓存器的对象发送一个HTTP请求。</li><li>Web缓存器检查自己的磁盘存储空间，<strong>看看本地是否有存储该对象</strong>。如果有的话直接HTTP响应报文返回。</li><li>如果没有该对象，<strong>则Web缓存器向存储该对象的服务器建立TCP连接并发送该对象的HTTP请求</strong>。收到该请求后，存储该对象的服务器向Web缓存器发送该对象(HTTP响应报文)。</li><li>Web缓存器接收到该对象之后，首先在<strong>自己本地先存储一份副本</strong>，然后再透过HTTP响应报文发送该对象给浏览器(透过先前建立的TCP连接)。</li></ol><blockquote><p>值得一提的是，Web缓存器既是服务器端也是客户端。</p></blockquote><h5 id="Web缓存的优点"><a href="#Web缓存的优点" class="headerlink" title="Web缓存的优点"></a>Web缓存的优点</h5><ul><li><p>Web缓存器大大减少了客户的响应时间，特别是从浏览器到初始服务器的瓶颈带宽远远小于浏览器到Web缓存器的瓶颈带宽时。</p><blockquote><p>瓶颈带宽就是数据流经过的最慢的环节所能提供的最大带宽。可以想象为一条宽大的高速公路，如果其中某个狭窄的路段（即瓶颈）限速，那么即使其他路段很宽阔，整体的车流速度也无法超过这个限速。</p></blockquote></li><li><p>Web缓存器大大减少了局域网(机构)的接入链路的通信量，使得接入链路的带宽可以大大减少。</p></li></ul><h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>高速缓存减少响应时间的同时也引入了一个问题：存放在缓存器中的副本可能是陈旧的，即原对象可能已经被更新修改了。</p><p>而HTTP协议有一种机制，允许缓存器证实它的对象是最新的，这种机制就是<strong>条件GET方法</strong>。</p><p><strong>目的：确认Web缓存器中的对象是否有被更改。</strong></p><p>格式：如果请求报文是 GET 方法，并且包含 <strong>If-Modified-Since: 首部行</strong>，那么就是一个条件 Get 请求报文。</p><p><strong>If-Modified-Since</strong>记录了存储<strong>在Web缓存器中该对象最后的修改时间</strong>，在Web缓存器向初始服务器获取该对象的请求报文中的Last-Modified首部行中得到。</p><p>流程如下：</p><ol><li><p>客户 A 发送 HTTP 请求报文给 Web 缓存器。</p></li><li><p>Web 缓存器有该对象，然后向初始服务器发送<strong>条件 Get</strong> (包含If-Modified-Since: 首部行)。</p></li><li><p>初始服务器上的对象若没有改动，于是返回 HTTP 响应报文，状态码为 304（返回的 HTTP 响应报文并没有该对象实体）。</p><blockquote><p>因为如果包含该对象就会浪费带宽。</p></blockquote></li><li><p>Web 缓存器使用本地存储的对象返回给客户端。</p></li></ol><h3 id="因特网中的电子邮件系统"><a href="#因特网中的电子邮件系统" class="headerlink" title="因特网中的电子邮件系统"></a>因特网中的电子邮件系统</h3><p>由三个部分组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>、**简单邮件传输协议(SMTP)**。</p><img src="/2025/01/24/复习笔记/image-20241208152556510.png" alt="image-20241208152556510" style="zoom:67%;"><ul><li><p>用户代理：这是用户用来发送、接收和管理电子邮件的软件或应用程序。</p></li><li><p>邮件服务器： 每个邮件服务器上会对应每个接收方有个邮箱。邮箱管理和维护着接收方的报文。</p><p>具体流程：</p><ol><li><strong>发送方代理</strong>将邮件发送到<strong>发送方的服务器邮箱</strong>。</li><li><strong>发送方的服务器</strong>将邮件发送到<strong>接收方的服务器邮箱</strong>。</li><li><strong>接收方的服务器</strong>再将邮件发送给<strong>接收方代理</strong>。</li></ol></li><li><p>简单邮件传输协议(SMTP)：是因特网电子邮件的主要应用层协议。</p></li></ul><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>邮件服务器之间借助 <strong>SMTP</strong> 发送 Email 报文，它定义了邮件服务器之间交换电子邮件的规则和格式。</p><ul><li>SMTP 使用 <strong>TCP</strong> 在客户端和服务器之间传送报文，端口号为25。</li><li>SMTP 要求各个服务器之间不存在中间服务器。也就是发送方服务器和接收方服务器之间不存在其他中介服务器。</li><li>要求报文必须转化成 <strong>ASCII 码</strong>再进行传输。</li><li>SMTP 要求报文（首部和主体）必须都是<strong>7位的ASCII编码</strong>。</li></ul><p>邮件发送的流程：</p><ol><li>邮件从发送方 A 的用户代理开始，传输到发送方 A 的邮件服务器，邮件放在报文队列中（不会立即发送，而是<strong>定时统一</strong>进行发送）</li><li>SMTP 的客户端打开到接收方B邮件服务器的 TCP 连接，通过 TCP 连接发送邮件（可以发现这里 TCP 的连接是由发送方的机器发起的）</li><li>接收方 B 的邮件服务器将邮件放到 B 的邮箱中，B 调用他的用户代理来阅读邮件。</li></ol><h4 id="SMTP与HTTP的区别"><a href="#SMTP与HTTP的区别" class="headerlink" title="SMTP与HTTP的区别"></a>SMTP与HTTP的区别</h4><p>二者都采用请求 命令 - 响应 模型。</p><ul><li><p><strong>SMTP是推协议</strong>：邮件从发送方主动“推”到接收方的服务器。<strong>HTTP是拉协议</strong>：客户端（如浏览器）向服务器发出请求，服务器返回相应的数据。</p><blockquote><p>在网络通信中，“拉协议”指的是客户端主动向服务器请求数据，服务器根据请求返回相应的数据。这与“推协议”（如 SMTP）相对，推协议是服务器主动将数据发送给客户端。</p></blockquote></li><li><p>SMTP <strong>要求 ASCII 码格式</strong>。HTTP 不需要。</p></li><li><p>SMTP 是<strong>面向电子邮件传输</strong>的文本协议（以文本为主），而 HTTP 是<strong>面向超文本传输</strong>的应用层协议（以传输网页内容、图片为主）。</p></li></ul><h4 id="SMTP报文格式"><a href="#SMTP报文格式" class="headerlink" title="SMTP报文格式"></a>SMTP报文格式</h4><ul><li><p>每一个典型的邮件报文都包含<strong>首部行</strong>和<strong>报文体</strong>。</p></li><li><p>每个报文的首部行都会包含 <strong>From: 首部行</strong>和 <strong>To: 首部行</strong>。</p></li><li><p>首部行与报文体中间有一个间隔。</p></li><li><p>格式类似如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">From:</span> ilovesysu<span class="hljs-subst">@123</span>.com<br><span class="hljs-symbol">TO:</span> sysuloveme<span class="hljs-subst">@123</span>.com<br><br>ASCII data...<br></code></pre></td></tr></table></figure></li></ul><h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>邮件访问协议是<strong>拉协议</strong>，因为接收用户代理主动向接收方邮件服务器请求并获取邮件内容。</p><p>常见的邮件访问协议有：<strong>IMAP</strong>…</p><h3 id="DNS（本章重点）"><a href="#DNS（本章重点）" class="headerlink" title="DNS（本章重点）"></a>DNS（本章重点）</h3><p>识别一部主机的方式：<strong>主机名</strong>、<strong>IP地址</strong>。</p><blockquote><p>人们喜欢便于记忆的主机名，但路由器喜欢格式统一的IP地址。</p></blockquote><p>目的：实现主机名与 IP 地址之间的转换，可以去识别主机。</p><ul><li><p>DNS是一个<strong>分层的 DNS 服务器</strong>实现的<strong>分布式数据库</strong>。</p></li><li><p>是<strong>应用层协议</strong>。</p><blockquote><p>但是与一般的应用层协议不同，DNS是与客户的应用程序打交道而不是与客户打交道。</p></blockquote></li><li><p>使用 UDP 协议作为运输层协议。</p></li></ul><h4 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h4><ol><li><p><strong>域名解析</strong></p><p>DNS 的核心服务是将域名与对应的 IP 地址互相解析。</p><ul><li><strong>正向解析</strong>：将域名解析为 IP 地址（如 <code>www.example.com</code> → <code>93.184.216.34</code>），便于用户访问网站或其他网络服务。</li><li><strong>反向解析</strong>：将 IP 地址解析为域名（如 <code>93.184.216.34</code> → <code>www.example.com</code>），通常用于网络故障排查或安全认证。</li></ul></li><li><p><strong>负载均衡</strong></p><p>DNS 可以根据用户的地理位置或其他策略，将请求分配给不同的服务器，实现<strong>流量分发和负载均衡</strong>。例如，访问同一域名时，可能解析到不同的数据中心的 IP 地址，从而优化访问速度。</p></li></ol><h4 id="DNS的层次结构"><a href="#DNS的层次结构" class="headerlink" title="DNS的层次结构"></a>DNS的层次结构</h4><p>大致说来，一共有三种不同类型的DNS服务器：<strong>根DNS服务器</strong>、<strong>顶级域DNS服务器(TLD)<strong>、</strong>权威DNS服务器</strong>。</p><ul><li><strong>根DNS服务器</strong><ul><li>根域名服务器存储了<strong>所有顶级域（TLD）服务器的地址信息</strong>（每一个根域名服务器并不存储全部顶级域服务器的地址信息，而是只存储一部分TLD服务器的地址信息）</li><li><strong>主要功能</strong>是告诉查询者<strong>下一步应该访问哪个顶级域 DNS 服务器</strong>（如 <code>.com</code>、<code>.org</code>、<code>.cn</code> 等）。</li></ul></li><li><strong>顶级域DNS服务器(TLD)</strong><ul><li>负责<strong>顶级域名</strong>（如com，org，net等）和<strong>所有国家级的顶级域名</strong>（如cn，uk，jp等）。</li></ul></li><li><strong>权威DNS服务器</strong><ul><li>权威 DNS 服务器<strong>负责存储特定域名的实际记录</strong>，包括正向解析（域名到 IP）和反向解析（IP 到域名）的映射。</li></ul></li></ul><blockquote><p>你可以把这三类服务器比作一个分布式的导航系统：</p><ol><li><strong>根服务器</strong>：像是地图的目录，告诉你去哪个分区（比如 <code>.com</code>）。</li><li><strong>TLD 服务器</strong>：像是分区内的管理员，指向目标（比如 <code>example.com</code> 的权威服务器）。</li><li><strong>权威服务器</strong>：像是目的地的接待员，直接告诉你最终答案（域名对应的 IP 地址）。</li></ol></blockquote><p>以上三种 DNS 服务器都属于 DNS 服务器的层次结构中，但是还有一种重要的 DNS 服务器，它不属于 DNS 层次结构，但是它非常重要，就是<strong>本地服务器</strong>。</p><ul><li><strong>本地DNS服务器</strong><ul><li>每一个 ISP 都有一台本地 DNS 服务器。</li><li>当一个主机发起 DNS 查询时，查询被送到其本地 DNS 服务器，起着代理的作用，将查询转发到层次结构中。</li><li><strong>优点：</strong>可以实现缓存！</li></ul></li></ul><p>DNS 查询分为<strong>迭代查询</strong>和<strong>递归查询</strong>。</p><p><strong>迭代查询：</strong>在迭代查询中，客户端向本地 DNS 服务器发送查询请求，本地 DNS 服务器若无法解析该请求，会返回一个指向下一个 DNS 服务器的参考。客户端自己继续向返回的 DNS 服务器发送查询，直到找到最终答案。</p><p><strong>递归查询：</strong>在递归查询中，客户端将查询请求发送给本地 DNS 服务器。如果本地 DNS 服务器无法直接返回结果，它会继续向其他 DNS 服务器发起查询，直到找到最终的答案。</p><p><strong>区别：</strong>递归查询下，<strong>根 DNS 服务器的压力较大</strong>。主机向本地 DNS 服务器查询常使用递归查询，为了减少根 DNS 服务器的压力，域名服务器之间的查询常使用下面这种方式：</p><ul><li><p>从主机到本地 DNS 是递归查询，其余查询都是迭代查询。</p></li><li><p>所有查询都是递归查询：                                  </p></li></ul><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><ul><li>如果在 DNS 服务器中缓存了一个 主机名&#x2F;IP地址对，另一个对相同主机名的查询到达该 DNS 服务器时，该 DNS 服务器就能立刻返回对应的 IP 地址，<strong>即使它并不是该主机名的权为服务器</strong>。</li><li>经过了 TTL 时间后，DNS 服务器就会删除缓存中的资源。<ul><li><strong>优势</strong><ul><li><strong>速度提升</strong>：减少了域名解析所需的时间和网络延迟。</li><li><strong>减少负载</strong>：降低了 DNS 服务器的压力，尤其在高访问量的网络中。</li></ul></li><li><strong>问题</strong><ul><li><strong>缓存过期</strong>：当缓存记录的 TTL 到期时，必须重新查询，可能导致短暂延迟。</li><li><strong>更新延迟</strong>：当域名的 IP 地址发生变化时，旧的缓存记录可能导致访问失败或错误。</li></ul></li></ul></li></ul><h4 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h4><p>实现 DNS 分布式数据库的所有 DNS 服务器存储了<strong>资源记录（Resource Record，RR）</strong>，RR 提供了主机名到IP地址的映射。</p><p>RR 是一个四元组：**(Name, Value, Type, TTL)**</p><ul><li><p>TTL 是该记录的生存时间，决定了该资源记录应当从缓存中删除的时间。</p></li><li><p>Name 和 Value 的意义取决于 Type。</p><table><thead><tr><th align="center">TYPE</th><th align="center">NAME</th><th align="center">VALUE</th><th align="center">EXAMPLE</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">主机规范名</td><td align="center">对应的IPV4地址</td><td align="center">example.com → 192.0.2.1</td></tr><tr><td align="center">NS</td><td align="center">域名</td><td align="center">请求链中的下一个域名</td><td align="center">example.com → dns.example.com</td></tr><tr><td align="center">CNAME</td><td align="center">主机别名</td><td align="center">主机规范名</td><td align="center"><a href="http://www.example.com/">www.example.com</a> → example.com</td></tr><tr><td align="center">MX</td><td align="center">邮件服务器别名</td><td align="center">邮件服务器规范名</td><td align="center">example.com → mail.example.com</td></tr></tbody></table><blockquote><p>一个主机只会有一个主机规范名，但可以有很多个主机别名。</p><p>不记得了看看这篇博客：[计算机网络之域名、主机名、IP地址和URL-CSDN博客](<a href="https://blog.csdn.net/weixin_45437521/article/details/109037537#:~:text=%E4%B8%BB%E6%9C%BA%E5%88%AB%E5%90%8D%EF%BC%88%E5%BD%93%E5%AD%98%E5%9C%A8%E6%97%B6%EF%BC%89%E6%AF%94%E4%B8%BB%E6%9C%BA%E8%A7%84%E8%8C%83%E5%90%8D%E6%9B%B4%E5%8A%A0%E5%AE%B9%E6%98%93%E8%AE%B0%E5%BF%86%E3%80%82">https://blog.csdn.net/weixin_45437521/article/details/109037537#:~:text=主机别名（当存在时）比主机规范名更加容易记忆。</a> 应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址。 主机别名不是一定要有的，也有很多主机只有一个主机名。,规范主机名具有唯一性。 规范主机名对应多个别名，多个IP地址。 一个别名也可以对应多个IP地址。 计算机名称是在我的电脑–&gt;属性–&gt;计算机名称，它是表明这台计算机的名称叫什么。)</p></blockquote><ul><li><p><strong>CNAME 记录本身不直接关联 IP 地址</strong>，它只会提供一个域名到另一个域名的映射。然后，后续的 DNS 查询会继续解析这个规范主机名（<code>VALUE</code>）到其对应的 IP 地址。</p><blockquote><p>从实现的功能来看，A记录和CNAME记录并无太大差别。但是CNAME记录在做IP地址变更时要比A记录方便。</p><p>CNAME记录允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即：CNAME)到A记录的域名上。</p></blockquote></li><li><p>当一个 DNS 服务器是某个特定主机名的<strong>权威 DNS 服务器</strong>时，它负责存储和管理该主机名的所有 DNS 记录。这时，权威服务器通常会包含该主机名的 <strong>A 记录</strong>（将域名映射到其对应的 IP 地址）。</p><blockquote><p>即使不是权威 DNS 服务器，也有可能缓存一条 A 记录。</p></blockquote></li><li><p>当一个 DNS 服务器不是某个特定主机名的<strong>权威 DNS 服务器</strong>时，它并没有该域名的直接记录（如 A 记录）。这时，非权威 DNS 服务器会通过 <strong>NS 记录</strong> 指向该主机名的权威 DNS 服务器，并通过 <strong>A 记录</strong> 提供该权威 DNS 服务器的 IP 地址。<br>这意味着非权威 DNS 服务器并没有该域名的最终 IP 地址，而是通过查询权威 DNS 服务器来获取正确的记录。</p></li></ul></li></ul><h4 id="DNS报文格式"><a href="#DNS报文格式" class="headerlink" title="DNS报文格式"></a>DNS报文格式</h4><p>DNS 请求和应答都是用相同的报文格式，分成5个段（有的报文段在不同的情况下可能为空），如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+---------------------+<br>  |<span class="hljs-string">        Header       </span>|<span class="hljs-string"> 报文头</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">       Question      </span>|<span class="hljs-string"> 要查询的问题</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">        Answer       </span>|<span class="hljs-string"> 服务器的应答</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">      Authority      </span>|<span class="hljs-string"> 权威的应答</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">      Additional     </span>|<span class="hljs-string"> 附加信息</span><br><span class="hljs-string">  +---------------------+</span><br></code></pre></td></tr></table></figure><h4 id="DNS域名解析流程"><a href="#DNS域名解析流程" class="headerlink" title="DNS域名解析流程"></a>DNS域名解析流程</h4><ol><li><p><strong>客户端查询</strong></p><ul><li>当用户在浏览器中输入一个域名（如 <code>www.example.com</code>）时，首先会检查操作系统的本地 DNS 缓存，看是否已经有该域名对应的 IP 地址。</li></ul></li><li><p><strong>查询本地 DNS 服务器</strong></p><ul><li>如果操作系统没有缓存结果，客户端会将 DNS 查询请求发送给 <strong>本地 DNS 服务器</strong>（通常是 ISP 提供的 DNS 服务器）。这就是 DNS 查询的起点。</li><li>本地 DNS 服务器会首先检查自己是否有该域名的解析记录，如果有，则直接返回该 IP 地址给客户端。</li></ul></li><li><p><strong>本地 DNS 服务器查找（递归或迭代查询）</strong></p><ul><li>如果本地 DNS 服务器没有该域名的解析记录，它会以<strong>递归查询</strong>或<strong>迭代查询</strong>的方式向更高级别的 DNS 服务器请求解析。</li></ul></li><li><p><strong>根 DNS 服务器查询</strong></p><ul><li>如果本地 DNS 服务器需要从根 DNS 服务器开始查询，它会向根 DNS 服务器发起请求。根 DNS 服务器返回一个 <strong>顶级域（TLD）DNS 服务器</strong> 的地址，如 <code>.com</code> 的 TLD 服务器。</li></ul></li><li><p><strong>TLD DNS 服务器查询</strong></p><ul><li>本地 DNS 服务器根据根 DNS 服务器提供的指引，查询到对应的 <strong>TLD DNS 服务器</strong>（例如：<code>com</code> 域名的 TLD DNS 服务器）。TLD DNS 服务器返回指向 <strong>权威 DNS 服务器</strong> 的地址。</li></ul></li><li><p><strong>权威 DNS 服务器查询</strong></p><ul><li>本地 DNS 服务器向 <strong>权威 DNS 服务器</strong> 发起查询，权威 DNS 服务器知道该域名的最终解析结果（即对应的 IP 地址）。</li><li>权威 DNS 服务器返回该域名的 <strong>A 记录</strong>（如果是 IPv4）或者 <strong>AAAA 记录</strong>（如果是 IPv6）给本地 DNS 服务器。</li></ul></li><li><p><strong>返回结果</strong></p><ul><li>本地 DNS 服务器将查询到的 IP 地址返回给客户端。客户端就可以使用这个 IP 地址与目标服务器建立连接（例如加载网页）。</li></ul></li></ol><h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>目前我们讨论的都是<strong>客户 - 服务器(CS) 模型</strong>：</p><ul><li><p><strong>结构：</strong>在 CS 模型中，网络中有明确的角色分配。<strong>客户端</strong>发起请求，而<strong>服务器</strong>提供资源或服务。服务器通常是强大的计算机或设备，负责管理和处理客户端的请求。</p></li><li><p><strong>通信：</strong>客户端向服务器发送请求，服务器响应并处理这些请求。客户端和服务器之间通常有一对多的关系。</p><blockquote><p>客户之间是不会进行通信的。</p></blockquote></li><li><p>极大地依赖总是打开的基础设施服务器。</p></li></ul><p>而在P2P模型中</p><ul><li><strong>结构：</strong>节点没有明确的角色区分，所有节点既可以是资源的提供者，也可以是资源的请求者。</li><li><strong>通信：</strong>节点之间直接相互通信，数据和资源可以在节点之间共享，不依赖于中心服务器。</li></ul><h4 id="C-S与P2P模型分发时间比较"><a href="#C-S与P2P模型分发时间比较" class="headerlink" title="C&#x2F;S与P2P模型分发时间比较"></a>C&#x2F;S与P2P模型分发时间比较</h4><ul><li>$$u_s$$表示服务器接入链路的上载速率。</li><li>$$u_i$$表示第$$ i$$ 个对等方接入链路的上载速率。</li><li>$$N$$表示想要获得该文件副本的对等方数量。</li><li>$$F$$表示被分发的文件长度(bit)。</li><li><strong>分发时间：</strong>所有 N 个对等方得到该文件的副本所需要的时间。</li></ul><h4 id="C-S分发时间"><a href="#C-S分发时间" class="headerlink" title="C&#x2F;S分发时间"></a>C&#x2F;S分发时间</h4><ul><li><p>服务器需要向 $$N$$ 个对等方传输该文件的副本，一共是$$NF$$ bit。服务器上载速率为$$u_s$$。**因此服务器分发该文件的时间必定至少为$$\frac{NF}{u_s}$$**。</p></li><li><p>令$$d_{min} &#x3D; min{d_1,d_2,…,d_N}$$，具有$$d_{min}$$下载速率的对等方至少需要$$\frac{F}{d_{min}}$$下载该副本，**因此分发该文件的时间至少为$$\frac{F}{d_{min}}$$**。</p></li><li><p>综合以上两点可以得出：<br>$$<br>D_{cs} \geq max{\frac{NF}{u_S},\frac{F}{d_}}<br>$$<br>可以发现，当$$N$$很大的时候，分发时间被第一项所支配了。并且还是<strong>线性增长</strong>的。</p></li></ul><h4 id="P2P分发时间"><a href="#P2P分发时间" class="headerlink" title="P2P分发时间"></a>P2P分发时间</h4><ul><li><p>在分发开始的时候，只有服务器有文件，**分发该文件至少需要$$\frac{F}{u_s}$$**。</p></li><li><p>令$$d_{min} &#x3D; min{d_1,d_2,…,d_N}$$，具有$$d_{min}$$下载速率的对等方至少需要$$\frac{F}{d_{min}}$$下载该副本，**因此分发该文件的时间至少为$$\frac{F}{d_{min}}$$**。</p></li><li><p>考虑整个系统的上载，一共需要上传 $$NF$$ bit的文件，整个系统的上载速率为$$u_{total}&#x3D;u_s+u_1+u_2+…+u_N$$，因此最小的分发时间至少为$$\frac{NF}{U_{total}}$$。</p></li><li><p>综合以上三点可以得出：<br>$$<br>D_{P2P} \geq max{\frac{F}{u_S},\frac{F}{d_},\frac{NF}{U_{total}}}<br>$$<br>可以发现，当$$N$$很大的时候，第三项的$$u_{total}$$也会相应增大。</p></li></ul><h4 id="分发时间随N变化图"><a href="#分发时间随N变化图" class="headerlink" title="分发时间随N变化图"></a>分发时间随N变化图</h4><p>发现 C&#x2F;S 模型是线性增长的，但是 P2P 模型不是。</p><h3 id="BitTorrent（这个真的不太重要，感觉不太重要）"><a href="#BitTorrent（这个真的不太重要，感觉不太重要）" class="headerlink" title="BitTorrent（这个真的不太重要，感觉不太重要）"></a>BitTorrent（这个真的不太重要，感觉不太重要）</h3><p>一种用于文件分发的P2P协议。</p><p>一些术语定义如下：</p><ul><li><strong>洪流：</strong>参与一个特定的文件分发的所有对等方集合。在一个洪流中的对等方彼此下载等长度的文件块。</li><li><strong>文件块：</strong>将一个文件拆分成很多个块，典型的一个块为256KB。</li><li><strong>追踪器：</strong>每个洪流都有一个追踪器。</li></ul><p>当有一个新节点 Alice 加入洪流，会有以下流程：</p><ol><li>向追踪点注册自己，并且周期性的通知追踪器自己仍在洪流中。</li><li>追踪点会随机选择洪流中对等方的节点子集告诉新节点 Alice，Alice会与这些节点并行建立 TCP 连接。</li><li>Alice 从这些邻居中获取它们拥有哪些块，并思考做出以下两个决定：<ul><li>应该从哪个邻居当中获取哪些块</li><li>应该向哪个向她发出请求块的邻居发送块</li></ul></li><li>应该从哪个邻居当中获取哪些块：<ul><li><strong>最稀缺算法</strong>：选择在所有的邻居中副本数量最少的块来获取。</li></ul></li><li>应该向哪个向她发出请求块的邻居发送块<ul><li>Alice 根据当前能够以<strong>最高速率</strong>向她提供数据的邻居中选择。</li></ul></li></ol><h3 id="内容分发网-cdn（看看概念就行）"><a href="#内容分发网-cdn（看看概念就行）" class="headerlink" title="内容分发网 cdn（看看概念就行）"></a>内容分发网 cdn（看看概念就行）</h3><p>简单来说，就是想让客户访问距离客户最近的服务器，增快访问速度。</p><p>流程如下：</p><ol><li>用户向 Local DNS 服务器发起请求</li><li>DNS 服务器将请求重定向到 CDN 服务器。</li><li>CDN 服务器提供最优 CDN 服务器的 IP 地址。</li><li>用户向该 CDN 服务器请求内容。</li><li>该 CDN 服务器提供内容。</li></ol> <h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>HTTPS 是 HTTP（应用层协议）+ TLS&#x2F;SSL 的结合，而 HTTP 数据通过 TLS 加密后，再传输到 TCP（传输层协议）进行数据传输。</li></ul><h3 id="题目（随便选几题）"><a href="#题目（随便选几题）" class="headerlink" title="题目（随便选几题）"></a>题目（随便选几题）</h3><ul><li><p><strong>R3：</strong>对于两个进程的通信而言，哪个进程是用户，哪个进程是服务器？</p><p>答：一般而言，主动发起通信的进程是用户，等待接受通信的是服务器。</p></li><li><p><strong>R6：</strong>假定你想尽快处理从远程客户到服务器的事务，你会选择TCP还是UDP？</p><p>答：选择 UDP，因为 UDP 进行通信成本更低，不需要向 TCP 一样进行三次握手等等。</p></li><li><p><strong>R10：</strong>什么是握手协议？</p><p>答：实际上是一个<strong>同步机制</strong>，类似交换信息，双方都告诉对方自己的信息，以及一些预备动作。</p></li><li><p><strong>R19：</strong>一个机构的 Web 服务器和邮件服务器可以有完全相同的主机名别名（例如：foo.com） 吗？包含邮件服务器主机名的 RR 有什么样的类型？</p><p>答：可以有相同的主机名别名，包含邮件服务器主机名的 RR 可以有 <strong>MX</strong>、<strong>A</strong>类型。</p><ul><li><strong>MX 类型</strong>完成邮件服务器主机名到邮件服务器规范主机名的映射。</li><li><strong>A 类型</strong>完成邮件服务器规范主机名到邮件服务器 IP 地址的映射。</li></ul></li><li><p><strong>R22：</strong>考虑一个新对等方 Alice 加入 BitTorrent 而不拥有任何文件块。没有任何块，因此她没有任何东西可上载，她无法成为任何其他对等方的前 4 位上载者。那么 Alice 将怎样得到她的第一个文件块呢？</p><p>答：太工程了，感觉不会考。</p></li><li><p><strong>R26：</strong>2.7 节中所描述的 UDP 服务器仅需要一个套接字，而 TCP 服务器需要两个套接字。为什么？如果 TCP 服务器支持 n 个并行连接，每条连接来自不同的客户主机，那么 TCP 服务器将需要多少个套接字？</p><p>答：UDP 没有欢迎套接字，UDP 的连接和发送都是通过一个套接字进行的。而 TCP 需要一个欢迎套接字建立三次握手过程，当连接建立时，又创建一个新套接字用于通信，所以如果 TCP 服务器需要支持 n 个并行连接，那么需要有 n + 1 个套接字。</p></li><li><p><strong>R27：</strong>对于 2.7 节所描述的运行在 TCP 之上的客户-服务器应用程序，服务器程序为什么必须先于客户程序运行？对于运行在 UDP 之上的客户-服务器应用程序，客户程序为什么可以先于服务器程序运行？</p><p>答：基于 TCP 的程序，客户端必须与服务器程序建立持续性的连接，服务器必须先通过 <strong><code>bind()</code></strong> 和 <strong><code>listen()</code></strong> 在一个固定的端口上等待客户端的连接请求，所以服务器程序必须先于客户程序打开。基于 UDP 的程序，因为 UDP 的客户程序本身并不期待报文能无差错可靠的到达。</p></li></ul><h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><p>经典的运输层协议有：<strong>TCP</strong>、<strong>UDP</strong>。</p><p><strong>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信。</strong></p><p>运输层协议是在<strong>端系统中实现的</strong>，而不是在路由器中实现。</p><p>实现方法如下：</p><ul><li>将应用报文拆分成很多小块，并且每个小块加上运输层头部形成运输层报文段。</li><li>在发送端系统中，运输层将运输层报文段交给网络层，网络层进行封装成网络层分组，并向目的地发送。</li><li>接收端系统中，网络层提取出分组的运输层报文段并交给接收端运输层进行处理。</li></ul><h3 id="运输层与网络层区别"><a href="#运输层与网络层区别" class="headerlink" title="运输层与网络层区别"></a>运输层与网络层区别</h3><p>运输层位于网络层之上。</p><p>运输层提供了应用进程之间的逻辑通信。</p><p>网络层提供了主机之间的逻辑通信。</p><p><strong>运输层实际上是透过网络层实现的。</strong></p><blockquote><p>设想一下有两所房子，每所房子里都住着12个小孩。两所房子里的孩子喜欢互相通信，每一封信都由老式的邮局分别用信封来寄。在每一家里面都由一个孩子——西海岸的房子里的Ann和东海岸房子里的BilI——负责邮件的收集和分发。每周Ann都从她的兄弟姐妹那里收集起来信件，并将这些信件送到每天都来的邮递服务员那里。当信件到达西海岸的房子，Ann又将这些信件分发给她的兄弟姐妹。BilI在东海岸有着同样的工作。</p><p>在这个例子中，邮递服务提供着两所房子之间的逻辑通信——邮递服务在两所房子之间传递邮件，而不是针对每个人的服务。</p><p>另一方面，Ann和BilI提供堂兄妹之间的逻辑通信——Ann和BilI从他们的兄弟姐妹那里收集邮件并将邮件递送给他们。</p><p>注意，从这些堂兄妹的角度看，Ann和BilI是邮件的服务人，尽管他们俩只是端到端寄送服务的一部分(终端系统部分)。</p><ul><li>主机(也称为终端系统)&#x3D;房子</li><li>进程&#x3D;堂兄妹</li><li>应用程序消息&#x3D;信封里的信</li><li>网络层协议&#x3D;邮递服务(包括邮递员)</li><li>传输层协议&#x3D;Ann和Bill</li></ul></blockquote><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>提供可靠的、面向连接的服务。</li><li>提供拥塞控制。</li><li>提供流量控制。</li><li>多路复用、解复用。</li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul><li>提供不可靠、无连接的服务。</li><li>基本上只有最基本的运输层功能。</li><li>没有为<strong>尽力而为</strong>的 IP 服务添加更多功能。</li><li>多路复用、解复用。</li></ul><h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>我们已经知道，网络层向传输层提供的提供的服务是<strong>主机-主机</strong>的，而传输层提供的服务是<strong>进程-进程</strong>的，如何在传输层实现这一细分的服务的实现，所依靠的就是<strong>端口号</strong>。</p><ul><li>端口号实际上是将收到的报文定位到相应的套接字，再由相应的套接字发送给对应的进程。</li></ul><p>通常一部主机上都会运行多个网络应用程序进程，即<strong>一部主机会同时运行多个套接字</strong>。</p><p>考虑接收主机如何将一个到达的运输层报文段定向到合适的套接字。</p><p><strong>多路分解(接收方)：</strong> 根据报文段的头部信息中的<strong>IP地址</strong>和<strong>端口号</strong>将接收到的报文段发给正确的套接字(和对应的应用进程)。</p><p><strong>多路复用(发送方)：</strong>从多个套接字接收来自多个进程的报文，根据套接字对应的<strong>IP地址</strong>和<strong>端口号</strong>等信息对报文段用头部加以封装。</p><blockquote><p>考虑到上述的例子：当 Bill 从邮递员收到一批信件，并且通过查看收件人来分发信件，就是多路分解；当 Ann从兄弟姐妹收集要发送的信件给邮递员，就是一个多路复用。</p></blockquote> <h4 id="UDP的多路复用与多路分解"><a href="#UDP的多路复用与多路分解" class="headerlink" title="UDP的多路复用与多路分解"></a>UDP的多路复用与多路分解</h4><p>一个 UDP 套接字由一个二元组全面标识，包含一个<strong>目的 IP</strong> 和<strong>目的端口号</strong>。</p><blockquote><p>若两个 UDP 报文段具有不同的源地址IP和源端口号，但是具有相同的目的IP和目的端口号，则两个报文段会经过相同的目的套接字被定向到相同的进程。</p></blockquote><p>当一个 UDP 报文段到达接收主机，接收主机运输层检查该报文段中的目的端口号，并将该报文段交付给目的端口号所标识的套接字。</p><h4 id="TCP的多路复用与多路分解"><a href="#TCP的多路复用与多路分解" class="headerlink" title="TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h4><p>一个 TCP 套接字由一个四元组全面标识，包含一个<strong>目的 IP</strong> 和<strong>目的端口号</strong>和一个<strong>源 IP</strong> 和<strong>源端口号</strong>。</p><blockquote><p>两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字。</p><p>UDP 是传输到同一套接字，TCP 为每个客户创建一个 socket。</p></blockquote><p>当一个 TCP 报文段到达接收主机，接收主机利用上述四个值来定向(分解)一个套接字，并将该报文段交付给该套接字。</p><p>查看下图，就算主机 A 和主机 C 都分配源端口 26145，但是服务器 B 仍然能够正确分解这两个具有相同端口号的连接，因为<strong>具有不同的 IP 位置</strong>。</p><h3 id="无连续运输：UDP"><a href="#无连续运输：UDP" class="headerlink" title="无连续运输：UDP"></a>无连续运输：UDP</h3><h4 id="UDP-提供的服务"><a href="#UDP-提供的服务" class="headerlink" title="UDP 提供的服务"></a>UDP 提供的服务</h4><ul><li>尽力而为的服务，数据包可能会丢，乱序。</li><li>在发送报文段之前，发送方和接收方的运输层实体之间没有握手（无连接）。</li></ul><h4 id="UDP-好处（对比-TCP）"><a href="#UDP-好处（对比-TCP）" class="headerlink" title="UDP 好处（对比 TCP）"></a>UDP 好处（对比 TCP）</h4><ul><li><p><strong>应用层可以更好的控制发送数据的时间</strong></p><p>因为 TCP 有拥塞控制机制，所以当网络情况变得极度拥塞的时候，就会抑制 TCP 发送方。</p></li><li><p><strong>无需建立连接</strong></p><p>因为 TCP 需要三次握手建立连接，UDP 没有连接时延。</p></li><li><p><strong>无连接状态</strong></p><p>TCP 需要维护连接状态，例如发送和接收方缓存。</p></li><li><p><strong>分组首部开销更小</strong></p><p>UDP 首部只需要 8 个字节，TCP 首部需要 20 个字节。</p></li></ul><h4 id="UDP报文段"><a href="#UDP报文段" class="headerlink" title="UDP报文段"></a>UDP报文段</h4><p> UDP 头部只有四个字段，每个字段占两个字节。</p><p>分别是 源端口号，目的端口号，长度，检验和。</p> <h4 id="UDP-检验和"><a href="#UDP-检验和" class="headerlink" title="UDP 检验和"></a>UDP 检验和</h4><p>检验和计算：就是当加法溢出后，回卷，然后再执行反码运算。</p><p>如何检验：将所有的分组和检验和相加，结果需要为全1。</p> <p>如果未通过检验则说明数据报存在差错，<strong>但通过检验也只能说明未检测到差错，不能证明接收到的数据报一定正确无误。</strong></p><blockquote><p>举个简单的例子：0000 和 1111，检验和计算为 0000；若出现差错，为0001 和 1110，则检验和计算不出来。</p></blockquote><h3 id="可靠数据传输原理（很重要这部分）"><a href="#可靠数据传输原理（很重要这部分）" class="headerlink" title="可靠数据传输原理（很重要这部分）"></a>可靠数据传输原理（很重要这部分）</h3><p>可靠数据传输协议为上层实体提供的抽象是<strong>可以通过一条可靠的信道进行传输</strong>。</p><p>但是实际上可靠传输协议的下层协议是<strong>不可靠的</strong>。</p><p>利用不可靠的协议来实现可靠的信道。</p> <h4 id="rdt-1-0（在可靠信道上的可靠数据传输）"><a href="#rdt-1-0（在可靠信道上的可靠数据传输）" class="headerlink" title="rdt 1.0（在可靠信道上的可靠数据传输）"></a>rdt 1.0（在可靠信道上的可靠数据传输）</h4><p>假设信道是完全可靠的。</p><p>有限状态机为：</p> <h4 id="rdt-2-0（经具有比特差错信道的可靠数据传输）"><a href="#rdt-2-0（经具有比特差错信道的可靠数据传输）" class="headerlink" title="rdt 2.0（经具有比特差错信道的可靠数据传输）"></a>rdt 2.0（经具有比特差错信道的可靠数据传输）</h4><p>引入了**否定确认(NAK)<strong>和</strong>肯定确认(ACK)**控制报文。</p> <p>发送端有两个状态，当它在等待接收端传控制报文的时候，它不能从上层获取数据。</p><p>类似这种行为的协议叫做<strong>停等协议</strong>。</p><h4 id="rdt-2-2（无NAK）"><a href="#rdt-2-2（无NAK）" class="headerlink" title="rdt 2.2（无NAK）"></a>rdt 2.2（无NAK）</h4><blockquote><p>rdt 2.1和 rdt 2.2都一样，只不过 2.1 有 NAK，2.2 是全部使用 ACK 包了。</p></blockquote><p>但是有个问题，当控制报文（ACK NAK）分组受损，要怎么办？</p><p>因此在数据分组中<strong>增加序号</strong>，让发送方对于其数据分组编号（0 &#x2F; 1），并且当发送方收到重复的 ACK 序号则重发。</p><p>接收方接受到序号为什么的包，就 ACK 什么序号回去。</p> <h4 id="rdt-3-0（经具有比特差错的丢包信道的可靠数据传输）"><a href="#rdt-3-0（经具有比特差错的丢包信道的可靠数据传输）" class="headerlink" title="rdt 3.0（经具有比特差错的丢包信道的可靠数据传输）"></a>rdt 3.0（经具有比特差错的丢包信道的可靠数据传输）</h4><p>现在假设底层信道除了比特会出差错，还假设会丢包。</p><p>引入超时重传机制，以解决丢包问题。</p><p>但是有可能只是网络塞车，并不是丢包，这个时候导致冗余数据分组；但是因为我们有序列号，所以可以解决这个问题。</p><p>也称为<strong>比特交替协议</strong>。</p><p>下面展示rdt 3.0在无丢包操作、分组丢失、ACK丢失、过早超时四种情况下的运行流程：</p>  <h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>rdt 1.0：完全正常</li><li>rdt 2.0：可能会出比特差错<ul><li>引入 ACK&#x2F;NAK 控制报文，重传机制，序号。</li></ul></li><li>rdt 3.0：可能会丢包<ul><li>引入超时重传机制。</li></ul></li></ul><p>重传是无敌的！！</p><h4 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h4><p>因为 rdt 3.0 是一个停等协议，即发送方发送完包之后需要等待接收方的响应控制报文。</p><p>这个效率是非常慢的，考虑已知链路带宽R为1Gbps，端到端传播延时T为15ms，分组大小L为1kB。</p><p>传输延时为：$$8us$$。</p><p>往返传播延时RTT为：$$30ms$$。</p><p>利用率为：$$\frac{8us}{30ms+8us}$$   十分的低效！！</p> <p>所以考虑流水线：<strong>允许发送方发送多个分组而无需等待确认</strong>。</p><p>但是必须满足：</p><ul><li>增加序号范围：每个运输中的分组和多个在传输中的未确认报文。</li><li>发送方和接收方需要缓存分组：发送方需要缓存发送但是没有确认的分组，接收方需要缓存已正确接收但是还没有处理的分组。</li></ul> <p>对于流水线的差错恢复，可以用<strong>回退N步</strong>和<strong>选择重传</strong>进行解决。</p><h4 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h4><p>设定流水线中未确认的分组数不能超过 N。</p><p>N 也被称为窗口长度，GBN也被称为滑动窗口协议。</p> <p>简单来说，就是将 N 个未确认分组看成一个整体（窗口），如果其中一个包丢失了，则整个窗口的包重传。</p><p>使用<strong>累计确认</strong>，即假设发送方接收到对序号为 n 的分组的确认，则表明接收方已正确接收到序号为 n 和 n 以前的包。</p><p>下图为 N 为4的一个情况。</p> <h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>刚刚的 回退N步 有个很明显的问题，就是假设只有一个包出错了，但是却需要重传全部窗口内的分组。</p><p><strong>选择重传的基本思想是只重传可能出错的包。</strong></p> <p>接收方将确认一个正确接收的分组而不管它是不是按序的（先放到缓存）。</p><p>在图 3.26 中接收方初始缓存了分组3 4 5，最后接收到分组 2 之后再一并上传给上层。</p> <p><strong>需要限制窗口长度小于等于序号空间的一半！！</strong></p> <h3 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h3><p>TCP是<strong>面向连接</strong>的，这是因为两个应用进程发送数据之前，必须先进行<strong>握手</strong>。</p><p>TCP是<strong>点对点</strong>的，因为<strong>单个发送方</strong>和<strong>单个接收方</strong>。</p><p>TCP是<strong>全双工</strong>的，因为建立连接之后数据可以<strong>从任意一方流向另一方</strong>。</p><p>TCP是<strong>流水线协议</strong>，有<strong>拥塞控制</strong>和<strong>接收窗口大小</strong>。</p><h4 id="TCP数据传输流程"><a href="#TCP数据传输流程" class="headerlink" title="TCP数据传输流程"></a>TCP数据传输流程</h4> <ul><li>进程将数据给 TCP 套接字后，TCP 将数据引导至发送缓存。</li><li>TCP 会在合适的时间点从发送缓存中取出数据，加上TCP头部，并传递给网络层。<ul><li>因数据链路层最大传输单元为1500字节，TCP头部和IP头部各需要20个字节，所以最多可取出1460字节的数据。</li></ul></li><li>TCP 的另一端接收该报文段后，应用程序从接收缓存中读取数据。</li></ul><h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4><p>TCP报文段由首部字段（<strong>20字节</strong>）和一个数据字段组成：</p> <p><strong>源端口号（16位）和目标端口号（16位）</strong>：</p><ul><li><strong>源端口号</strong>：表示发送数据的进程的端口号，用于标识发送方的应用。</li><li><strong>目标端口号</strong>：表示接收数据的进程的端口号，用于标识接收方的应用。</li><li>这两个字段共同完成了端到端的通信连接。</li></ul><p><strong>序号（32位）</strong>：</p><ul><li>用于标识数据字节流中的每一个字节的位置。</li><li>在连接建立时，初始序列号（ISN）是随机生成的，后续每发送一个字节，序号会递增。</li></ul><p><strong>确认号（32位）</strong>：</p><ul><li>用于确认接收到的数据，表示期望收到的下一个字节的序列号。</li><li>例如，如果接收到的最后一个字节的序列号是 100，那么确认号会是 101。</li><li>只有当 ACK 标志位被设置时，确认号字段才有效。</li></ul><p><strong>窗口大小（16位）</strong>：</p><ul><li>用于流量控制，表示接收端当前能够接收的最大字节数。</li></ul><p><strong>标志位（6位，常用位如下）</strong>：</p><ul><li><strong>URG</strong>（紧急标志）：标志该段包含紧急数据，通常不使用。</li><li><strong>ACK</strong>（确认标志）：标志确认号字段有效。</li><li><strong>PSH</strong>（推送标志）：表示要求接收方立即将数据交付给应用层。</li><li><strong>RST</strong>（重置标志）：用于重置连接。</li><li><strong>SYN</strong>（同步标志）：用于建立连接。</li><li><strong>FIN</strong>（终止标志）：用于断开连接。</li></ul><h5 id="TCP序列号和确认号"><a href="#TCP序列号和确认号" class="headerlink" title="TCP序列号和确认号"></a>TCP序列号和确认号</h5><p>最重要的两个部分：<strong>序列号</strong>、<strong>确认号</strong>。</p><p>TCP 将数据看成一种字节流，所以序列号和确认号是基于字节上定义的，而不是按照报文段的序列。</p><p><strong>TCP序号表示的是当前报文段数据部分第一个字节的序号</strong>，序列号用于跟踪数据流的顺序和确保数据包的完整性，接收方通过序列号来重新排序数据包，以便正确重组原始数据流。</p><p><strong>确认号表示期望收到的下一部分数据的首字节序号</strong>，代表确认号之前的数据（不包括确认号本身）已被成功接受。(累计确认)</p><p>如下图，第一个报文段的序号为0，第二个报文的序列号为1000…</p>  <h4 id="TCP往返时间的估计与超时（感觉不是重点）"><a href="#TCP往返时间的估计与超时（感觉不是重点）" class="headerlink" title="TCP往返时间的估计与超时（感觉不是重点）"></a>TCP往返时间的估计与超时（感觉不是重点）</h4><p>假设你有一个估计RTT的值，并且还有一个测量RTT跟估计RTT的偏离程度的值：偏离RTT。</p><p>一般TCP设置超时时间为 估计RTT + 4 * 偏离RTT。</p><h4 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h4><p>TCP在IP不可靠的尽力而为服务之上创建了一种<strong>可靠数据传输服务</strong>。</p><p>TCP的可靠数据传输是一种流水线协议，是GBN和SR两种协议的混合体。</p><ul><li><p>TCP采用累计确认（类GBN）</p></li><li><p>TCP使用单个重传计时器（类GBN）</p><p>这个重传计时器与最早的未被确认的报文段相关联</p></li><li><p>TCP触发超时重传时只重发那个最早的未确认的段（类SR）</p></li></ul><h5 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h5><p>每当有超时事件发生，TCP只重传当前未被确认的最小序号的报文段，然后<strong>设置超时间隔为先前值的两倍</strong>，而不是刚刚的用估计RTT和偏移RTT所计算的值。</p><p>这是因为发生超时事件，意味着网络很堵塞，所以超时时间长点。</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>接收方接收到报文段后，发出ACK有四种情况：</p> <p>我只分析第一和第三种情况：</p><ul><li>当接收方接收到期望序号的报文后，选择等500ms再发送ACK，这是因为假设下个期望序号的报文若此时到达，则只需要发送一次ACK（TCP是累计确认）。</li><li>发送ACK的序号为当前的期望序号。</li></ul><p>当发送方根据上面的第三种情况连续收到三次冗余ACK，则意识到这个冗余ACK的期望序号的报文没有成功到达，所以<strong>立即重传</strong>。 </p> <h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>主要考虑的是发送端和接收端的速率差太大，即发送方发的很快，但是接收方处理的很慢，并且接收方缓存会慢慢变满。</p><p><strong>流量控制服务可以消除接收方缓存溢出的可能。</strong></p><p>TCP 让发送方维护一个<strong>接收窗口</strong>的变量来控制流量，接收窗口可以用来给发送方一个指示–接收方还有多少可用的缓存空间。</p><p>这个变量就是TCP头部的窗口大小值。</p><p>发送方根据接收到的接收窗口值，调整接下来要发送的数据量。如果接收窗口值较大，发送方可以加快数据发送速率；如果接收窗口较小，发送方会减缓发送速率，甚至停止发送数据，直到接收窗口再次打开。</p><blockquote><p>若是UDP协议，若接收方在缓存中读取数据的速度不够快，则缓存会满，报文段会丢失。</p></blockquote><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>主要讲的是<strong>三次握手</strong>和<strong>四次挥手</strong>。</p><p>刚刚前面有说到，TCP是面向连接的，即发送方和接收方会先进行握手协议。</p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5> <ul><li>第一步：<strong>客户端生成 SYN 报文</strong>，将 TCP首部的SYN位置 1，随机生成一个初始序号值 X，没有任何数据内容。</li><li>第二步：<strong>服务器端返回 SYN-ACK报文</strong>，将 TCP首部的SYN位和ACK位置 1，随机生成一个初始序号值 Y，确认号为 X+1，并且为该 TCP 连接分配缓存。</li><li>第三步：<strong>客户端生成 ACK 报文</strong>，将 TCP首部的ACK位置 1，确认号为 Y+1，在客户端分配缓存。在这个时候已经可以携带数据传输了。</li></ul><p>为什么不使用二次握手呢？</p> <ul><li>因为可能服务器响应不够快，客户端直接重传了。</li></ul><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5> <ul><li>第一步：<strong>客户端生成 FIN 报文</strong>，将 TCP首部的FIN位置 1，随机生成一个初始序号值 X，没有任何数据内容。</li><li>第二步：<strong>服务端生成 ACK 报文</strong>，将 TCP首部的ACK位置 1，确认号为 X+1。</li><li>第三步：<strong>服务端生成 FIN 报文</strong>，将 TCP首部的FIN位置 1，随机生成一个初始序号值 Y，没有任何数据内容。</li><li>第四步：<strong>客户端生成 ACK 报文</strong>，将 TCP首部的ACK位置 1，确认号为 Y+1。</li></ul><blockquote><p>需要记得FIN报文和SYN报文是会占据序列号的，ACK报文不会。</p></blockquote><h4 id="TCP拥塞管理"><a href="#TCP拥塞管理" class="headerlink" title="TCP拥塞管理"></a>TCP拥塞管理</h4><p>需要在发送方增加多一个变量–拥塞窗口值。</p><blockquote><p>拥塞窗口是<strong>发送方维护的变量</strong>，表示网络当前能够安全传输的数据量上限。</p><p>接收窗口是<strong>接收方维护的变量</strong>，表示接收方当前能够接收并缓存的数据量上限。</p></blockquote><p>拥塞窗口对一个TCP发送方能向网络中发送流量的速率进行了限制，在一个发送方中未被确认的数据量不会超过cwnd与rwnd中的最小值。<br>$$<br>\text{LastByteSent} - \text{LastByteAcked} \leq \min{\text{cwnd}, \text{rwnd}}<br>$$<br>在每个往返时间RTT的起始点，允许发送方向该连接发送cwnd个字节的数据，在该RTT结束时发送方接收对数据的确认报文。因此发送方发送的数据大概为<strong>cwnd&#x2F;RTT</strong> 字节&#x2F;秒。可以调整cwnd的值来控制发送方速率。</p><blockquote><p>这里主要考虑拥塞管理，所以假设接收窗口为无穷大。</p></blockquote><p>TCP发送方定义的<strong>丢包事件</strong>为：</p><ul><li>超时。</li><li>收到三个冗余ACK报文。</li></ul><p>拥塞控制算法思想：当TCP发生丢包事件，就减少cwnd的值；如果接收到ACK，就增加cwnd的值（ACK意味着一切安好）。</p><h5 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h5><ol><li><p><strong>慢启动</strong></p><p>在<strong>慢启动</strong> 阶段，cwnd的值以一个MSS开始，并且每当传输的报文段被确认就增加一个MSS。</p><p>在这个过程中，每经过一个RTT，发送速率就会翻倍。</p> <ul><li><p><strong>若发生超时事件</strong></p><p>当出现超时情况后，TCP发送方会把cwnd的大小设置为1并重新开始慢启动过程，同时将慢启动阈值ssthresh设置为cwnd大小的一半，即ssthresh&#x3D;cwnd&#x2F;2。</p><p>后面当cwnd到达或超过慢启动阈值后，说明此时快要触碰到上限了，继续指数增长过于鲁莽，因此会结束慢启动阶段，进入拥塞避免阶段。</p><p>在拥塞避免阶段，cwnd线性增长。当再次发生超时事件，发送方会更新慢启动阈值，将其设置为当前cwnd大小的一半，然后把cwnd的大小设置为1重新开始慢启动，以此类推。</p></li><li><p><strong>若接收到三个冗余ACK</strong></p><p>因为这个情况没有<strong>超时</strong>这么严重，会将慢启动阈值设置为cwnd大小的一半，然后进入快速恢复阶段。</p></li></ul></li><li><p><strong>拥塞避免</strong></p><p>一旦进入了拥塞控制阶段，cwnd的值大约是上次遇到拥塞时值的一半，说明距离拥塞已经不远。</p><p>TCP选择采用了一种更保守的方式，即每个RTT只将cwnd增加一个MSS。</p><ul><li><p><strong>若发生超时事件</strong></p><p>若触发超时，会更新慢启动阈值并进入慢启动阶段。</p></li><li><p><strong>若接收到三个冗余ACK</strong></p><p>更新慢启动阈值为cwnd的一半并且将cwnd设置为cwnd&#x2F;2 + 3，进入快速恢复状态。</p></li></ul></li><li><p><strong>快速回复</strong></p><p>分成早期版本TCP Tahoe和新版本TCP Reno。</p><ul><li><p><strong>TCP Tahoe</strong></p><p>将收到三个冗余ACK的事件跟超时事件处理一样，将cwnd设置为1，阈值为cwnd一半，并进入慢启动阶段。</p></li><li><p><strong>TCP Reno</strong></p><p>将cwnd设置为cwnd&#x2F;2 + 3，阈值为cwnd一半，继续拥塞避免阶段。</p></li></ul></li></ol><h5 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h5><p>TCP拥塞控制算法是<strong>加性增，乘性减</strong>的。</p> <p>假设 W 为拥塞窗口极限大小，每次cwnd的值一到达W就会发生三次冗余ACK。</p><p>TCP的发送速率在0.5*W&#x2F;RTT 和W&#x2F;RTT 反复横跳。</p><p>最终：<br>$$<br>一条连接的平均吞吐量 &#x3D; \frac{0.75*w}{RTT}<br>$$</p><h4 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h4><p>如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R&#x2F;K，我们将TCP的这种特点称之为<strong>TCP的公平性</strong>。</p> <ul><li><p>我们首先假设两条连接最开始的状态位于A点，此时连接1的吞吐量大于连接2，由于A点位于RR的下方，说明两条连接都处于拥塞控制状态（忽略慢启动）。</p></li><li><p>此时每过一个RTT，两条连接的cwnd都会加一，也就是说此时的状态会由A点45度向右上角移动。</p></li><li><p>当到达B点后，由于B点位于RR上方，超过了带宽的承受能力，两条连接的吞吐量都会回退到原本来的一半（依旧忽略慢启动）。</p></li><li><p>因为连接1的吞吐量比较大，减半后减少的吞吐量会更多，所以会退到C点，然后继续进入拥塞控制状态慢慢移动到D点。</p></li><li><p>以此类推，最终会收敛到两条连接的吞吐量相等的位置。</p></li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li>  </li><li><p>TCP的流量控制主要是防止发送方发送的数据量超过接收方的处理能力，避免接收端的缓冲区溢出。</p><p>而拥塞控制是防止发送方过快地向网络中注入数据，避免造成网络拥塞。</p></li></ul><h2 id="第四章-网络层（数据平面）"><a href="#第四章-网络层（数据平面）" class="headerlink" title="第四章 网络层（数据平面）"></a>第四章 网络层（数据平面）</h2><p>为<strong>主机和主机</strong>之间提供了逻辑通信。</p><p>网络层提供的功能其实就是<strong>转发</strong>和<strong>路由选择</strong>。</p><ul><li>转发（做搬运工）：将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。</li><li>路由选择：指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。计算路径的算法叫<strong>路由选择算法</strong>，在网络中交换路由信息的通信协议被称为<strong>路由选择协议</strong>。</li></ul><p>网络层可以分解成<strong>数据平面（转发）</strong>和<strong>控制平面（路由选择）</strong>。</p><h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><p>目的是实现<strong>转发</strong>功能。</p><p>每个路由器都有一个<strong>转发表</strong>。</p><p>传统：<strong>基于目标地址 + 转发表</strong></p><ul><li>路由器会检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方法来转发分组。</li></ul><p>SDN 方法：<strong>基于多个字段 + 流表</strong></p><ul><li>传统方法只使用目标地址进行转发，SDN 方法利用了更多信息（如源IP地址和目的IP地址）。</li><li>SDN 中流表指分组交换机中用于转发的表（即记录流转发方式的表）。SDN使用流表取代传统路由器中的转发表。</li></ul><h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>目的是<strong>决定数据报从源到目标主机之间的端到端路径</strong>。</p><p>传统：<strong>分布式计算转发表</strong></p><ul><li>路由选择算法运行在每台路由器中，并且在<strong>每台路由器中都包含转发和路由选择两种功能</strong>。</li><li>一台路由器中的路由选择算法与其他路由器中的路由选择算法通信，以计算出它的转发表的值。</li></ul><p>SDN方法：<strong>集中计算流表</strong></p><ul><li>SDN 方式下控制平面路由选择功能与物理的路由器是分离的，即<strong>路由器选择设备仅执行转发</strong>，而远程控制器计算并分发流表。</li><li>SDN 允许网络管理员在不手动处理网络硬件设备的前提下，使用集中化程序重新规划网络，控制复杂网络拓扑以及网络流量。<strong>将传统的分布式规则计算演变为集中计算</strong>。</li></ul><blockquote><p>SDN 方法了解即可。</p></blockquote><p>网络层提供了单一的服务，称为<strong>尽力而为服务</strong>。</p><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>路由器由四个组件组成：输入端口、输出端口、交换结构、路由选择处理器。</p> <ul><li><p>上方为控制平面，负责路由：运行路由选择算法&#x2F;协议（RIP、OSPF、BGP） - 生成路由表。</p></li><li><p>下方为数据平面，负责转发：从输入到输出链路交换数据报 - 根据路由表进行分组的转发。</p></li></ul><h4 id="输入端口处理和基于目的地转发"><a href="#输入端口处理和基于目的地转发" class="headerlink" title="输入端口处理和基于目的地转发"></a>输入端口处理和基于目的地转发</h4><p>流程：数据链路的帧进入到通信链路输入端口，将帧拆封，在路由器内进行查找（按照转发表选择对应的输出端口）、转发、排队（等待将IP数据包传输到输出端口）。</p><h5 id="最长前缀匹配（必考）"><a href="#最长前缀匹配（必考）" class="headerlink" title="最长前缀匹配（必考）"></a>最长前缀匹配（必考）</h5><p>在基于目的地转发模式下，我们使用<strong>最长前缀匹配规则</strong> 来查找路由。</p><p>路由器使用分组目的地址（IP）的前缀与路由表中的表项进行匹配。</p><p>当有多个匹配时，在该表中寻找最大的匹配项。</p> <p>例如 11001000 00010111 0011000 11111111，则同时匹配第二项和第三项，根据最长前缀匹配规则，转发至链路接口2。</p><h5 id="输入端口缓存"><a href="#输入端口缓存" class="headerlink" title="输入端口缓存"></a>输入端口缓存</h5><p>如果来自其他输入端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被阻塞，所以需要存放在输入端口缓存。</p><h4 id="交换-1"><a href="#交换-1" class="headerlink" title="交换"></a>交换</h4><p>交换结构位于一台路由器的核心部位。</p><p>有三种方式实现：内存、总线、互联网。</p> <ul><li><p><strong>内存</strong></p><p>该交换结构下，输入端口与输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。</p><p>在这种情况下，如果内存带宽为每秒可写进内存或从内存读出最多B个分组，则总的转发吞吐量（分组从输入端口被传送带输出端口的总速率）必然小于B&#x2F;2，因为每个数据包需要写入和读出这两次操作。</p><p>一次只能转发一个分组。</p></li><li><p><strong>总线</strong></p><p>该交换结构下，数据报通过共享总线，从输入端口转发到输出端口。</p><p>如果多个分组同时到达路由器，每个位于不同的输出端口，除了一个分组外所有其他分组必须等待，<strong>因为一次只有一个分组能够跨越总线</strong>。</p><p>因为每个分组必须跨过单一总线，故路由器的交换带宽受总线速率的限制；</p></li><li><p><strong>互联网</strong></p><p><strong>该交换结构下，同时并发转发多个分组</strong>，克服单一、共享式总线带宽限制。</p><p>纵横式网络能够并行转发多个分组。例如当分组达到端口A，需要转发到端口Y时，交换机控制器闭合总线A和Y交叉部位的的交叉点，然后端口A在其总线上发送该分组，该分组仅由总线Y接收。</p><p>而来自端口B的一个分组在同一时间能够转发到端口X，因为A到Y和B到X的分组使用不同的输入和输出总线。</p></li></ul><h4 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h4> <p>与输入端口对应，输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。</p><blockquote><p>缓存并不是越大越好，虽然更大的缓存可以降低路由器的分组丢失率，但是意味着更长的排队时延！！</p></blockquote><h4 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h4><p>这里跟操作系统的原理一样，我就不细写了。</p><ul><li><p><strong>先进先出（FIFO）</strong></p> </li><li><p><strong>优先权排队</strong></p> <p>在<strong>非抢占式优先权排队</strong> 规则下，一旦分组开始传输，就不能打断。例如在下面的这个过程中，分组1、3和4属于高优先权类，分组2和5属于低优先权类。分组4到达时，分组2正在传输中，分组4不会将其打断，而是排队等待传输，等其传输完成后开始传输。</p> </li><li><p><strong>循环排队</strong></p><p>传输完类1的一个分组后，开始传输类2的一个分组，然后是类3，以此类推，最后循环到类1。</p><p>分组1 2 4属于第一类，分组3 5属于第二类。</p> </li><li><p><strong>加权平均排队</strong></p> <p>在<strong>加权公平排队</strong> 规则下，分组会被分到不同的类，WFQ调度器也以循环的方式为各个类提供服务。但是由于每个类在任何时间间隔内可能收到不同数量的分组，因此每个类都会被分配一个权w，每一个类在一个循环中获得不同权重的服务量。</p><blockquote><p>每个队列得到的服务时间并不是严格按照权重比例的，因为它不会打断一个分组的传输来开始传输另一个分组。</p></blockquote></li></ul><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h3><h4 id="IPV4-数据包格式"><a href="#IPV4-数据包格式" class="headerlink" title="IPV4 数据包格式"></a>IPV4 数据包格式</h4> <ul><li><strong>版本：</strong>占4比特，指ip协议版本号，ipv4分组中此处应为4。</li><li><strong>首部长度：</strong>占4比特，表示ip首部的长度，以4字节为单位，最小值为5（即20字节）。</li><li><strong>服务类型</strong>：占8比特，用于指定服务质量需求，如延迟、吞吐量和可靠性。</li><li><strong>数据报总长度：</strong>占16比特，表示整个ip数据报（包括首部和数据）的总长度，单位是字节，最大值为65535字节。</li><li><strong>标识：</strong>占16比特，用于唯一标识每个ip数据报，在分片传输时帮助分片重组。</li><li><strong>标志：</strong>占3比特，用于控制数据报的分片行为，包括是否允许分片（df）和是否有更多分片（mf）。</li><li><strong>片偏移：</strong>占13比特，用于指示当前分片在原始数据报中的相对位置，单位是8字节。</li><li><strong>生存时间</strong>：占8比特，表示数据报的最大生存周期，<strong>每经过一个路由器减1，防止数据报在网络中无限循环。</strong></li><li><strong>上层协议</strong>：占8比特，表示数据报承载的上层协议类型，例如tcp（值为6）或udp（值为17）。</li><li><strong>首部校验和：</strong>占16比特，用于检测ip首部在传输过程中是否损坏，不校验数据部分。</li><li><strong>源ip地址：</strong>占32比特，表示数据报的发送方ip地址。</li><li><strong>目标ip地址：</strong>占32比特，表示数据报的接收方ip地址。</li><li><strong>选项：</strong>可变长度，用于携带额外控制信息，例如路由记录或时间戳，不是必选字段。</li><li><strong>数据部分：</strong>可变长度，承载实际应用层或传输层的数据内容，其长度等于数据报总长度减去首部长度。</li></ul><p><strong>要记得IP头部至少为20字节！</strong>TCP头部是20字节，UDP头部为8字节。</p><p>数据链路的帧的数据部分最大（MTU）为1500字节，<strong>如果IP数据包过大则会分片</strong>。</p><p>假设一个无分片的TCP报文封装的数据帧，至少承载了<strong>40字节的首部信息</strong>！！</p><h4 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h4><p><strong>IP地址</strong>是对主机或者路由器与网络的<strong>接口</strong>的编址，共32位。</p><p>IP地址不能唯一的识别设备，MAC地址可以。</p><h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p>一个子网内的节点（主机或者路由器）的IP地址的高位部分相同，这些节点构成的网络的一部分叫做<strong>子网</strong>，IP地址的<strong>高位表示子网部分</strong>，<strong>低位表示主机部分</strong>。</p><p>子网内的各主机之间通信无需路由器能直接连通，因为数据链路层连通。</p> <p>例如为左边的子网分配地址223.1.1.0&#x2F;24，其中的&#x2F;24就是<strong>掩码</strong>，意味着前24个比特组成了子网地址。</p><p>划分子网时，将每一个接口从主机或路由器上分开，构成一个个网络的孤岛，每一个孤岛都可称之为子网。以下图为例，将其划分为6个子网，因为每个路由器之间的网络也是一个子网。</p> <h4 id="IP地址分配"><a href="#IP地址分配" class="headerlink" title="IP地址分配"></a>IP地址分配</h4><p><strong>分类编址：</strong>将IP地址分成A B C三类，三类的网络部分比特分别为8 16 24。</p><p>CIDR编址：就是我们现在用的方法，将IP地址用a.b.c.d&#x2F;x来分类。</p><h4 id="获取IP地址"><a href="#获取IP地址" class="headerlink" title="获取IP地址"></a>获取IP地址</h4><p>可以从一个大子网（主机比特更多）拆分成多个小子网（主机比特更少）。</p> <p>将一个 ISP 拆分成了8个子 ISP。可以观察主机部分的比特，原本为12位，拆分之后变成9位，即每个小子网的主机数量是原本子网的1&#x2F;8。</p><p>要记得IP地址全0和全1都是保留的，不可以使用！</p><ul><li>全1是广播地址。</li></ul><h5 id="DHCP（动态主机配置协议）重要"><a href="#DHCP（动态主机配置协议）重要" class="headerlink" title="DHCP（动态主机配置协议）重要"></a>DHCP（动态主机配置协议）重要</h5><p>DHCP允许主机自动获得一个IP地址。</p><p>使用UDP作为传输层。</p><p>DHCP是应用层协议。</p><p>除了为主机发送IP地址之外，<strong>还会发送网关IP，DNS服务器IP</strong>。</p>  <p>DHCP一共有四个流程：DHCP发现、DHCP提供、DHCP请求、DHCP ACK：</p><ol><li><p><strong>DHCP服务器发现</strong>：新接入网络的主机会尝试获取 IP 地址，它会向网络发送一个<strong>DHCP发现报文</strong>。该报文是广播报文，<strong>目的是寻找网络中可用的 DHCP 服务器</strong>。</p><p>由于主机在初始阶段还没有 IP 地址，所以报文是从源 IP <code>0.0.0.0</code> 广播到目的 IP <code>255.255.255.255</code>。</p><p>这个过程使 DHCP 服务器得知有新设备需要分配 IP 地址。</p></li><li><p><strong>DHCP服务器提供</strong>：DHCP服务器收到一个DHCP发现报文时，会从其可用的 IP 地址池中选取一个地址，并用<strong>DHCP提供报文</strong>向客户做出回应，告知主机它可以使用这个 IP 地址，该报文依旧使用IP广播地址<code>255.255.255.255</code>。</p></li><li><p><strong>DHCP请求</strong>：新到达的客户从一个或多个服务器提供中选择一个，并向其发送<strong>DHCP请求报文</strong>，来告知 DHCP 服务器它选择了哪个提供的 IP 地址。</p></li><li><p><strong>DHCP ACK</strong>：当 DHCP 服务器收到主机的请求报文后，会发送一个<strong>DHCP确认报文</strong>给主机，告知其正式使用提供的 IP 地址及配置信息。</p></li></ol><blockquote><p>一直都将目的IP设为广播。</p></blockquote><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>将家庭中的私有地址和公网地址进行映射。</p><p>可以实现一块局域网内部的设备公共一个IP地址，而不需要从ISP分配一块地址。</p> <p>主要是通过NAT路由器的NAT转换表工作！</p><p>流程如下：</p><ol><li><p>主机<code>10.0.0.1</code>向<code>128.119.40.186</code>，80号端口发送数据报，该数据报的源地址为<code>10.0.0.1</code>，3345号端口，目标地址为<code>128.119.40.186</code>，80号端口。</p></li><li><p>该数据报到达NAT路由器后，路由器将其源地址修改为此内网公用的IP地址，并选一个没有被占用的端口号来代表该内网主机，此时数据报的源地址为<code>138.76.29.7</code>，5001号端口。</p></li><li><p>然后将这种映射关系记录在NAT转换表中。</p></li><li><p>当NAT路由器收到广域网返回的响应数据报时，该数据报的目标地址为<code>138.76.29.7</code>，5001号端口。NAT路由器查找表项后发现，5001号端口对应的是内网的<code>10.0.0.1</code>，3345号端口。</p></li><li><p>于是将数据报中的目标地址修改为<code>10.0.0.1</code>，3345号端口后，发送给对应内网主机。</p></li></ol><p><strong>广域网返回的响应经过NAT路由器更改了目的IP和目的端口！！</strong></p><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>因为IPV4的32位地址即将用完，所以开发了IPV6，IPV6有128位地址。</p><p>IPV6没有分片功能，因为这会增加路由器的工作，不符合复杂事情都在网络边缘干的设计思想。</p><h4 id="IPV6数据包格式"><a href="#IPV6数据包格式" class="headerlink" title="IPV6数据包格式"></a>IPV6数据包格式</h4> <ul><li><p><strong>版本</strong>：占4比特，用于表示IP版本号，这里毫不意外地将值设置为6。</p></li><li><p><strong>流量类型</strong>：占8比特，相当于IPv4的服务类型字段，用于区分优先级。</p></li><li><p><strong>流标签</strong>：占20比特。可以理解为同一个IP发出来的属于同一个会话的数据，可以为其打上同样的一个流标签，试图让网络对同一个流的数据做出同样的处理。</p></li><li><p><strong>有效载荷长度</strong>：占16比特，该值作为一个无符号整数，给出了IPv6数据报中在定长的40字节数据报首部后面的字节数量。</p></li><li><p><strong>下一个首部</strong>：占8比特，标识数据报中的内容需要交付给哪个协议（如TCP或UDP），使用与IPv4首部中协议字段相同的值。</p></li><li><p><strong>跳限制</strong>：占8比特，转发数据报的每台路由器将对该字段的内容减1，如果跳限制计数达到了0，则该数据报将被丢弃。</p></li></ul><p>IPV6头部占了40字节（源地址目的地址一共占了32字节）！</p><p>对比IPV4头部内容更加简化了。</p><h4 id="IPV4到IPV6的迁移"><a href="#IPV4到IPV6的迁移" class="headerlink" title="IPV4到IPV6的迁移"></a>IPV4到IPV6的迁移</h4><p>通过<strong>隧道</strong>实现，实际上还是一种抽象。</p> <p>假定两个IPV6节点是依靠IPV4路由器互联的，将依靠的IPV4路由器的集合成为<strong>隧道</strong>。</p><p>在上图中，B和E路由器是同时支持IPv4和IPv6的。</p><p>流程如下：</p><ol><li>借助于隧道，在隧道发送端的IPv6节点可将整个IPv6数据报放到一个IPv4数据报的数据字段中，进行运输。（IPv6此时很像传输层协议）。</li><li>隧道接收端的IPv6节点最后收到该IPv4数据报，并确定其包含一个完整的IPv6数据报（通过观察IPv4数据报中的协议号字段是41）后，从中取出IPv6数据报，继续为其进行路由。</li></ol><h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>这里我就简单的描述概念。</p><p>主要思想是因为传统的路由选择算法是只依靠<strong>目的IP</strong>这个单一的信息进行计算，并且是每个路由器自己<strong>独立</strong>、<strong>分布式计算</strong>的，而我们想利用<strong>更多的信息</strong>（例如源IP和传输层源端口和目的端口）来进行路由，并且希望是由一个远程控制器来计算路由，路由器只负责转发。</p><ul><li><p><strong>更多的信息</strong>也被称为流。</p></li><li><p>实现了控制平面和数据平面的分离，传统的方法路由器需要计算转发表（路由）和进行转发。</p></li></ul><h2 id="第五章-网络层（控制平面）"><a href="#第五章-网络层（控制平面）" class="headerlink" title="第五章 网络层（控制平面）"></a>第五章 网络层（控制平面）</h2><p>本章的目标是学习路由器中的<strong>转发表</strong>和<strong>流表</strong>是如何计算的。</p><p>完成这个工作有两种实现方法：</p><ul><li><p><strong>每路由器控制：</strong></p><p>在每台路由器中运行一种路由选择算法，每台路由器都包含转发和路由选择功能（即数据平面和控制平面没有独立）。</p><p>路由器之间会进行通信。</p> </li><li><p><strong>逻辑集中式控制：</strong></p><p>控制器计算并分发转发表给每一台路由器，每一台路由器都只负责转发功能（实现数据平面和控制平面的独立）。</p><p>路由器之间不会进行通信。</p></li></ul><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>目的是从发送方到接收方的过程中找到一条<strong>具有最低开销</strong>的路径。</p><p>路由选择算法可以根据输入分为<strong>集中式路由选择算法</strong> 和 <strong>分散式路由选择算法</strong>。</p><ul><li><strong>集中式路由选择算法</strong>：所有的路由都拥有完整的全局拓扑信息，这样的算法被称作<strong>链路状态算法</strong>。</li><li><strong>分散式路由选择算法</strong>：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径，这样的算法被称为<strong>距离向量算法</strong>。</li></ul><p>路由选择算法也可以根据算法是静态的还是动态的进行分类：</p><ul><li><strong>静态路由选择算法</strong>： 路由随时间的变化非常缓慢，通常是人工进行调整；</li><li><strong>动态路由选择算法</strong> ：会随着网络流量负载或拓扑发生变化而改变路由选择路径。</li></ul><h4 id="链路状态路由选择算法-LS"><a href="#链路状态路由选择算法-LS" class="headerlink" title="链路状态路由选择算法 LS"></a>链路状态路由选择算法 LS</h4><p>因为输入就是全局拓扑（代价），每个路由器使用 Dijkstra 算法来计算自己到每个节点的最小代价，计算自己的路由表。</p> <p>对上图的 u 节点进行 Dijkstra 算法如下，详细这里就不写了。 </p><h4 id="路由选择的振荡"><a href="#路由选择的振荡" class="headerlink" title="路由选择的振荡"></a>路由选择的振荡</h4><p>每次执行一次LS算法，最短路都会发生改变。（这个有点太细了）</p><h4 id="距离向量路由选择算法-DV"><a href="#距离向量路由选择算法-DV" class="headerlink" title="距离向量路由选择算法 DV"></a>距离向量路由选择算法 DV</h4><p>每个节点维护一张路由表，跟邻居交换路由表，根据交换后的信息，计算最低代价并且更新自己的路由表。</p><p>计算最低代价与 Bellman-Ford 方程相关：<br>$$<br>d_x(y) &#x3D; \min_v { c(x, v) + d_v(y) }<br>$$<br>下图有一个书本的例子：</p> <p>DV算法流程：</p><ol><li>一开始每个路由器的路由表只有自己到自己邻居的代价。</li><li>跟邻居互相交换信息（传送自己的距离向量给邻居），并将邻居的信息加入路由表并计算自己的距离向量。</li><li>如果自己的距离向量因为邻居的信息而变小，将更新后的距离向量发给邻居。<strong>只有在自己的最低开销改变，才会发送距离向量给邻居！！</strong></li><li>直到无更新为止。</li></ol><h4 id="链路开销改变"><a href="#链路开销改变" class="headerlink" title="链路开销改变"></a>链路开销改变</h4> <p>情况 a：</p><ul><li>t0时刻：y发现链路状态更新，更新其距离向量，并发送给邻居。</li><li>t1时刻：z发现到x的最小代价减少，更新其距离向量，并发送给邻居。</li><li>t2时刻：y收到z的更新，但y自己的最低代价没有改变，所以算法停止。</li></ul><p>情况 b：</p><ul><li>t0时刻：y发现链路状态更新，更新其距离向量到x的距离有6（因为它知道z可以以代价5到达x），发送给邻居。</li><li>t1时刻：z收到y的更新，并更新其距离向量到达x的距离为7（因为z直连到x需要50，但y到x只需要代价6）。</li><li>t2时刻：y收到z的更新，并将自己的距离向量改为到x的距离为8…</li><li>t3时刻：z收到y的更新，并将自己的距离向量改为到x的距离为9…</li><li>…</li><li>直到当z经由y到x的距离大于50（一共需要44次迭代！！）</li></ul><p>这个问题就是<strong>路由选择环路</strong>。</p><p>解决方法就是<strong>增加毒性逆转</strong>，即类似<strong>z通过y到达x</strong>，则<strong>z告诉y自己是没有直连到x的</strong>。</p><h4 id="LS和DV路由选择算法的比较"><a href="#LS和DV路由选择算法的比较" class="headerlink" title="LS和DV路由选择算法的比较"></a>LS和DV路由选择算法的比较</h4><p>LS算法是<strong>全局</strong>性的，DV算法是<strong>分布式</strong>的、<strong>局部</strong>的。</p><ul><li>报文复杂性：LS更复杂，因为要有全局信息。</li><li>收敛速度：LS收敛更快，DV可能遇到路由选择环路。</li><li>健壮性：LS健壮性更好。</li></ul><h3 id="自治系统内部的路由选择（必考）"><a href="#自治系统内部的路由选择（必考）" class="headerlink" title="自治系统内部的路由选择（必考）"></a>自治系统内部的路由选择（必考）</h3><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p>自治系统通常由一组处在<strong>相同管理控制下的路由器</strong>组成。</p><p>在相同AS中的路由器都运行<strong>相同的路由选择算法</strong>并且<strong>拥有彼此的信息</strong>。</p><p>在一个自治系统内部运行的路由选择算法叫做<strong>自治系统内部路由选择协议</strong>。</p><p><strong>下面的两个算法都是iBGP</strong>。</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>其实书本上没有RIP，但我怕考到就RIP了，所以还是简单的写一下。</p><p>RIP是一种<strong>基于距离向量的路由选择协议</strong>，RIP以 <strong>跳数</strong> 作为代价，每经过一个路由器就加一。RIP允许一条路径最多只能包含15个路由器，距离16相当于不可达，每个DV通告最多可以包含 25 个目标网络。因此RIP只适用于小型互联网。</p><h4 id="OSPF（必考）"><a href="#OSPF（必考）" class="headerlink" title="OSPF（必考）"></a>OSPF（必考）</h4><p>基于<strong>链路状态算法</strong>实现的，使用<strong>泛洪链路状态信息</strong>和 <strong>Dijkstra</strong> 最低开销路径算法。</p><p>使用OSPF时，路由器向整个自治系统内的路由器广播<strong>路由选择信息</strong>和<strong>链路状态信息</strong>。</p><p>OSPF的优点：</p><ul><li>安全</li><li>负载均衡</li></ul><p>OSPF 可以分层（<strong>一个主干区域</strong>和<strong>多个非主干区域</strong>），并且每个区域运行自己的OSPF链路状态路由选择算法。</p><p>但是主干区域一定包含本AS中<strong>所有的区域边界路由器</strong>。</p> <ul><li>区域边界路由器（area border router）负责连接多个区域，并在不同区域之间传播路由信息。</li><li>骨干路由器（backbone router）仅在骨干区域内，运行OSPF路由。</li><li>边界路由器（boundary router）用于连接其他的AS。</li></ul><p>AS中的区域间的路由器传输流程如下：</p><ul><li><p>分组先到达自己区域的区域边界路由器</p></li><li><p>通过主干区域到达目的区域的区域边界路由器</p></li><li><p>到达目的路由器</p><blockquote><p>在每个区域内的路由器都知道自己去往自己边界路由器的最短路径！</p></blockquote></li></ul><h3 id="ISP-之间的路由选择：BGP（必考）"><a href="#ISP-之间的路由选择：BGP（必考）" class="headerlink" title="ISP 之间的路由选择：BGP（必考）"></a>ISP 之间的路由选择：BGP（必考）</h3><p>刚刚分析的是AS内部的路由选择协议，现在考虑AS之间的路由选择协议。</p><p>在因特网中，所有的AS间都运行边<strong>界网关协议BGP</strong>。</p><p>BGP实际上是<strong>DV距离向量</strong>算法，但是它不只记录了代价和下一跳路由器，还记录了详细路径（AS序号的列表）。</p> <p>考虑上图：我们可以将AS间的路由器分成<strong>网关路由器</strong>和<strong>内部路由器</strong>。</p><p>还有一些简单的术语定义：</p><ul><li><strong>外部BGP（eBGP）</strong>：跨越两个AS的BCP连接。</li><li><strong>内部BGP（iBGP）</strong>：在相同AS中的两台路由器之间的BGP连接。</li></ul> <p>一个简单流程：</p><ul><li>网关路由器3a先向网关路由器2c发送一个eBGPb报文“AS3 x”，表示x存在且位于AS3中。</li><li>网关路由器2c然后向AS2中的所有其他路由器（包括网关路由器2a）发送iBGP报文“AS3 x”。网关路由器2a接下来向网关路由器1c发送一个eBGP报文“AS2 AS3 x”，报文中包括了AS序号形式的到达x的详细路径。</li><li>最后网关路由器1c使用iBGP向ASI中的所有路由器发送报文“AS2 AS3 x”。</li><li>在这个过程完成后，AS1和AS2的每个路由器都知道了x的存在并且也都知道了通往x的AS路径。</li></ul><h4 id="确定最好的路由"><a href="#确定最好的路由" class="headerlink" title="确定最好的路由"></a>确定最好的路由</h4><p>还要介绍一些BGP属性，其中两个最重要的属性是 <strong>AS-PATH</strong> 和 <strong>NEXT-HOP</strong> 。</p><ul><li><p><strong>AS-PATH</strong> 属性包含了该通告已经通过的AS列表，例如下图中，AS1到子网x有两条路，一条使用AS-PATH“AS2 AS3”，而另一条使用AS-PATH“AS3”。</p><blockquote><p>该属性还可以用来检测和防止通告环路，如果一台路由器在路径列表中看到了包含自己的AS，它将拒绝通告。</p></blockquote></li><li><p><strong>NEXT-HOP</strong> 是<strong>AS-PATH</strong> 起始的路由器接口的IP地址，例如下图中的2a和3d分别是从AS1到x的两条路径的NEXT-HOP。</p></li></ul><p>这里每条BGP路由包含3个组件：<strong>NEXT-HOP</strong>，<strong>ASPATH</strong>，<strong>目的地前缀</strong>。</p><blockquote><p>可以把每个 x 看成一个子网，目的地前缀就是子网的网络部分。</p></blockquote><h4 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h4><p>基本思想：尽可能快地将分组送出其AS，就像丢烫手的土豆一样。</p><p><strong>选择具备最小内部区域代价的网关作为往X的出口。</strong></p><p>以上图中的1b为例，如果想到达子网x，它可选的两条路径的NEXT-HOP分别为2a和3d。因为1b到达2a的最短距离为2，到达3d的最短距离为3，因此选择到达NEXT-HOP开销更小的路径“AS2 AS3”。</p><p>但是很明显，送往3d开销会小一些。</p><h4 id="路由选择算法-1"><a href="#路由选择算法-1" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><p>简单的来说，就是路由器被指定一个<strong>本地偏好值</strong>的属性，使得将分组送往本地偏好值最高的路由。</p><p>若几个路由器都有最高的本地偏好值，再利用DV向量算法来选择路由。（这里使用的距离是AS间的跳数）</p><p>最后使用热土豆路由选择算法。</p><h3 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN 控制平面"></a>SDN 控制平面</h3><p>前面已经简单介绍了。</p><p>路由控制平面实现转发表和流表的计算可以分成<strong>每路由器控制</strong>和<strong>逻辑集中控制</strong>。</p><p>SDN是逻辑集中控制的。</p><h3 id="ICMP（我觉得重点）"><a href="#ICMP（我觉得重点）" class="headerlink" title="ICMP（我觉得重点）"></a>ICMP（我觉得重点）</h3><p>ICMP中文名为因特网 控制 消息 协议。</p><p>目的是被主机和路由器用来彼此沟通网络层的信息。</p><p>因为ICMP报文是作为IP有效载荷承载的，就像TCP与UDP报文段作为IP有效载荷被承载那样，所以ICMP是<strong>运输层</strong>的（这里有歧义）。</p><p>使用UDP作为运输层协议。（所以我说有歧义）</p> <p>记得ping请求报文的类型是8编码为0。</p><p>ping响应报文的类型是0编码为0。</p><p>ttl过期报文的类型为11编码为0。</p><p><strong>tracert 原理：</strong></p><ul><li>从源主机向目的主机发出一系列具有不可达UDP端口号的报文，并且TTL从1，2，3…逐渐上升，并且对每个报文开始计时。</li><li>当路径上的路由收到该报文，并检查TTL值，发现过期，就向源主机发送ICMP（类型11编码0TTL过期）报文。</li><li>因为ICMP报文会有IP地址，这样源主机就可以得到整条路径上的路由器IP和RTT了。</li><li>当报文到达目的主机时，因为报文是具有UDP不可达端口号的，所以目的主机会向源主机发送ICMP（类型3编码3）报文，这样源主机就知道哪个是目的主机的IP了。</li></ul><p>实际上，tracert是每个TTL值发送3个分组，即10跳有30个分组！！</p><h3 id="网络管理-SNMP（了解概念）"><a href="#网络管理-SNMP（了解概念）" class="headerlink" title="网络管理 SNMP（了解概念）"></a>网络管理 SNMP（了解概念）</h3><p>简单网络管理协议 SNMP 是一个应用层协议，用于管理服务器和被管设备的网络管理代理之间。</p><blockquote><p>网络管理代理实际上是运行在被管设备的一个应用，用于跟SNMP管理服务器通信。</p></blockquote><p>SNMP 一共有两种模式，一种是请求响应，一种是陷阱报文（中断）。</p><ul><li><p><strong>请求响应</strong></p><p>SNMP管理服务器定时向网络代理发送请求（类似问你还好吗），代理再响应（类似说我很好）。</p></li><li><p><strong>陷阱报文</strong></p><p>聪明的你一定可以想到，管理服务器需要定期向网络代理发送”关怀”报文，这太麻烦了和浪费资源了。所以参考操作系统的中断概念，只有当被管设备自己出现问题的时候，网络代理才会向管理服务器发送<strong>陷阱报文</strong>，提示管理服务器要管管自己了。</p></li></ul><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><p>可以刷作业12到15题。</p><h2 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h2><p>通信链路一般分两种，分别是<strong>点对点链路</strong>和<strong>广播信道</strong>。</p><ul><li><p><strong>点对点链路</strong></p><p><strong>定义：</strong> 点对点通信链路指的是两个网络设备之间的直接连接，数据只能在这两个设备之间传输。</p><p>适用于<strong>长距离通信</strong>和<strong>企业内部两个办公室之间使用专线连接</strong>。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">设备A</span> &lt;<span class="hljs-literal">----</span><span class="hljs-comment">点对点链路</span><span class="hljs-literal">----</span>&gt; <span class="hljs-comment">设备B</span><br></code></pre></td></tr></table></figure><blockquote><p>长距离通信不适合广播信道因为可能会发生很多碰撞。</p></blockquote></li><li><p><strong>广播信道</strong></p><p><strong>定义：</strong> 广播信道通信链路指的是多个网络设备共享同一传输介质，数据在该介质上以广播方式传输，所有连接在该信道上的设备都能接收传输的数据。</p><p>适用于<strong>以太网</strong>和<strong>无线局域网</strong>。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">设备A</span><br>   <span class="hljs-comment">\</span><br>    <span class="hljs-comment">\</span><span class="hljs-literal">---</span> <span class="hljs-comment">广播信道</span> <span class="hljs-literal">---</span> <span class="hljs-comment">设备B</span><br>    <span class="hljs-comment">/                  /</span><br><span class="hljs-comment">设备C               设备D</span><br></code></pre></td></tr></table></figure><blockquote><p>前面有讲到，同一个子网内的分组可以直接传送，这是因为它们使用了广播信道，。</p></blockquote></li></ul><p>定义一些术语：</p><ul><li>节点：运行链路层协议的一切设备。例如主机，wifi接入点，路由器，交换机。</li><li>链路：沿着通信路径连接相邻节点的通信信道。</li><li>在通过特定的链路时，传输节点将数据报封装在<strong>链路层帧</strong>中，并将该帧传送到链路中。</li></ul><p>为了将一个数据报从源主机传输到目的主机，数据包必须通过<strong>沿端到端路径上的各段链路传输</strong>。</p><h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><h4 id="数据链路层提供的服务"><a href="#数据链路层提供的服务" class="headerlink" title="数据链路层提供的服务"></a>数据链路层提供的服务</h4><p>链路层是为<strong>节点与节点</strong>之间提供逻辑通信的；网络层是为<strong>源主机和目的主机</strong>提供逻辑通信的；运输层是为<strong>源主机上的进程与目的主机上的进程</strong>提供逻辑通信的。</p><p>提供的具体服务如下：</p><ul><li><strong>封装成帧</strong></li><li>链路接入</li><li>可靠交付</li><li><strong>差错检错和纠正</strong></li></ul><p>链路层的主体部分实在<strong>网络适配器</strong>中实现的，也被称为<strong>网络接口卡</strong>，就是我们通常说的<strong>网卡</strong>。网络适配器实现链路层功能和相应的物理层功能。</p> <h3 id="差错检测和纠正技术（重点）"><a href="#差错检测和纠正技术（重点）" class="headerlink" title="差错检测和纠正技术（重点）"></a>差错检测和纠正技术（重点）</h3><p>在发送节点，为了保护比特免受差错，使用<strong>差错检测和纠正比特（EDC）</strong> 对数据D进行增强，D即为我们需要保护的数据，它不仅包括从网络层传递下来的数据报，还包括链路帧首部中的链路级的寻址信息、序号。</p><p>接收方的任务是在只接收到D’和EDC’的情况下，确认D’和D是否相同。</p> <p>要记得：<strong>检测出差错一定错！！未检测出差错不一定对！！</strong></p><p>使用三个方法来检测差错：奇偶校验、检验和、CRC。</p><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>使用<strong>单个奇偶校验位</strong>。</p><ul><li><strong>偶校验方案：</strong>使得整个帧中（原始数据<strong>加上奇偶校验位</strong>）的”1”比特数量为偶数。</li><li><strong>奇校验方案：</strong>使得整个帧中（原始数据<strong>加上奇偶校验位</strong>）的”1”比特数量为奇数。</li></ul><blockquote><p>只能检验出现奇数个比特出错。</p></blockquote> <p>为了能够查询出错误并且纠正，将 D 中的 d 个比特划分成 i 行 j 列，并且对它的每一行计算奇偶校验值（一共有i+j+1个），这个方案称为<strong>二维奇偶校验</strong>。</p> <h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4><p>跟运输层的实现方法一样，将数据 D 拆分成 16 个比特的序列处理，将整个序列加起来（记得回滚）并取反码就是检验和。</p><p>检验和方法开销比较小（检验和字段只需要16个比特），但是提供的差错保护没有CRC好。</p><blockquote><p>为什么运输层常用Checksum，但是链路层常使用CRC检测差错呢？</p><p>因为运输层有一部分是通过系统的软件实现的，所以采用简单而快速的Checksum方法来检测是很重要的。并且链路层的CRC检验在网络适配器中有专门的设计，可以更快的计算CRC。</p></blockquote><h4 id="循环冗余检测（CRC）（必考）"><a href="#循环冗余检测（CRC）（必考）" class="headerlink" title="循环冗余检测（CRC）（必考）"></a>循环冗余检测（CRC）（必考）</h4><p>首先，先介绍一下模2运算，所有的<strong>CRC计算都采用模2运算</strong>：</p><p>加法不进位，减法不借位，位与位之间无关。这意味着加法和减法是相同的，这种操作等价于异或（XRO）。</p> <p>CRC 编码的操作如下：对于一个 d 比特的数据D，在发送前，发送方和接收方先约定一个 r+1 比特模式，称为生成多项式（G），要求 G 的最高有效位为 1。</p><p>发送方要选择 r 个附加比特 R，并将他们附加到 D 上，使得得到的 d+r 比特模式用模 2 算术恰好能够被 G 整除。</p> <p>接收方进行差错检测：用G去除接收到的 d+r 比特，如果余数非零，则说明出现了差错，否则认为数据正确而被接收。而所有的 CRC 计算均采用模2运算来计算。</p><p>通常会给定 G，因为 G 是 r+1 位的，所以可以计算出 r。再根据以下公式计算出 R 的值。<br>$$<br>R &#x3D; \text{remainder} \left( \frac{D \cdot 2^r}{G} \right)<br>$$<br>下图是一个例子：</p><p>给定 G 为 1001，即 r 为 3。</p><p>因为要求 R 是 3位 的，所以要在余数前面补上 0。</p><p><strong>每个CRC检测都能检测出最多 r 比特的差错！！</strong></p><h3 id="多路访问链路和协议（重点）"><a href="#多路访问链路和协议（重点）" class="headerlink" title="多路访问链路和协议（重点）"></a>多路访问链路和协议（重点）</h3><p>前面提到网络链路有两种类型：<strong>点对点链路</strong>和<strong>广播链路</strong>。</p><ul><li><strong>点对点链路</strong> 由链路一端的单个发送方和链路另一端的单个接收方组成。点对点协议（point-to-point protocol，PPP）和高级数据链路控制（high-level data link control，HDLC）便是为这种网络链路设计的协议。</li><li><strong>广播链路</strong> 能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。这里的广播意味着任何一个节点传输一个帧时，信道都会广播该帧，每个其他节点都会收到一个特定的副本。传统的以太网和无线局域网都是广播链路层技术的例子。</li></ul><p>在广播链路中应该如何协调多个发送和接收节点对一个共享广播信道的访问，我们将其称为<strong>多路访问问题</strong>。</p><p>在广播链路中，当多个节点同时传输帧时，传输的帧会在所有的接收方处<strong>碰撞</strong>。当碰撞发生时，接收节点无法有效地获得任何传输的帧。<strong>多路访问协议</strong> 便是用来解决这种问题的。</p><p>多路访问协议划分为三种：<strong>信道划分协议</strong>、<strong>随机接入协议</strong>、<strong>轮流协议</strong>。</p><h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><p>可以根据时间（时分多用TDM）和频率（频分多用FDM）来划分信道。</p><p>假设一共有N个节点以及信道的传输速率为 R bps。</p><ul><li><p><strong>时分多用</strong></p><p>将时间划分成时间帧，并进一步将每个时间帧划分成N个时隙。</p><p>然后平均将每个时隙分配给一个节点。</p><p>消除碰撞，并且十分公平。</p><p>但问题是假设只有一个节点需要发送帧，可是它的速率被限制成R&#x2F;N。并且还需要等待到自己的时隙才能发送。</p></li><li><p><strong>频分多用</strong></p><p>在信道划分成多个频段（带宽为R&#x2F;N）,并将频段平均分给每个节点。</p><p>但问题还是假设只有一个节点需要发送帧，可是它的速率被限制成R&#x2F;N。</p></li><li><p><strong>码分多址 CDMA</strong></p><p>简单来说，就是对每个节点要传输的帧进行不同的编码，然后接收方再解码。</p><p>如果精心选择编码的话，可以实现不同的节点同时发送，并且相对应的接收方可以正确接收发送方编码的数据比特。</p></li></ul><h4 id="随机接入协议（重点）"><a href="#随机接入协议（重点）" class="headerlink" title="随机接入协议（重点）"></a>随机接入协议（重点）</h4><p>在随机接入协议中，一个传输节点总是以<strong>信道的最大传输速率（R）</strong>来进行发送。</p><p>当发生碰撞之后，<strong>它在重发该帧之前等待一个随机时延</strong>。</p><h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a><strong>时隙ALOHA</strong></h5><p>在分析之前，需要进行一些假设：</p><ul><li>所有数据链路帧是等长的。</li><li>时间被划分成相等的时隙，每个时隙刚好可以发送一帧。</li><li>每个节点只在时隙开始时发送帧。</li><li>节点是<strong>同步</strong>的，每个节点都知道时隙何时开始。</li><li>如果一个时隙中有两个及以上帧碰撞，则所有的节点在该时隙结束之前都能检测到碰撞。</li></ul><p>当碰撞发生后，碰撞的节点不会立即在下一个时隙重传，<strong>而是在每个时隙开始时以概率P重传</strong>，直到成功。</p> <p>以上图为例，1、2、3号节点在第一个时隙同时发送数据，产生碰撞。</p><ul><li><p>第三个时隙，恰巧1、2号节点同时选择重传，再一次发生碰撞，传送失败。</p></li><li><p>第四个时隙，只有2号节点选择重传，成功传输。</p></li><li><p>第六个时隙，1、3号节点同时选择重传，发送碰撞。</p></li><li><p>第八个时隙，只有1号节点选择重传，成功传输。</p></li><li><p>第九个时隙，三号节点选择重传，没有碰撞，成功传输。</p></li></ul><p>时隙ALOHA特点：</p><ul><li>当信道中只有一个活跃节点，表现很好。</li><li>但是当信道中有多个活跃节点，容易发生碰撞，“浪费”掉时隙。</li><li>并且每个节点需要<strong>同步</strong>。</li></ul><p>时隙ALOHA效率：</p><p>我们用成功传输的时隙占比来计算时隙ALOHA协议的效率，一个节点成功传输的概率为：<br>$$<br>p(1-p)^{N-1}<br>$$<br>因为有N个节点，任意一个节点成功的概率（实际上是时隙ALOHA的效率）为：<br>$$<br>Np(1-p)^{N-1}<br>$$<br>对上式取最大值，可以计算出时隙ALOHA的最大效率为：1&#x2F;e &#x3D; <strong>0.37</strong> 。</p><h5 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h5><p>在ALOHA协议下，节点无需在时间上同步，当有帧需要传输时，可以马上传输，如下图所示：</p> <p>为了使时刻 t0 开始传输的帧正确的传输，在[t0 -1 , t0]这个时间间隔内不能有其他节点开始传输。</p><p>其他节点在[t0 -1 , t0]这个时间间隔内不传输的概率为：<br>$$<br>(1-p)^{N-1}<br>$$<br>则任意一个节点成功传输的概率（ALOHA的效率）为：<br>$$<br>Np(1-p)^{2(N-1)}<br>$$</p><p>对上式取最大值，ALOHA的最大效率为：1&#x2F;2e ，是时隙ALOHA的一半，这个就是去除同步之后付出的代价。</p><h5 id="载波侦听多路访问CSMA（重点）"><a href="#载波侦听多路访问CSMA（重点）" class="headerlink" title="载波侦听多路访问CSMA（重点）"></a>载波侦听多路访问CSMA（重点）</h5><p>跟纯ALOHA有点像，但是一个节点在传输前会先<strong>侦听信道</strong>，如果信道空闲，则传输整个帧，否则推迟传送，等到信道空闲再尝试传输。</p><p>使用这种方式，信道仍然会有碰撞，主要原因是因为广播信道的端到端信道传播时延。</p> <p>t0时刻，节点B侦听到信道是空闲的，开始沿着广播媒体在两个方向上传播它的比特。</p><p>在t1时刻，节点D有一个帧需要发送，虽然此时节点B正在传输，但是B传输的比特还没有到达，导致D误认为信道空闲，选择传输比特，最终发生碰撞，导致两个节点传输失败。</p><p>很明显广播信道的端到端传播时延对CSMA影响很大，碰撞概率主要由以下因素影响：</p><ul><li>节点间距离越大，传播时延越大，碰撞可能越大。</li><li>节点越多，碰撞可能越大。</li></ul><h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h5><p>对比载波侦听多路访问CSMA，增加了碰撞检测，即一发生碰撞就停止传输。</p> <p>CSMA&#x2F;CD协议的整体运行流程如下：</p><ol><li><p>适配器从网络层获得数据报，准备链路层帧。</p></li><li><p>在发送帧前，侦听信道，若信道空闲则开始传送帧，信道忙则等到信道空闲再发送。</p></li><li><p>在传输过程中仍然检测信道，没有检测到冲突则持续发送，直到成功发送完成；检测到冲突则终止传输。</p></li><li><p>终止传输后，适配器<strong>根据二进制指数</strong>后退等待一个随机时间量，返回步骤2。</p></li></ol><h5 id="二进制指数后退"><a href="#二进制指数后退" class="headerlink" title="二进制指数后退"></a>二进制指数后退</h5><p>假设传输一个给定帧，它一共发生了n次碰撞后，节点随机从{$$0,1,2,…,2^n-1$$}选择一个k值，并且等待 <strong>k * 512 字节在数据链路层的传输时间</strong>。</p><ul><li>即k的单位是链路层传输512字节的时间。</li></ul><p>举个例子：</p><ul><li>首次碰撞，节点从{0, 1}中随机选择k值，若抽到0，则立刻监听信道；若抽到1，则等待（链路层传输512字节时间）后进行监听信道。</li><li>第二次碰撞，节点从{0, 1, 2, 3}中随机选择k值…</li><li>…</li></ul><p>二进制指数后退算法是<strong>分布式</strong>的！即每个节点自己算自己的。</p><p>CSMA&#x2F;CD的效率为：<br>$$<br>\text{效率} &#x3D; \frac{1}{1 + 5 \frac{d_{\text{prop}}}{d_{\text{trans}}}}<br>$$</p><ul><li>$$d_{prop}$$是传播的最大时间。</li><li>$$d_{trans}$$是传输一个最大长度的以太网帧的时间。</li></ul><h4 id="轮流协议（了解）"><a href="#轮流协议（了解）" class="headerlink" title="轮流协议（了解）"></a>轮流协议（了解）</h4><p><strong>信道划分协议</strong>在高负载下是有效和公平的，但是低负载下由于节点速率被限制在R&#x2F;N，因此效率较低；</p><p><strong>随机访问协议</strong>在低负载时效率高，单个节点可以完全利用信道带宽，但在高负荷情况下冲突概率大，效率低。</p><p>而<strong>轮流协议</strong> 集成了两者的优点，在低负载和高负载情况下都能有着较高的效率。</p><p>分为<strong>轮询协议</strong>和<strong>令牌传递协议</strong>。</p><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h5><p>设置一个主节点，主节点依次询问每个节点，告诉它能够传输的帧的最多数量。</p><p>一个节点传输完成后，主节点就会开始询问下一个节点，轮流执行。</p><p>存在单点故障问题，一旦主节点故障，整个信道都会变得不可操作。</p><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h5><p>该协议没有主节点。一个称为<strong>令牌的小的特殊帧</strong>在节点之间以某种固定的次序进行交换。如果某节点持有令牌并有数据要发送，它将占用令牌并发送数据，当发送完成，节点释放令牌并将其传递给下一个节点。</p><p>也是一样存在问题，如果令牌传丢了怎么办。</p><h3 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h3><h4 id="MAC地址与IP地址"><a href="#MAC地址与IP地址" class="headerlink" title="MAC地址与IP地址"></a>MAC地址与IP地址</h4><ul><li><p><strong>IP地址</strong>是网络层地址，32位（IPv6为128位），是<strong>分层</strong>的，能够实现路由聚集。用于完成网络到网络的交付。</p><p>分层的意思是IP地址可被分成子网部分和主机部分。</p></li><li><p><strong>MAC地址</strong>是链路层地址，48比特。是<strong>平面</strong>的，仅用来区分一个网络内的不同网卡，任何两个网卡的MAC地址都不相同。用于完成一个物理网络内部节点到节点的数据交付。</p></li></ul> <blockquote><p>可以注意到链路层交换机是没有MAC地址的接口的，只有主机和路由器的接口有。</p></blockquote><p>目前可观察到的三种地址：应用层的主机名，网络层的IP地址，链路层的MAC地址。</p><h4 id="ARP协议（地址解析协议）重点"><a href="#ARP协议（地址解析协议）重点" class="headerlink" title="ARP协议（地址解析协议）重点"></a>ARP协议（地址解析协议）重点</h4><p>目的在IP地址和MAC地址之间进行转换。</p><p>接下来解释ARP在一个子网中的使用流程。</p> <p>如上的一个局域网中每个接口都有一个IP地址和MAC地址，假设主机C想要向主机A发送IP数据报。发送数据报时，主机C除了需要向它的网络适配器提供IP数据报外，还需要提供目的地的MAC地址，然后适配器将构造一个包含目的地的MAC地址的链路层帧，并把该帧发送进局域网。<strong>而目标主机MAC地址的获取就是ARP需要完成的任务。</strong></p><p>每个主机或路由器上维护着一个ARP表，而主机C上的ARP表可能如下图所示：</p> <blockquote><p>可以发现还存储了时间，可能时间久了，就会将该记录从ARP表中去除。</p></blockquote><p>可以看到ARP表上并不包含该子网内的所有主机和路由器，需要查询的目标地址A的MAC地址并不在表项中，那么主机C会向它的适配器传递一个ARP查询分组（包括源和目的地的IP地址和MAC地址），该分组的目标地址为<strong>MAC广播地址（即FF-FF-FF-FF-FF-FF）</strong>，子网内的所有地址都会收到该查询分组。</p><p>当主机A收到该查询分组后（分组里有主机A的IP地址），会把自己的MAC地址放在ARP响应分组里，通过<strong>标准帧</strong>的形式发送给主机C。然后主机C将得到的映射关系存储更新在自己的ARP表中。</p><p>ARP查询是<strong>广播帧</strong>！响应是一个<strong>标准帧</strong>！！</p><blockquote><p>一般来说，收到一个帧后，网络适配器检查自己的MAC地址是否与目的MAC地址对应，如果不对应则丢弃，对应则接收并处理；但是如果目的MAC地址是广播帧，则所有的网络适配器都会接收并处理。</p></blockquote><p>DNS和ARP的区别：DNS是<strong>整个因特网都可以使用</strong>，但是<strong>ARP只能在自己的子网内</strong>（即同个广播信道）使用。</p><p>ARP是<strong>即插即用</strong>的：ARP表是<strong>自动生成</strong>的，不需要人工配置。</p><h4 id="发送数据报到子网之外"><a href="#发送数据报到子网之外" class="headerlink" title="发送数据报到子网之外"></a>发送数据报到子网之外</h4><p>刚刚描述了子网内传报的流程，现在观察如何传输到子网外。</p><p>考虑下图是由一台路由器互联两个子网形成的简单网络：</p><p>假设IP为<code>111.111.111.111</code>的主机A准备向另一个子网里IP为<code>222.222.222.222</code>的主机B发送数据报。</p><ol><li><p>主机A将数据报交付给它的适配器时，需要指示一个适当的MAC地址。该地址并不是主机B的MAC地址（因为主机B并不在当前子网内），而是下一跳路由器<code>111.111.111.110</code>的MAC地址。</p></li><li><p><strong>通过ARP得到该MAC地址后</strong>，封装链路层帧（该帧包含了寻址到主机B的IP数据报），并发送出去。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">IP   src : 111.111.111.111<br>IP  dest : 222.222.222.222<br>MAC  src : <span class="hljs-type">FF</span>-<span class="hljs-number">55</span><br>MAC dest : <span class="hljs-type">BB</span>-<span class="hljs-number">4</span>B<br></code></pre></td></tr></table></figure></li><li><p>路由器发现该帧是向自己寻址的，于是进行接收，然后解封装。读取到数据报的目标IP后，结合自己的转发表找到转发端口应该为<code>222.222.222.220</code>。</p></li><li><p>该端口再把这个数据报进行封装，MAC地址为目标主机B的MAC地址（因为此时已经和目标主机位于同一子网，且<strong>依旧使用ARP获得主机222.222.222.222的MAC地址</strong>）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IP</span>   src : <span class="hljs-number">111.111.111.111</span><br><span class="hljs-attribute">IP</span>  dest : <span class="hljs-number">222.222.222.222</span><br><span class="hljs-attribute">MAC</span>  src : <span class="hljs-number">06</span>-<span class="hljs-number">9</span>B<br><span class="hljs-attribute">MAC</span> dest : <span class="hljs-number">56</span>-<span class="hljs-number">2</span>A<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>可能你会想主机111.111.111.111一开始是如何获得网关路由器的IP地址的，这是DHCP分配IP地址给主机的时候给的。</p></blockquote><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网的拓扑结构分成<strong>总线拓扑</strong>和<strong>星形拓扑</strong>，若以太网是总线拓扑则是一种<strong>广播信道（链路）</strong>。</p><p>使用总线拓扑的以太网使用<strong>CSMA&#x2F;CD协议</strong>解决碰撞。（所以CSMA&#x2F;CD很重要）</p> <ul><li><strong>目的地址（6字节）</strong>：适配器只会处理自己和广播地址为目的地址的帧。</li><li><strong>源地址（6字节）</strong>：传输该帧到局域网上的适配器的MAC地址。</li><li><strong>类型字段（2字节）</strong>：类型字段允许以太网复用多种网络层协议。即类似向目的适配器告知使用了哪个网络层协议。</li><li><strong>数据字段（46~1500字节）</strong>：该字段承载了IP数据报，以太网的最大传输单元MTU是<strong>1500字节</strong>，超过则需要进行分片。数据字段的最小长度是46字节，不足则需要填充到46字节。</li><li><strong>CRC（4字节）</strong>：循环冗余校验码。</li></ul><p>以太网向网络层提供<strong>无连接服务</strong>和<strong>不可靠服务</strong>（就算它包含了CRC）。</p><ul><li>因为即使通过校验，接收方也不会发送确认帧；没通过校验，接收方也不会发送否定确认帧，只是直接丢弃该帧。所以发送方并不知道它传输的帧是否成功达到并通过校验。</li><li>这有助于降低以太网的复杂度和成本，但可能导致传递到网络层的数据报流存在间隙。UDP会无视这些间隙（导致应用层会看到数据中的间隙），但TCP不会对有间隙的数据报进行确认，从而执行重传。以太网并不知道自己传输的是一个新的数据报还是被重传的数据报。</li></ul><blockquote><p>链路层的东西都有点无脑，只负责做搬运工。</p></blockquote><h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><h5 id="转发和过滤"><a href="#转发和过滤" class="headerlink" title="转发和过滤"></a>转发和过滤</h5><ul><li><p><strong>过滤</strong>：决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p></li><li><p><strong>转发</strong>：是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。</p></li></ul><p>交换机的过滤和转发必须依靠<strong>交换机表</strong>实现。</p><p>交换机表的表项包含：</p><ul><li>MAC地址</li><li>通向该MAC地址的接口</li><li>表项放在表内的时间</li></ul> <p>当一个目的地址为<code>DD-DD-DD-DD-DD-DD</code>的帧从交换机接口 x 到达，交换机用该MAC地址在它的表里进行索引。有3种可能的情况：</p><ol><li><strong>表中没有该表项</strong>：交换机会将该帧广播到所有端口（除了接收该帧的端口x），即将帧转发到除入口端口以外的所有接口。</li><li><strong>表中有一个表项将该MAC地址与接口 x（即进来时的接口）联系起来</strong>：不会转发，而是直接丢弃该帧（避免环路）。</li><li><strong>表中有一个表项将该MAC地址与非 x 的的接口联系起来</strong>：将帧转发到该MAC地址对应的端口，不会进行广播。</li></ol><h5 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h5><p>交换机是<strong>自学习</strong> 的，即它的表是自动，动态和自治地建立的，不需要来自网络管理员和配置协议的任何干预。实现过程如下：</p><ol><li>交换机表初始为空。</li><li>对于在每个接口收到的帧，交换机会在其表中存储：<ul><li><strong>源MAC地址</strong>。</li><li><strong>接口信息</strong>：将源MAC地址和对应的接口进行关联并记录，以便在之后需要转发到该地址时知道帧应该从哪个接口发送。</li><li><strong>时间</strong>。</li></ul></li><li>如果在老化期内，交换机没有收到以该地址作为源地址的帧，就在表中删除这个地址（以这种方式，如果一台主机更换了网卡，那么旧的MAC地址最终会被从该交换机表中清除掉）。</li></ol><p>因为交换机不需要网络管理员或用户的干预，因此交换机是<strong>即插即用设备</strong>。</p><blockquote><p>ARP虽然也是即插即用的，但并不是自学习的。因为ARP的工作依赖于<strong>设备主动发送ARP请求</strong>来获得地址映射信息，而交换机是被动地从流经的帧中学习。</p></blockquote><h4 id="交换机和路由器的比较"><a href="#交换机和路由器的比较" class="headerlink" title="交换机和路由器的比较"></a>交换机和路由器的比较</h4> <p><strong>其实我看网上其他人的复习资料，好像到这里就结束了。</strong></p><h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>之前描述的局域网具有以下几个问题：</p><ul><li>缺乏流量隔离：可以发现经常有广播流量，例如像ARP和刚刚提到的交换机转发功能。为了安全和性能，要尽量减少广播流量。</li><li>难管理。</li></ul><p>这些问题都可以通过支持<strong>虚拟局域网的交换机</strong>来处理。</p><blockquote><p>简单来说，就是将一个物理局域网划分成多个虚拟局域网。</p></blockquote><p>在一个基于端口区分的VLAN中，交换机的端口由网络管理员划分为组。每个组形成一个VLAN，来自一个端口的广播流量只能到达该组的其他端口。</p> <p>上图表示端口2-8被分配给了电气工程系，形成电气工程系的虚拟局域网；端口9-15被分配给了计算机科学与技术系，形成计算机科学与技术系的虚拟局域网。端口1和16未被分配，属于一个默认的VLAN。</p><p>现在考虑，如何实现来自电气工程系的流量发送给计算机科学系：</p> <p>使用<strong>VLAN 干线连接（VLAN trunking）</strong>实现。</p><p>每台交换机的一个特殊端口被配置为 <strong>trunk 端口</strong>（左边的16端口，右边的1端口），以互联这两台交换机。</p><p>trunk 端口属于任何一个VLAN，发送到其他VLAN的帧都需要发送到 trunk 端口。</p><p>发送到 trunk 端口的帧都需要使用扩展的<strong>以太网帧格式 802.1Q</strong>，增加了<strong>VLAN 标签（tag）</strong>以区分流量属于哪个VLAN。</p><p>VLAN 标签由干线发送侧的交换机加进帧中，由干线接收侧的交换机去除。</p><p>假设端口2想传送数据包给端口9（上上图）传输流程如下：</p><ol><li><p><strong>设备发送数据包</strong>：VLAN 1中的设备生成数据帧，并将数据包发送到交换机。</p></li><li><p><strong>交换机识别VLAN ID</strong>：交换机检查数据包的来源端口（端口2），并识别该端口属于VLAN 1。</p></li><li><p><strong>数据帧转发到路由器</strong>：由于目标设备在另一个VLAN（VLAN 2），交换机将数据包通过Trunk端口转发到路由器。</p></li><li><p><strong>路由器进行路由</strong>：路由器检查数据包的目标IP地址，判断数据应转发到VLAN 2；路由器将数据包发送回交换机，同时标记数据帧属于VLAN 2。</p></li><li><p><strong>交换机转发数据</strong>：交换机接收数据帧后，将其转发到VLAN 2的目标端口（如端口9）。</p></li></ol><h4 id="多协议标签交换-MPLS（了解）"><a href="#多协议标签交换-MPLS（了解）" class="headerlink" title="多协议标签交换 MPLS（了解）"></a>多协议标签交换 MPLS（了解）</h4><p>IP转发需要使用最长前缀匹配，太慢了！</p><p>希望能够用一个定长的标签（而不是IP地址）来决定转发的接口。</p><p>在以太网首部和IP首部中间增加MPLS标签（首部），因为这个设计，一个MPLS加强的帧只能在两个均为MPLS使能的路由器间传输。</p> <p>具体例子如下图：</p><p>假设 R1 到 R4 都是支持MPLS的路由器。</p> <p>实现了不必考虑IP首部来决定转发的端口。</p><h3 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h3><p>这个真的会考吗… 但是写了作业哎。</p> <ul><li>Border Router（边界路由器）</li><li>Access Router（接入路由器）</li><li>Load Balancer（负载均衡器）</li><li>Tier-1 Switches（第一层交换机）</li><li>Tier-2 Switches（第二层交换机）</li><li>TOR Switches（Top of Rack 交换机）</li><li>Server Racks（服务器机架）</li></ul><p>数据中心网络中的数据流动可以分为以下两种情况：</p><h4 id="从互联网到数据中心内部的服务器"><a href="#从互联网到数据中心内部的服务器" class="headerlink" title="从互联网到数据中心内部的服务器"></a><strong>从互联网到数据中心内部的服务器</strong></h4><ol><li>边界路由器（Border Router）：<ul><li>接收来自互联网的数据包，判断其目标地址。</li></ul></li><li>接入路由器（Access Router）：<ul><li>将数据包转发到合适的 Tier-1 交换机。</li></ul></li><li>Tier-1 交换机：<ul><li>将数据包进一步分发到合适的 Tier-2 交换机。</li></ul></li><li>Tier-2 交换机：<ul><li>将数据包转发到目标服务器机架（Server Rack）上的 TOR 交换机。</li></ul></li><li>TOR 交换机：<ul><li>将数据包转发到目标机架中的具体服务器。</li></ul></li></ol><h4 id="从数据中心内部的一台服务器到另一台服务器"><a href="#从数据中心内部的一台服务器到另一台服务器" class="headerlink" title="从数据中心内部的一台服务器到另一台服务器"></a><strong>从数据中心内部的一台服务器到另一台服务器</strong></h4><ol><li>数据包从源服务器发出，经过其所属机架的 <strong>TOR 交换机</strong>。</li><li>TOR 交换机将数据包转发到 <strong>Tier-2 交换机</strong>。</li><li>如果目标服务器与源服务器属于不同的子网，数据包需要经过 <strong>路由器</strong>，然后进入目标 Tier-2 子网。</li><li>最终数据包通过目标机架的 <strong>TOR 交换机</strong> 到达目标服务器。</li></ol><p>可以发现鲁棒性很差，所以：</p> <h3 id="Web页面请求的历程（非常重要-必考必考！！）"><a href="#Web页面请求的历程（非常重要-必考必考！！）" class="headerlink" title="Web页面请求的历程（非常重要 必考必考！！）"></a>Web页面请求的历程（非常重要 必考必考！！）</h3>、<p><strong>首先先明确一个终端上网需要的四个地址：IP地址、子网掩码、网关IP、DNS服务器IP地址。</strong></p><p>整体计划：初始化IP，得到网关MAC，得到网站IP，建立TCP连接，发送HTTP请求报文。</p><p>这里我直接复制网上找的别人写的流程了：</p><ol><li><strong>DHCP请求报文</strong>：连接到网络时，此时这台机子还没有一个IP地址，因此需要得到一个。将该报文段放入<strong>UDP报文段</strong>，报文目的端口为DHCP服务器，源端口为客户。<br>UDP报文段放入IP数据报中，目的地址为广播，IP源地址为0.0.0.0。<br>IP数据报放入以太网帧中，目的地址为广播，源MAC地址为笔记本MAC地址。<br>将该以太网帧发送到以太网交换机。交换机广播该帧。<br>路由器在对应的MAC地址接收到了这个帧。抽取出IP数据报，分析广播得知这不是针对自己的特定通信，而是一个需要<strong>传递给更高层协议</strong>的信息，可能是为了进一步分发到网络上的所有主机，或者是为了执行某些本地处理（如DHCP服务器响应客户端请求）。因此IP数据报继续被分解，得到UDP报文段，得知这是一个DHCP请求。<br>假设路由器是DHCP服务器，那么会响应该DHCP请求。数据内容为：分配的IP地址，DNS服务器的IP地址，默认网关路由器的IP地址，子网块。生成一个如此的DHCP ACK报文发送回，目标MAC是笔记本的MAC地址。<br>交换机收到该帧。由于是<strong>自学习</strong>的，因此转发给笔记本。<br>笔记本收到该帧，得知IP，DNS，网关，子网块。初始化完成。</li><li><strong>ARP查询</strong>：Web浏览器需要生成一个<strong>TCP套接字</strong>，向谷歌网址发送<strong>HTTP请求</strong>。为了生成，需要知道网址的IP地址，这需要<strong>DNS服务</strong>。<br>生成一个包含DNS请求报文的数据报、以太网帧，打算发送给网关路由器。但是仍然不知道网关路由器的MAC。这需要<strong>ARP协议</strong>。<br>ARP查询报文的IP和源MAC已设置好，目的MAC为广播。<br>网关路由器在收到后发送ARP回复。笔记本收到网关路由器的MAC地址。</li><li><strong>DNS查询</strong>：向网关服务器发送DNS查询，目标MAC为网关MAC。<br>网关服务器收到，根据转发表发送到Comcast网络中最左侧的服务器。<br>对应服务器收到，根据转发表确定出口，向DNS转发数据报。而转发表已根据域内协议（如<strong>RIP</strong>，<strong>OSPF</strong>）以及<strong>因特网域间协议BGP</strong>填写。<br>DNS服务器收到，抽取出DNS查询，查找谷歌网址。如果没找到，则向根服务器发送查询。<br>总之是得到了，然后生成DNS回答报文，放入UDP报文段中，原路返回。<br>笔记本收到谷歌网址的IP地址。</li><li><strong>TCP协议</strong>：同谷歌三次握手，建立TCP套接字。<br>生成HTTP GET报文，写入套接字，报文段交给IP数据报，发送给谷歌。<br>谷歌抽取出报文，生成HTTP响应，发送进TCP套接字中。<br>计算机收到。终于显示了网页。</li></ol><blockquote><p><strong>突然想起来 ack 不只是应用在运输层的要记得。</strong></p></blockquote><h2 id="第七章-无线网络和移动网络"><a href="#第七章-无线网络和移动网络" class="headerlink" title="第七章 无线网络和移动网络"></a>第七章 无线网络和移动网络</h2><p>我觉得整章都不是重点，应该只会出判断或者选择，如果出简答的话就考验我的吹牛逼能力了。</p><p>无线网络有以下要素组成：</p><ul><li>无线主机：例如手机，平板。</li><li>无线链路：主机通过<strong>无线通信链路</strong>连接到一个<strong>基站</strong>或者另一台无线主机。</li><li>基站：负责协调与之相关联的多个无线主机的传输。例如无线接入点。</li></ul><p>与基站关联的主机一般称为<strong>基础设施模式</strong>运行，因为所有网络服务（地址分配和路由选择）都通过基站向无线主机提供。</p><p>在<strong>自组织网络（ad hoc）</strong>模式中无线主机没有这样子的设备（基站）与之相连。</p><h3 id="无线链路和网络特征"><a href="#无线链路和网络特征" class="headerlink" title="无线链路和网络特征"></a>无线链路和网络特征</h3><p>无线链路有一些问题：</p><ul><li>递减的信号强度</li><li>来自其他源的干扰</li><li>多路径传播</li></ul><p>信噪比（SNR）是收到的信号和噪声强度的相对比较，SNR越大使接收方更容易从背景噪声中提取传输的信号。</p><p>比特差错率（BER），知道有这个东西就行。通常 SNR 和 BER 成反比。</p> <h3 id="CDMA-码分多址"><a href="#CDMA-码分多址" class="headerlink" title="CDMA 码分多址"></a>CDMA 码分多址</h3><p>这也是多路访问协议的信道划分协议的一种。</p><p>通过划分编码空间来划分信道。</p> <p>发送方和接收方先确定一个CDMA编码（code），发送方CDMA编码器的输出就是code乘以Data bits。</p><p>解码的时候就是将编码输出乘以code再除以code的长度即可。</p><p>就算有其他发送方的比特混在一起也可以分开：</p> <h3 id="802-11-无线局域网（WIFI）"><a href="#802-11-无线局域网（WIFI）" class="headerlink" title="802.11 无线局域网（WIFI）"></a>802.11 无线局域网（WIFI）</h3><p>使用<strong>CSMA&#x2F;CA协议</strong>控制无线链路之间的碰撞。</p><p>802.11体系结构的基本模块是<strong>基本服务器（BSS）</strong>。</p><p>BSS 包含<strong>无线站点</strong>和<strong>接入点（中央基站）AP</strong>。</p><p>每个无线站点都有一个 48 比特的MAC地址。</p> <p>根据之前的定义可以知道，ad hoc是没有基站的。</p><p>接下来我们考虑无线站点（手机）如何跟哪个BSS的接入点AP（wifi）相连呢？</p><p>首先要知道，当网络管理员配置BSS的时候，会给AP分配一个<strong>服务集标识符（SSID）</strong>。</p><blockquote><p>例如用手机联网的时候会显示很多wifi供你选择。</p></blockquote><p>为了获得因特网接入，你的无线站点需要与一个AP相<strong>关联</strong>。关联的意思是这个无线站点只和这个AP发送数据帧，也只有这个AP能够给无线站点发送数据帧。</p><p>802.11要求每个AP周期性的<strong>发送信标帧</strong>（包含AP的SSID和MAC）。</p><p>可以通过<strong>被动扫描</strong>和<strong>主动扫描</strong>两种方式来建立关联。</p><ul><li>被动扫描：<ol><li>AP周期的发送信标帧</li><li>主机向选择的AP发送关联请求帧</li><li>被选择的AP发送关联响应帧</li></ol></li><li>主动扫描：<ol><li>主机广播探测请求帧</li><li>每个AP向主机发送探测响应帧</li><li>主机向选择的AP发送关联请求帧</li><li>被选择的AP发送关联响应帧</li></ol></li></ul> <h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h4><p>带有<strong>碰撞避免</strong>的CSMA（载波侦听多路访问）。</p><p>这个是碰撞避免，前面讲的以太网常使用的<strong>CSMA&#x2F;CD是碰撞检测</strong>。</p><p>因为不使用碰撞检测，所以802.11一旦开始传输，就会传输整个帧了。</p><p><strong>802.11有确认重传机制</strong>。</p> <p>CSMA&#x2F;CA 的核心在于通过一系列机制<strong>尽量避免碰撞</strong>的发生。以下是其基本工作流程：</p><ol><li><strong>监听信道</strong>：<ul><li>设备在发送数据之前，首先监听通信信道。</li><li>如果信道忙（正在传输数据），设备会等待信道空闲。</li></ul></li><li><strong>随机等待（Backoff）</strong>：<ul><li>如果信道空闲，设备不会立即发送数据，而是等待一个随机时间（称为“退避时间”）。</li><li>这一机制可以减少多个设备同时发送数据的概率，从而避免碰撞。</li><li>为什么不使用CSMA&#x2F;CD，假设信道空闲从忙到空闲的一个情况：多个终端就会同时传送帧，导致碰撞发生。</li></ul></li><li><strong>数据传输</strong>：<ul><li>如果设备等待后发现信道仍然空闲，则开始发送数据。</li><li>发送完毕后，接收设备会向发送设备返回一个 <strong>ACK（确认帧）</strong>，表明数据成功到达。</li></ul></li><li><strong>重传机制</strong>：<ul><li>如果发送设备在一定时间内未收到 ACK，则认为数据包丢失（可能由于碰撞或信道问题），并重新尝试发送数据。</li></ul></li></ol><p>但是802.11还有一个问题是可能会有隐藏的终端，并且随着信号的衰减，两个终端之间互相检测不到对方。</p> <p>CSMA&#x2F;CA可以使用RTS（request to send）控制帧和CTS（clear to send）控制帧来预约信道的使用，避免隐藏终端问题：</p>  <p>所以如果判断题问：ack机制只有在传输层才使用是错误的，链路层也有使用。</p><h4 id="802-11-帧结构"><a href="#802-11-帧结构" class="headerlink" title="802.11 帧结构"></a>802.11 帧结构</h4><p><strong>一共有四个MAC地址段！以太网帧只有两个（源和目的）！！</strong></p><p>802.11帧结构的四个MAC地址段：</p><ol><li><p>无线站点的MAC地址（源）</p></li><li><p>AP的MAC地址（目的）</p></li><li><p>与该AP相连的路由器的MAC地址。</p><p>因为 BSS 可以想象成是子网的一个部分，这个子网经过路由器和其他子网相连接。</p><p>其实就是网关的MAC地址。</p></li><li><p>ad hoc自组织网络使用的MAC地址（这里不作讨论）</p></li></ol> <p>802.11帧的类型有：信标帧（SSID、MAC）、关联帧、RTS控制帧（预约信道使用）、CTS控制帧（允许信道使用）、ack、数据帧。</p><h4 id="在相同的IP子网中的移动性"><a href="#在相同的IP子网中的移动性" class="headerlink" title="在相同的IP子网中的移动性"></a>在相同的IP子网中的移动性</h4><p>若两个BSS之间是交换机相连的，则它们属于同一个子网；若是路由器相连的，则它们不属于一个子网（并且移动之后必须在新的子网内获得新的IP地址）。</p> <p>现在考虑一台主机从BSS1移动到BSS2，两个BSS子网是相同的。</p><ol><li>随着主机 H1 从 BSS1 移动到 BSS2 的过程中，来自 AP1 的信号会逐渐减弱，而 AP2 的信号会逐渐增强。</li><li>主机 H1 决定断开与 AP1 的连接并尝试连接到 AP2。</li><li>H1 与 AP2 关联起来后，<strong>IP地址不变</strong>并且维持正在进行的TCP对话。即移动过程对网络层和传输层的通信透明。</li></ol><h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>蓝牙网络必须是<strong>自组织网络（ad hoc）</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>让自己记得文章如何输出图片</title>
    <link href="/2024/12/03/%E8%AE%A9%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BE%97%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87/"/>
    <url>/2024/12/03/%E8%AE%A9%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BE%97%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="让自己记得文章如何输出图片"><a href="#让自己记得文章如何输出图片" class="headerlink" title="让自己记得文章如何输出图片"></a>让自己记得文章如何输出图片</h2><p>首先打开 hexo 的文件 _config.yml 更改 post_asset_folder 为 true。</p><p><img src="/2024/12/03/%E8%AE%A9%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BE%97%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87/7b88f8d3656c25b999185fc722972ba.png" alt="7b88f8d3656c25b999185fc722972ba"></p><p>然后将<code>/node_modules/hexo-asset-image/index.js</code>内的代码更改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPosition</span>(<span class="hljs-params">str, m, i</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">split</span>(m, i).<span class="hljs-title function_">join</span>(m).<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-title class_">String</span>(hexo.<span class="hljs-property">version</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.<span class="hljs-property">config</span>;<br>  <span class="hljs-keyword">if</span>(config.<span class="hljs-property">post_asset_folder</span>)&#123;<br>        <span class="hljs-keyword">var</span> link = data.<span class="hljs-property">permalink</span>;<br>    <span class="hljs-keyword">if</span>(version.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title class_">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>       <span class="hljs-keyword">var</span> beginPos = <span class="hljs-title function_">getPosition</span>(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">var</span> beginPos = <span class="hljs-title function_">getPosition</span>(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br>    <span class="hljs-keyword">var</span> endPos = link.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.<span class="hljs-title function_">substring</span>(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.<span class="hljs-property">length</span>; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.<span class="hljs-title function_">load</span>(data[key], &#123;<br>        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span> ($(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br>            <span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br>            <span class="hljs-keyword">var</span> src = $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;src&#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.<span class="hljs-title function_">test</span>(src) &amp;&amp;<br>               !<span class="hljs-regexp">/^\s*\//</span>.<span class="hljs-title function_">test</span>(src)) &#123;<br>              <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>              <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>              <span class="hljs-keyword">var</span> linkArray = link.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">var</span> srcArray = src.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)&#123;<br>                <span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>              &#125;);<br>              <span class="hljs-keyword">if</span>(srcArray.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>)<br>                srcArray.<span class="hljs-title function_">shift</span>();<br>              src = srcArray.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>              $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;src&#x27;</span>, config.<span class="hljs-property">root</span> + link + src);<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>&amp;&amp;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.<span class="hljs-property">root</span> + link + src);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>&amp;&amp;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>&amp;&amp;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>($(<span class="hljs-variable language_">this</span>));<br>        &#125;<br>      &#125;);<br>      data[key] = $.<span class="hljs-title function_">html</span>();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后再更改typora内的图片路径为</p><p><img src="/2024/12/03/%E8%AE%A9%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BE%97%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87/9ef597884b9c3010e8b8f653a6d6241.png" alt="9ef597884b9c3010e8b8f653a6d6241"></p><p>对，typora内是输出不出来的，接下来有空再想想办法，看看能不能同时显示。</p><p>这个大佬写的很好，到时候可以试试</p><p><a href="https://jythomas.github.io/2022/01/11/Hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/">Hexo博客配置(解决图片显示问题) - Morant’s Blog</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>First Post!!</title>
    <link href="/2024/12/03/helloworld/"/>
    <url>/2024/12/03/helloworld/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-for-your-coming"><a href="#Welcome-for-your-coming" class="headerlink" title="Welcome for your coming"></a>Welcome for your coming</h1><p>你好，我是TAM CHEOK HANG，欢迎来到我的博客呀。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>人工智能复习</title>
    <link href="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能复习"><a href="#人工智能复习" class="headerlink" title="人工智能复习"></a>人工智能复习</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ol><li>人工智能的定义、概况；</li><li>人工智能主要学派及主要观点。</li></ol><h3 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h3><p>需要先有<strong>信息</strong>、<strong>认识</strong>、<strong>知识</strong>、<strong>智力</strong>、<strong>智能</strong>概念才能定义人工智能。</p><ul><li>信息：是搭配了<strong>上下文</strong>的<strong>数据</strong>，是经过整理（解释）的数据，例如“今天天气是30摄氏度”，配合上下文（天气和摄氏度）形成了有意义的信息。</li><li>认识：是用<strong>符号</strong>（例如文字）去整理信息，并且确定它们之间的联系。</li><li>知识：是被<strong>认识</strong>了的<strong>信息</strong>和信息之间的联系。是经过加工（整理）的信息，例如“水在摄氏度0度以下会结冰”就是一种知识。</li><li>智力：是<strong>学习</strong>的能力、<strong>解决问题</strong>的能力，强调运用推理来应对问题。</li><li>智能：定义为<strong>知识集</strong> + <strong>智力</strong>。所以智能就是运用知识来解决问题的能力。</li></ul><p><strong>人工智能定义</strong>：就是利用机器去模仿人类的智能来解决问题。</p><h3 id="人工智能学派及主要观点"><a href="#人工智能学派及主要观点" class="headerlink" title="人工智能学派及主要观点"></a>人工智能学派及主要观点</h3><p><strong>符号主义学派（数理逻辑）</strong></p><ul><li>主要观点：人工智能源于<strong>数理逻辑</strong>。认知基元是符号，以归结原理为基础。</li><li>应用：IBM提出的<code>DEEP BLUE</code>国际象棋和<code>WATSON</code>认知系统。</li></ul><p><strong>联结主义学派（仿生学）</strong></p><ul><li>主要观念：人工智能源于<strong>仿生学</strong>。通过神经元连接和相互作用模拟大脑的结构和功能，通过神经网络来实现智能行为。</li><li>应用：计算机视觉、卷积神经网络、自然语言处理。</li></ul><p><strong>行为主义学派（控制论）</strong></p><ul><li>主要观念：人工智能来源于<strong>控制论</strong>和<strong>反馈机制</strong>。通过模拟生物体在环境中的适应能力和行为来实现智能。</li><li>应用：强化学习、Google研发的机器狗。</li></ul><h2 id="第二章-知识表示和推理"><a href="#第二章-知识表示和推理" class="headerlink" title="第二章 知识表示和推理"></a>第二章 知识表示和推理</h2><h3 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h3><ol><li><p>命题逻辑语法、语义；</p></li><li><p>谓词逻辑语法、语义；</p></li><li><p>谓词推理规则（等价式、永真蕴含式）以及应用；</p></li><li><p>命题及谓词逻辑归结推理（子句、子句集、置换与合一、答案提取）。</p></li></ol><h3 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h3><ul><li><strong>项</strong><ol><li><strong>常数（Constant）</strong>：表示特定的对象，例如<code>a</code>、<code>b</code>、<code>c</code>。</li><li><strong>变量（Variable）</strong>：表示可以取不同值的对象，例如<code>x</code>、<code>y</code>、<code>z</code>。</li></ol></li><li><strong>谓词</strong><ol><li>谓词符号通常是大写字母，例如P(x)、Q(a,b)。</li></ol></li><li><strong>量词</strong><ol><li><strong>全称量词（Universal Quantifier）</strong>：表示对所有的情况都成立，符号为∀，例如∀x P(x)表示“对所有x，P(x)都成立”。</li><li><strong>存在量词（Existential Quantifier）</strong>：表示存在某种情况成立，符号为∃，例如∃x P(x)表示“存在某个x，使得P(x)成立”。</li></ol></li></ul><h3 id="谓词逻辑推理规则"><a href="#谓词逻辑推理规则" class="headerlink" title="谓词逻辑推理规则"></a>谓词逻辑推理规则</h3><ul><li><p>假言推理：</p><p>P→Q, P ⇒ Q</p></li><li><p>假言否定:</p><p>P→Q, ¬Q ⇒ ¬P</p></li><li><p>等等</p></li></ul><h3 id="谓词逻辑应用"><a href="#谓词逻辑应用" class="headerlink" title="谓词逻辑应用"></a>谓词逻辑应用</h3><ul><li>课件一中有两题例子，可以刷下。</li></ul><h3 id="归结推理"><a href="#归结推理" class="headerlink" title="归结推理"></a>归结推理</h3><p>需要先了解<strong>反证法</strong>、<strong>子句集</strong>、<strong>归结操作</strong>的概念才能清楚归结推理。</p><ul><li><p>反证法</p><p>P ⇒ Q  当且仅当  P ∧ ¬Q ⇔ False</p></li><li><p>子句集</p><ol><li>文字：原子公式及其否定。例如：P：正文字，¬P：负文字。</li><li>子句：任何文字的<strong>析取</strong>，当然一个文字自己也是子句。例如：P ∨ Q ∨ R。</li><li>子句集：子句的<strong>合取</strong>集合。例如 {P ∨ Q, ¬P ∨ R, ¬Q}这个子句集合表示了一个包含三个子句的集合，其中 P ∨ Q, ¬P ∨ R, 和 ¬Q 是各自的子句。在归结推理中，我们可以通过归结操作来处理这些子句，从而推导出新的子句或证明目标。</li></ol></li><li><p>归结操作</p><ol><li>定义：归结操作步骤包括选择两个子句并尝试将它们合并成一个新的子句。合并的过程依赖于通过消解相反的文字来生成新的子句。</li><li>例子：有两个子句{P ∨ Q, ¬Q}，经过归结操作后生成新子句{P}。</li></ol></li></ul><p>归结推理的基本步骤是利用反证法：首先将目标子句的否定加入子句集中，然后通过归结操作处理子句集，直到推导出空子句。根据反证法的原理，这表明目标子句是可证明的。</p><ul><li><p>谓词公式转换子句集</p><ol><li>消去蕴涵和等价符号</li><li>内移否定符号¬</li><li>变量标准化（变量换名）</li><li>消去存在量词（<code>Skolemize</code>）</li><li>化为前束型</li><li>把母式化成合取范式</li><li>略去全称量词</li><li>把母式用子句集表示</li><li>子句变量标准化（最好每个子句的变量都不一样）</li></ol></li><li><p>合一</p><ol><li>定义：在谓词归结过程中（子句集内）寻找谓词相同但是项不同，把它们不同的项经过置换，使得该谓词项相同，就是合一。</li></ol></li><li><p>置换</p><ol><li><p>定义：用σ &#x3D; {v1&#x2F;t1, v2&#x2F;t2,…, vn&#x2F;tn}来表示任一置换。vi &#x2F;ti 是指表达式中的变量vi以项ti来替换，且不允许vi 用与vi 有关的项ti（但是ti中可以包含其它变量）作置换。</p></li><li><p>例子：**{a&#x2F;x, w&#x2F;y, f(s)&#x2F;z}是置换**; <strong>{x&#x2F;x}, {y&#x2F;f(x)}不是置换</strong>;、</p></li><li><p>置换是同时进行的。</p></li></ol></li><li><p>复合置换</p><ol><li>过程：θ&#x3D;{t1&#x2F;x1,…,tn&#x2F;xn}，λ&#x3D;{u1&#x2F;y1,…,um&#x2F;ym},求θ°λ<ol><li>构成{t1λ&#x2F;x1,…,tnλ&#x2F;xn,u1&#x2F;y1,…,um&#x2F;ym};（可想象成先置换t1λ&#x2F;x1,…,tnλ&#x2F;xn这一部分再一个一个置换λ）</li><li>如果yj∈(x1,…,xn),  则删除uj&#x2F;yj;<strong>（即替换的变量前面已经被换过了）</strong>（<strong>要记得是θ先做变换的，只要是θ里面更换的变量，λ都要删除</strong>）</li><li>如果tkλ&#x3D;xk,     则删除tkλ&#x2F;xk;<strong>（类似 y &#x2F; y这种）</strong></li></ol></li><li>性质：(θ° λ)° μ&#x3D;θ° (λ° μ) 成立，θ° λ&#x3D;λ ° θ 不一定成立。</li></ol></li><li><p>最一般合一项（MGU）算法：</p><p>给定两个原子公式 f 和 g：</p><ol><li><p>初始化：</p><p>σ&#x3D;{ };S&#x3D;{f,g}</p><p>σ 是当前的<strong>替换集</strong>，初始为空。 S 是包含两个公式 f 和 g 的集合。</p></li><li><p>检查 S 是否包含相同的一对公式。如果是，停止并返回 σ 作为 f 和 g 的 MGU。</p></li><li><p>否则，找到 S 中不一致的项集 D&#x3D;{e1,e2}。</p></li><li><p>检查不一致的项：</p><ul><li>如果 e1&#x3D;V 是一个变量，并且 e2 是不包含 V 的项（反之亦然），则更新替换集： σ&#x3D;σ ° {V&#x3D;t};S&#x3D;S ° {V&#x3D;t}。</li></ul></li><li><p>否则，停止，表示 f 和 g 不能被合一。1</p></li></ol></li><li><p>应用归结原理求解问题</p><ol><li>就是把待求解的问题<strong>否定</strong>加上与<code>A(x)</code><strong>析取</strong>转换成子句并加入到子句集合中，运用归结操作求解答案。</li></ol></li></ul><h2 id="第三章-搜索技术"><a href="#第三章-搜索技术" class="headerlink" title="第三章 搜索技术"></a>第三章 搜索技术</h2><h3 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h3><ol><li>盲目搜索（深度搜索、宽度搜索、迭代加深搜索）；</li><li>启发式搜索（最好优先搜索、A*搜索）；</li><li>博弈树搜索（极大极小过程、alpha-beta剪枝）。</li></ol><h3 id="搜索的形式化定义"><a href="#搜索的形式化定义" class="headerlink" title="搜索的形式化定义"></a>搜索的形式化定义</h3><ol><li>状态空间：即整个要搜索的空间。</li><li>动作：即在当前这个状态需执行的动作。</li><li>初始状态：就是自己目前的状态。</li><li>目标状态：目标的状态。</li><li>启发式函数：指导搜索的方向。</li></ol><p>除此之外，搜索算法还包括<strong>后继函数</strong>、<strong>动作成本</strong>以及如何<strong>选择下一步动作</strong>（这个最重要）等等。</p><h3 id="盲目搜索（无信息搜索）"><a href="#盲目搜索（无信息搜索）" class="headerlink" title="盲目搜索（无信息搜索）"></a>盲目搜索（无信息搜索）</h3><p>采用<strong>固定</strong>的选择策略来选择下一个状态。</p><h4 id="宽度优先搜索"><a href="#宽度优先搜索" class="headerlink" title="宽度优先搜索"></a>宽度优先搜索</h4><ol><li>定义：把当前要扩展的状态的后继状态放在边界的<strong>最后</strong>。</li><li>性质：宽度优先搜索具有<strong>完备性</strong>和<strong>最优性</strong>。<ul><li>完备性：宽度优先从短到长从上到下慢慢搜索，最终一定能找到目标状态。</li><li>最优性：根据宽度优先搜索定义，短的路径一定会在长的路径前被探索完，所以一定有最优性。</li><li>时空复杂度：时空复杂度开销很大，都是O(b^{d+1})，特别是空间复杂度。</li></ul></li></ol><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><ol><li>定义：把当前要扩展的状态的后继状态放在边界的<strong>最前面</strong>。</li><li>性质：深度优先搜索不具有<strong>完备性</strong>和<strong>最优性</strong>。<ul><li>完备性：如果状态空间无限或者存在回路则找不到目标状态；若状态空间有限并且一直进行剪枝的话具有完备性。</li><li>时空复杂度：时间复杂度为O(b^m)，空间复杂度**O(bm)**。</li></ul></li></ol><h4 id="迭代加深搜索"><a href="#迭代加深搜索" class="headerlink" title="迭代加深搜索"></a>迭代加深搜索</h4><p>其实就是深度优先和宽度优先缝合；具有宽度优先的优势（每个节点都搜索），也具有深度优先的优势（搜索快）</p><ol><li>定义：迭代加深搜索从<strong>深度限制为0</strong>开始，逐渐增加深度限制，直到找到目标节点或搜索完整个图。每次搜索都是<strong>深度优先搜索</strong>，但只允许到当前的最大深度限制为止。</li><li>性质：具有<strong>完备性</strong>和<strong>最优性</strong>。<ul><li>完备性：类似宽度优先一样。</li><li>最优性：类似宽度优先一样。</li><li>时空复杂度：空间复杂度为O(b^{d})（跟宽度优先一样，可是不用提前存储下一层的节点）；时间复杂度为O(bm)（跟深度优先一样）。</li></ul></li></ol><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><p>对于一个具体问题，构造专用于该领域的<strong>启发式函数 ℎ(𝑛)</strong>, 该函数用于估计从节点𝑛到达目标节点的成本。要求对于所有满足目标条件的节点𝑛，有<strong>ℎ(𝑛)</strong> &#x3D; 0。并且使用<strong>评价函数f(n)<strong>来选择下个要到达的状态。</strong>f(n) &#x3D; g(n) + h(n)</strong></p><ul><li>g(n)是初始节点到n的实际代价。</li></ul><h4 id="贪婪最佳优先搜索"><a href="#贪婪最佳优先搜索" class="headerlink" title="贪婪最佳优先搜索"></a>贪婪最佳优先搜索</h4><ol><li>定义：就是利用启发式函数<strong>ℎ(n)</strong> 来对边界上的节点进行排序，然后每次选择**ℎ(n)**最小的节点n去搜索。</li><li>评价函数（可以理解成）：<strong>f(n) &#x3D; h(n)</strong></li><li>性质：没有<strong>完备性</strong>和<strong>最优性</strong>。</li></ol><h4 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h4><ol><li><p>定义：就是利用评价函数<strong>f(n)</strong> 来对边界上的节点进行排序，然后每次选择f**(n)**最小的节点n去搜索。</p></li><li><p>评价函数：<strong>f(n) &#x3D; g(n) + h(n)</strong></p><ul><li>启发式函数**h(n)*<em>可采纳性：假设ℎ*(𝑛) 是从节点𝑛到目标节点的最优路径的成本，当对于所有节点𝑛，满足ℎ(𝑛) ≤ ℎ</em>(𝑛)，ℎ(n)是可采纳的。<ul><li>为什么叫可采纳，是因为一直低估了最优的代价，可以让A*算法更好的找到最优解。</li></ul></li><li>启发式函数**h(n)**一致性：对于任意节点𝑛1和𝑛2，若 ℎ(𝑛1) ≤ 𝑐(𝑛1 → 𝑛2) + ℎ(𝑛2) 则ℎ(𝑛)具有一致性。<ul><li>为什么叫一致性，因为保证f值是<strong>非递减</strong>的。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240702224627410.png" alt="image-20240702224627410"></li></ul></li><li><strong>证明：一致性可推可采纳性：</strong><ol><li>假设启发式函数 h(n)是一致的。</li><li>假设 h(n) 不是可采纳的。这意味着存在某个节点 n 使得 h(n)&gt;h∗(n)。</li><li>选择一个实际从起始节点 s 到目标节点的最优路径，并设这个路径为 s,n1,n2,…,ng，其中 ng 是目标节点。</li><li>在这条路径上，由于 h 是一致的，我们有： <img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240702223842521.png" alt="image-20240702223842521"></li><li>由于目标节点 ng 的启发值为零（即 h(ng)&#x3D;0），将这些不等式相加得到： <img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240702223905637.png" alt="image-20240702223905637"></li><li>因为 c(s,ng)c(s, n_g)c(s,ng) 就是从 sss 到 ngn_gng 的最小实际代价 h∗(s)h^*(s)h∗(s)，所以： h(s)≤h∗(s)</li><li>这与假设的 h(s)&gt;h∗(s) 矛盾。因此，假设 h(n) 不是可采纳的前提是错误的。</li></ol></li></ul></li><li><p>性质：<strong>可能</strong>具有最优性。</p><ul><li><p>一致性可以推出可采纳性。</p></li><li><p>如果**h(n)**只具有可采纳性，没有环检测的情况下是有最优性的。有环检测则不是。</p></li><li><p>如果**h(n)**具有一致性，就算有环检测，也有最优性。</p></li></ul></li></ol><h3 id="博弈树搜索"><a href="#博弈树搜索" class="headerlink" title="博弈树搜索"></a>博弈树搜索</h3><h4 id="Minimax算法"><a href="#Minimax算法" class="headerlink" title="Minimax算法"></a>Minimax算法</h4><ol><li>定义：假设对方能总是做出最优的行动，己方总是做出能最小化对方获得的收益的行动，通过最小化对方的收益，可以最大化己方的收益。</li><li>使用<strong>深度优先搜索</strong>。（模拟算法很重要）</li></ol><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>只要计算节点n的一部分子节点就可以确定在<code>MiniMax</code>算法中我们不会考虑走到节点n了；如果已经确定节点n不会被考虑，那么也就不用继续计算n的子节点了。如下图：<code>x</code>和<code>y</code>已经不用被搜索了。<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240621191942772" style="zoom:67%;"></p><ul><li>MAX剪枝：对于Max节点n，如果它的α(子) ≥ β(父)的时候，就可以停止遍历n的子节点了。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621192426769.png" alt="image-20240621192426769"></li><li>MIN剪枝：对于Min节点n，如果它的α(父) ≥ β(子)的时候，就可以停止遍历n的子节点了。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621192631831.png" alt="image-20240621192631831"></li></ul><p>简单来说，对于Min节点n, 如果β值变得 ≤ 某个Max 祖先节点的α值, 那么就可以停止扩展n节点了。Max节点也是一样的。</p><p><strong>要记得！是α ≥ β就可以发生剪枝！</strong></p><h2 id="第四章-高级搜索"><a href="#第四章-高级搜索" class="headerlink" title="第四章 高级搜索"></a>第四章 高级搜索</h2><h3 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h3><ol><li>爬山法（基本思想）；</li><li>遗传算法（基本操作）（旅行商问题）。</li></ol><h3 id="爬山法（基本思想）"><a href="#爬山法（基本思想）" class="headerlink" title="爬山法（基本思想）"></a>爬山法（基本思想）</h3><ul><li>是一种<strong>贪婪局部搜索算法</strong>。 能很快<strong>朝着解的方向进展</strong>。</li><li>登高：一直向值增加的方向持续移动，将会在到达一个 “峰顶”时终止，并且在相邻状态中没有比它更高的值。 这个算法保留搜索得路径，因此当前节点的数据结构只需要记录当前状态和它的目标函数值。</li><li>优点：<ol><li>它们只用很少的内存。（因为没有保留搜索得路径）</li><li>它们通常能在很大状态空间中找到合理的解。</li></ol></li><li>可以把爬山法想象成一种地形图，既有“位置”（用状态定义），又有“高度”（用启发式函数定义）。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621202221480.png" alt="image-20240621202221480"></li><li>爬山法的缺点：容易陷入局部最优解。<ol><li>局部最大值：局部极大值是一个比它的每个邻居状态都高的峰顶，但是比全局最大值要低。爬山法找不到最优解。</li><li>山脊：就是一系列的局部最大值，爬山法搜索容易陷入死循环。</li><li>高原：高原是在状态空间地形图上评价函数值平坦的一块区域。像上图的<code>shoulder</code>（山肩）和<code>flat local maximum</code>（水平的局部最大值）都是高原。爬山法搜索效率降低。</li></ol></li><li>解决优点：从不同的状态开始运行爬山法看看哪个解更好。</li></ul><h3 id="爬山法和模拟退火的区别"><a href="#爬山法和模拟退火的区别" class="headerlink" title="爬山法和模拟退火的区别"></a>爬山法和模拟退火的区别</h3><p>因为爬山法是局部贪婪算法，所以容易陷入局部最优解；模拟退火算法是全局优化算法，它可以接受比当前更差的解，所以不会容易陷入局部最优解，并且随着时间慢慢降低接受差解的概率。</p><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>三函数两准则(状态生成函数 状态接受函数 降温函数 退火结束准则 内循环终止准则)</p><p>流程图：<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240703143135428.png" alt="image-20240703143135428"></p><p><img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240703144219931.png" alt="image-20240703144219931"></p><h3 id="遗传算法（基本操作）"><a href="#遗传算法（基本操作）" class="headerlink" title="遗传算法（基本操作）"></a>遗传算法（基本操作）</h3><p>遗传算法的一般步骤为<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621213314264.png" alt="image-20240621213314264"></p><p>流程中，不一定每个个体都会发生<strong>交叉</strong>和<strong>变异</strong>，都是有概率的。</p><p>包括编码、适应度函数、<strong>选择</strong>、<strong>交叉</strong>、<strong>变异</strong>。(后面三种为基本操作)</p><ul><li><p>编码：就是将每个个体进行二进制编码。</p></li><li><p>适应度函数：返回值是判断该个体的适应度，适应度越大代表该个体越好。</p></li><li><p>选择：选择是用来确定重组或交叉个体，以及被选个体将产生多少个子代个体。适应度越大的个体被选择的概率越大。选择方法有：</p><ol><li>轮盘赌：首先按照适应度比例分配给每个个体被选中的概率，然后所有个体被选中概率之和为1，再随机[0,1]生成浮点数，看落在哪个区间，就选择哪个个体。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621212351847.png" alt="image-20240621212351847"></li><li>锦标赛选择：就是按照轮盘赌抽几个个体进行适应度比较，适应度高的个体被选择，一直重复执行下去。</li></ol></li><li><p>交叉：结合父代中选择的个体中的信息而产生新的个体。交叉方法有：</p><ol><li>单点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换，并生成两个新的个体。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621213039839.png" alt="image-20240621213039839"></li><li>两点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。</li></ol></li><li><p>变异：子代基因按小概率扰动产生的变化。变异方法有：</p><ol><li>位点变异：群体中的个体码串，随机挑选一个或多个基因座，并 对这些基因座的基因值以变异概率作变动。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240621213549835.png" alt="image-20240621213549835"></li></ol></li><li><p>遗传算法的特点：遗传搜索是针对<strong>一组候选解决方案</strong>（individuals）而不是单个候选方案进行的。在搜索过程中，算法会保留当前一代的一组个体。遗传算法的每次迭代都会创建下一代个体。相反，大多数其他搜索算法都维持单个解决方案，并迭代地修改它以寻找最佳解决方案。例如，梯度下降算法沿当前最陡下降方向迭代移动当前解，梯度方向为给定函数的梯度的负数。</p></li><li><p>遗传算法的群体初始化规模：太小会导致局部最优解，太大会难以收敛。</p></li><li><p>例子：TSP旅行商问题、背包问题</p></li></ul><h2 id="第五章-不确定知识表示以及推理"><a href="#第五章-不确定知识表示以及推理" class="headerlink" title="第五章 不确定知识表示以及推理"></a>第五章 不确定知识表示以及推理</h2><h3 id="考点-4"><a href="#考点-4" class="headerlink" title="考点"></a>考点</h3><ol><li>贝叶斯网络定义及表示、联合概率表示、构建方法、朴素贝叶斯方法、独立性判断D分离；</li><li>贝叶斯网络边缘概率及条件概率计算。</li></ol><h3 id="贝叶斯网络定义及表示"><a href="#贝叶斯网络定义及表示" class="headerlink" title="贝叶斯网络定义及表示"></a>贝叶斯网络定义及表示</h3><ul><li>定义：它由一个有向无环图（表达了变量之间的有向依赖关系）和一系列条件概率表（衡量了上述关系的强度）组成。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623174719759.png" alt="image-20240623174719759"></li><li>补充：P(e)可推出P(<del>e)（一个参数），需要知道P(c|e)和P(c|</del>e)可推出P(<del>c|e)和P(</del>c|~e)（两个参数）。以此类推。</li><li>贝叶斯网络的构建：<ol><li>在某种变量顺序下，对所有变量的联合概率应用链式 法则 Pr(X1,…,Xn) &#x3D; Pr(Xn|X1,…, Xn-1)Pr(Xn-1|X1,…, Xn-2)…Pr(X1)</li><li>对于每个变量Xi ，考虑该变量的条件集合X1,…,Xi-1，Xi 和Xj 是条件独立的，则将Xj 从Xi 的 条件集合中删除。经过这一步骤，可以得到下式 Pr(X1,…,Xn) &#x3D; Pr(Xn|Par(Xn))Pr(Xn-1|Par(Xn-1))…Pr(X1)。</li><li>基于上述公式，构建一个有向无环图。其中，对于每个用节点表示的变量Xi，其父节点为Par(Xi)中的变量集合。</li><li>为每个家庭（即变量及其父节点集合）确定条件概率表的取值。</li></ol></li></ul><h3 id="朴素贝叶斯方法（上网找些题目看看）"><a href="#朴素贝叶斯方法（上网找些题目看看）" class="headerlink" title="朴素贝叶斯方法（上网找些题目看看）"></a>朴素贝叶斯方法（上网找些题目看看）</h3><ul><li>定义：就是人为定义条件独立的变量，使得式子变得更加简单。即类似**P(A,B,C,D) &#x3D; P(A|B)P(C|B)P(D|B)**。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623180235338.png" alt="image-20240623180235338"></li><li>就是先算给定x向量情况下y为正的可能性和y为负的可能性。</li></ul><p> <a href="https://blog.csdn.net/doge_coding/article/details/130307202">轻松搞定朴素贝叶斯(有例题)_朴素贝叶斯算法例题-CSDN博客</a>这个讲的挺好的。</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><ul><li>极大似然法：就是先把式子列出来，然后对数，再对该式子求导并且等于0。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623180513734.png" alt="image-20240623180513734"></li></ul><h3 id="贝叶斯网络的D-分离"><a href="#贝叶斯网络的D-分离" class="headerlink" title="贝叶斯网络的D-分离"></a>贝叶斯网络的D-分离</h3><ul><li><p>串形连接： 在串行连接中A通过事件B影响C，同样事件C也是用过事件B影响A。我们认为当<strong>证据B确定时</strong>，A、C条件独立。<img src="/2024/12/02/人工智能复习/" alt="image-20200112230651132.png" style="zoom: 200%;"></p></li><li><p>共同的原因：<strong>给定父节点的前提下</strong>，子节点们条件独立。<img src="/2024/12/02/人工智能复习/" alt="image-20200112231016234.png" style="zoom:200%;"></p></li><li><p>共同的作用：<strong>当不给定子节点时</strong>，父节点们条件独立。<img src="/2024/12/02/人工智能复习/" alt="image-20200112231325308.png" style="zoom:200%;"></p></li><li><p>若存在一条路径将这两个节点（直接）连通，则称这两个节点是<strong>相关</strong>的。若不存在这样的路径将这两个节 点连通，则这两个节点就是<strong>独立</strong>的。</p></li></ul><h3 id="贝叶斯网络计算"><a href="#贝叶斯网络计算" class="headerlink" title="贝叶斯网络计算"></a>贝叶斯网络计算</h3><ul><li>就是一直使用加法原理把父节点加入到式子中，然后链式法则，再对式子展开（条件独立就可以删除）。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623181434174.png" alt="image-20240623181434174"></li></ul><h2 id="第七章-机器学习"><a href="#第七章-机器学习" class="headerlink" title="第七章 机器学习"></a>第七章 机器学习</h2><h3 id="考点-5"><a href="#考点-5" class="headerlink" title="考点"></a>考点</h3><ol><li>监督学习（分类与回归，感知机、逻辑回归；神经网络、<strong>反向传播</strong>、CNN、RNN）；</li><li>非监督学习（Kmeans）；</li><li>强化学习（MDP定义、状态值函数和动作值函数、Q学习及SARSA、DQN）。</li></ol><h3 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h3><ul><li>定义：会给定<strong>输入特征</strong>和输出的<strong>标签</strong>（Y）</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>定义：预测<strong>离散</strong>型变量。给定(x1, y1), (x2, y2), …, (xn, yn)，学习一个输入x、预测y的函数f(x)。y是<strong>离散</strong>的。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623195838671.png" alt="image-20240623195838671"></li></ul><h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><ul><li>定义：预测<strong>连续</strong>性变量。给定(x1, y1), (x2, y2), …, (xn, yn)，学习 一个输入x、预测y的函数f(x) 。y是<strong>连续</strong>的。<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240623200254815.png" alt="image-20240623200254815"></li></ul><p>联结主义（Connetionism）学派：认为人工智能源于<strong>仿生学</strong>。（神经网络）</p><h4 id="感知机学习"><a href="#感知机学习" class="headerlink" title="感知机学习"></a>感知机学习</h4><p>解决<strong>二分类问题</strong>的算法。是有监督学习中的<strong>分类</strong>。</p><ul><li><p>定义：主要是处理<strong>线性可分</strong>的数据。对于拥有d个特征的 x&#x3D;(x1,x2,…,xd) , 计算它的带权“分数” 。如果分数大于0则预测为真，分数小于0则预测为假。</p></li><li><p>输入层：感知机接收一组输入特征向量 x&#x3D;(x1,x2,…,xn)，每个输入有一个对应的权重 w&#x3D;(w1,w2,…,wm)。</p></li><li><p>加权求和：输入特征向量和权重向量进行加权求和，计算公式为：<br>$$<br>\begin{equation}<br>z &#x3D; \mathbf{w} \cdot \mathbf{x} + b &#x3D; \sum_{i&#x3D;1}^{n} w_i x_i + b<br>\end{equation}<br>$$<br> 其中，b是偏置。</p></li><li><p>激活函数：加权求和的结果通过激活函数（通常是阶跃函数）进行处理，输出一个二值结果。阶跃函数的定义为：<br>$$<br>f(z) &#x3D;<br>\begin{cases}<br>1 &amp; \text{if } z \geq 0 \<br>0 &amp; \text{if } z &lt; 0<br>\end{cases}<br>$$</p></li><li><p>损失函数：定义为所有误分类点到分类线距离的总和。（M是所有误分类点的集合）<br>$$<br>L(w, b) &#x3D; -\sum_{\mathbf{x}_i \in M} y_i (w \cdot \mathbf{x}<em>i + b)<br>$$<br>修改函数利用梯度下降法：<br>$$<br>\begin{align}<br>\nabla_w L(w,b) &amp;&#x3D; -\sum</em>{\mathbf{x}_i \in M} y_i \mathbf{x}<em>i \<br>\nabla_b L(w,b) &amp;&#x3D; -\sum</em>{\mathbf{x}_i \in M} y_i<br>\end{align}<br>$$</p></li><li><p>感知机学习：</p><ol><li><p>先初始化权重向量w(0)和偏置b , 然后根据D来修正w和b。（通常初始化为0）</p></li><li><p>对于每个训练样本，计算感知机的输出。</p></li><li><p>如果感知机某个样本的输出与真实标签不一致，根据以下规则更新权重和偏置：<br>$$<br>\begin{align}<br>w_{i+1} &amp;\leftarrow w_i + \eta y_i x_i \<br>b &amp;\leftarrow b + \eta y_i<br>\end{align}<br>$$<br>其中η是学习率。</p></li><li><p>跳回第二步。</p></li></ol></li><li><p>分类图片如下：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240623210433383" style="zoom:67%;"></p></li></ul><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>感知机算法只要计算的分数大于0输出标签为真，可是分数<strong>1</strong>和<strong>1000</strong>也是输出标签为真。</p><p>解决<strong>多分类</strong>的算法。</p><ul><li><p>定义：和<strong>感知机学习算法</strong>一样，主要处理线性可分的数据。对于拥有d个特征的 x&#x3D;(x1,x2,…,xd) , 计算一个0到1的概率值，表示<strong>样本属于某个类别的概率</strong>。</p></li><li><p>输入层：感知机接收一组输入特征向量 x&#x3D;(x1,x2,…,xn)，每个输入有一个对应的权重 w&#x3D;(w1,w2,…,wm)。gai</p></li><li><p>加权求和：输入特征向量和权重向量进行加权求和，计算公式为：<br>$$<br>\begin{equation}<br>y &#x3D; \mathbf{w} \cdot \mathbf{x} + b &#x3D; \sum_{i&#x3D;1}^{n} w_i x_i + b<br>\end{equation}<br>$$<br>其中，输出y是该样本属于这个类别的可能性（目前还未经过转化），b是偏置。</p></li><li><p>激活函数：使用Logistic函数将求和y映射到一个介于 0 和 1 之间的概率值：<br>$$<br>\sigma(y) &#x3D; \frac{1}{1 + e^{-y}}<br>$$<br>这里的σ(y)是把刚刚加权求和的总数转换成概率。若y越大，则概率σ(y)就越大。</p></li><li><p>损失函数：定义为交叉熵函数。<br>$$<br>L(w) &#x3D; -\sum_{i&#x3D;1}^{N} \left[ y_i \log(q_i) + (1 - y_i) \log(1 - q_i) \right]<br>$$<br>yi 是第 i 个样本的真实标签（0或1），qi是模型预测的第 i 个样本属于类别 1 的概率。当qi越接近yi，损失函数值就越小。（等价于让损失函数最小）</p><p>修改函数利用梯度下降法：<br>$$<br>\begin{align*}<br>\nabla_{\mathbf{w}} L(\mathbf{w}) &amp; &#x3D; -\sum_{i&#x3D;1}^{N} \left[ y_i - q_i \right] \mathbf{x}_i<br>\end{align*}<br>$$</p></li><li><p>逻辑回归学习：</p><ol><li><p>初始化w和偏置 b，通常可以选择为零或者随机初始化。</p></li><li><p>对于每个训练样本 (xi,yi)，计算模型的预测输出 qi&#x3D;σ(w⋅xi+b)。</p></li><li><p>如果某个样本的输出与真实标签不一致，根据以下规则更新权重和偏置：<br>$$<br>\mathbf{w} \leftarrow \mathbf{w} - \eta  \sum_{i&#x3D;1}^{N} \left[ q_i - y_i \right]\mathbf{x}_i<br>$$</p></li><li><p>跳回第二步。</p></li></ol></li><li><p>其实本质是二分类输出还是0和1，还是一条直线。</p></li></ul><h4 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h4><h5 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h5><ul><li>定义：一个基本的神经网络包括：<strong>输入</strong>、<strong>计算</strong>、<strong>输出</strong>。下图是一个典型的人工神经网络模型，它包含3个输入，1个 输出，以及2个计算功能。<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624000843701" style="zoom:67%;"></li><li>人工神经元：人工神经网络中的计算单位。由下列部分组成：<ol><li>输入信号xi</li><li>一个激活层对输入信号乘上加权求和，神经元的激活层由加权输入的总和确定。</li><li>一个阈值函数 f(x)，该函数通过确定激活是低于还是高于阈值来计算最终输出。</li></ol></li><li>应用：可以实现“与”、“或”功能，可是不能处理异或。<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624002553421" style="zoom: 50%;"></li></ul><h5 id="多层神经网络"><a href="#多层神经网络" class="headerlink" title="多层神经网络"></a>多层神经网络</h5><p>优势：单层神经网络只能处理线性问题，而两层神经网络可以无限逼近<strong>任意连续函数</strong>。面对复杂的非线性分类任务，带一个隐藏层的两层神经网络可以分类的很好。输入和输出节点之间的附加层称为<strong>隐藏层</strong>。</p><p>原因：从输入层到隐藏层时， 数据发生了<strong>空间变换</strong>。这是因为输入层的阈值函数是<strong>非线性</strong>的，对数据进行了转换。</p><p>传递：训练的算法每次迭代都有<strong>前向传递阶段</strong>和<strong>反向传递阶段</strong>。</p><ol><li>前向传递阶段：利用第(l)层处的神经元的输出来计算第(l+1)层的输出。</li><li>反向传递阶段：第(l+1)层的权重在更新第(l)层的权重之前被更新。</li></ol><p>激活函数：</p><ol><li><p>双曲正切函数(tanh)：<br>$$<br>\begin{align}<br>\tanh(x) &amp;&#x3D; \frac{e^x - e^{-x}}{e^x + e^{-x}}\<br>\tanh’(x) &amp;&#x3D; 1 - \tanh^2(x)<br>\end{align}<br>$$</p></li><li><p>sigmoid函数：<br>$$<br>\begin{align}<br>f(x) &amp;&#x3D; \frac{1}{1 + e^{-x}}\<br>f’(x) &amp;&#x3D; f(x) \left(1 - f(x)\right)<br>\end{align}<br>$$<br>函数的<strong>导数</strong>特性很重要！</p></li></ol><p>损失函数：定义为最小二乘法：<br>$$<br>E &#x3D; \frac{1}{2} e^2 &#x3D; \frac{1}{2} (T - O)^2<br>$$<br>为了使用梯度下降调整权重 wjk,我们首先计算在wjk 上误差E的偏导数：<br>$$<br>\begin{align*}<br>\frac{\partial E}{\partial w_{jk}} &amp;&#x3D; \frac{\partial E}{\partial e} \times \frac{\partial e}{\partial O_k} \times \frac{\partial O_k}{\partial w_{jk}} \<br>&amp;&#x3D; -\left( e \right) \times \left( O_k (1 - O_k) \right) \times \left( O_j \right) \<br>&amp;&#x3D; -(T_k - O_k) O_k (1 - O_k) O_j<br>\end{align*}<br>$$</p><img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624193053302" style="zoom:80%;"><p>前向传播输入：</p><ul><li>净输入：<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193550696.png" alt="image-20240624193550696"></li><li>净输出：<img src="/2024/12/02/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240624193620428.png" alt="image-20240624193620428"></li></ul><p>反向传播误差：</p><ul><li>对于<strong>输出层</strong>，定义误差为：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624193737699" style="zoom:80%;"></li><li>对于<strong>隐藏层</strong>，定义误差为：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624193803486" style="zoom:80%;"></li><li><strong>权重更新公式</strong>（利用梯度下降）：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624193903303" style="zoom:80%;"></li><li>缺点：很容易梯度消失，每传递一层梯度就是原本的0.25倍。</li><li><a href="https://www.cnblogs.com/BlairGrowing/p/14982115.html">(<em>´∇｀</em>) 欢迎回来！ (cnblogs.com)</a>把这题刷一下基本没问题了(更改偏置b1和b2的时候，这个偏置项有点特殊，可以看成是一个隐藏层的节点进行处理，o1和o2的Err值都对它影响）<img src="/2024/12/02/人工智能复习/undefined" alt="b9a535cdb2ab277d41473d468584db9" style="zoom: 50%;"></li></ul><h4 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h4><ul><li><p>是<strong>深度学习</strong>算法。主要用于图像识别。</p></li><li><p>卷积计算：如下图<img src="/2024/12/02/人工智能复习/" alt="img" style="zoom:80%;"></p><p>描述卷积的四个量：卷积核个数、<strong>卷积核大小f</strong>、<strong>填充0值p</strong>、<strong>步长s</strong>。</p><p>假设原本大小为拿，卷积结果大小为(n可以是高或者宽)<br>$$<br>\frac{n + 2p - f}{s} + 1<br>$$</p></li><li><p>卷积神经网络的构造</p><ol><li><p>输入层：输入层接收原始图像数据。图像通常由三个颜色通道（红、绿、蓝）组成。（输入数据）</p></li><li><p>卷积层（可以有<strong>多层卷积层</strong>）：将输入图像与卷积核进行卷积，然后再进行<strong>非线性变换</strong>(RELU)，再进行<strong>池化</strong>。（提取特征）RELU函数为：<br>$$<br>\text{ReLU}(x) &#x3D; \max(0, x)<br>$$</p></li><li><p>全连接层：全连接层将提取的特征映射转化为网络的最终输出。（就是多层神经网络）<img src="https://pic1.zhimg.com/v2-f91e88cee5b0d44012a67da8853a8aa2_720w.jpg?source=172ae18b" alt="卷积神经网络（CNN）基础及经典模型介绍（续） - 知乎"></p></li><li><p>输出层：输出层是CNN的最后一层，其神经元的数量<strong>等于分类任务中的类别数</strong>。输出层的激活函数根据任务的不同而选择，例如Softmax用于多分类任务，Sigmoid用于二分类任务。</p></li></ol></li><li><p>卷积神经网络（CNN）是一种深度学习方法，它的发展历史可以追溯到20世纪90年代。最早的CNN是由Yann LeCun等人提出的，他们利用多层感知机（MLP）进行手写数字识别。随着技术的进步，CNN的结构变得越来越复杂，性能也得到了显著提高。</p></li><li><p>输入层用于接收原始数据，通常是图像数据。图像通常由三个颜色通道（红、绿、蓝）组成，每个通道包含图像的像素值。输入层只是数据的初始存储区域，不进行任何处理。</p></li><li><p>卷积层是CNN的核心部分，主要用于提取输入数据的局部特征。卷积层通过在每个位置计算卷积核与输入数据的点积，卷积操作后，特征图通过激活函数进行非线性变换，这种非线性变换使模型能够学习和表示更复杂的特征。池化层用于对卷积层生成的特征图进行下采样，减少特征图的尺寸，从而降低计算复杂度。</p></li><li><p>全连接层位于网络的最后几层，将前面层提取到的特征整合并映射到最终的输出。全连接层类似于传统的多层神经网络，每个神经元与上一层的所有神经元相连。通过全连接层，模型能够基于提取到的特征进行分类或回归任务。</p></li><li><p><strong>卷积神经网络和全连接神经网络区别</strong>：卷积神经网络有<strong>卷积层</strong>能够提取更多的数据特征，并且卷积的时候参数是<strong>共享</strong>的还有<strong>平移不变</strong>性。</p></li></ul><h4 id="循环神经网络（RNN）"><a href="#循环神经网络（RNN）" class="headerlink" title="循环神经网络（RNN）"></a>循环神经网络（RNN）</h4><ul><li><p>是<strong>深度学习</strong>算法，主要用于语言识别。</p></li><li><p>因为其余的神经网络输出只和当前时刻网络的输入相关。可是像预测天气这种问题还是很需要<strong>之前</strong>的数据的。这是一个<strong>有记忆</strong>的神经网络。<img src="https://img-blog.csdnimg.cn/a9f135e2447f4c91aceb93f646580000.gif" alt="img"></p></li><li><p>例如像判断广州是目的地还是出发地，需要看前一个英文单词，所以需要用到之前的记忆。<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624215758219" style="zoom:50%;"></p></li><li><p>简单来说，就是隐藏层的输出还存储在记忆中，并且记忆内容作为隐藏层的输入。<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624214743675" style="zoom:50%;"></p></li><li><p>例子如下：假设所有权重都是1，激活函数都是线性的。</p></li><li><p>第一步：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624215015924" style="zoom:50%;"></p></li><li><p>第二步：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624215128804" style="zoom:50%;"></p></li><li><p>第三步：<img src="/2024/12/02/人工智能复习/undefined" alt="image-20240624215206066" style="zoom:50%;"></p></li><li><p><strong>不同的</strong>输入顺序会影响到循环神经网络的输出，因为是<strong>有记忆</strong>的！</p></li></ul><p>基本上理解卷积神经网络就是眼睛，主要用来图像识别；循环神经网络就像嘴巴，主要用来语言识别。</p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>就是不会给出<strong>标签</strong>的学习。</p><h4 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h4><ul><li><p><strong>聚类</strong>：基于距离度量，将对象集合<strong>聚类到簇(cluster)中</strong>，使得簇内对象的距离<strong>尽量小</strong>，且簇之间对象的距离<strong>尽量大</strong>。</p></li><li><p>向量x和y之间距离公式：</p><ol><li><p><strong>街区距离</strong>：<br>$$<br>d(x, y) &#x3D; \sum_{i&#x3D;1}^{n} |x_i - y_i|<br>$$<br>n是向量的维度。</p></li><li><p><strong>欧式距离</strong>：<br>$$<br>d(x, y) &#x3D; \sqrt{\sum_{i&#x3D;1}^{n} (x_i - y_i)^2}<br>$$<br>n是向量的维度。</p></li></ol></li><li><p>K-Means算法流程：</p><ol><li><strong>初始化</strong>：<ul><li>确定聚类的数目K。</li><li>随机选择K个数据点当作质心。</li></ul></li><li><strong>分配每个点到最近的质心</strong>：<ul><li>对于每个数据点，计算它到每个质心的距离。</li><li>将每个数据点分配到距离最近的质心所属的簇。</li></ul></li><li><strong>更新质心</strong>：<ul><li>对于每个簇，计算所有属于该簇的数据点的平均值，这个平均值就是新的质心。</li><li>更新质心的位置为新的平均值。</li></ul></li><li><strong>重复步骤2和步骤3</strong>：<ul><li>反复执行步骤2和步骤3，直到质心不再发生变化，或者达到预设的迭代次数。</li></ul></li><li><strong>完成聚类</strong>：<ul><li>最终的质心和数据点的分配结果即为K-means算法的输出。</li></ul></li></ol></li><li><p>K-Means算法改进：</p><p>可以发现，一开始选择的质心很重要，很影响算法。所以初始化的质心应该离得越远越好。</p><ul><li><p>K-Means++算法：</p><ol><li><p>计算每个数据点x到最近的一个已选质心的距离</p><p>对于每个数据点 x，计算它到最近的一个已选质心的距离D(x)。假设我们已经选择了m 个质心 c1,c2,…,cm。<br>$$<br>D(x) &#x3D; \min_{i \in {1, 2, \ldots, m}} \text{dist}(x, c_i)<br>$$</p></li><li><p>计算每个点被选中当质心的概率</p><p>将每个数据点 x 到最近质心的距离 D(x) 的平方作为该点被选为下一个质心的概率权重。具体来说，计算概率权重：</p><p>$$<br>P(x) &#x3D; \frac{D(x)^2}{\sum_{y \in X} D(y)^2}<br>$$</p></li><li><p>轮盘赌选择下一个质心</p><p>离被选中的质心越远被选做质心的可能性越大。</p></li></ol></li></ul></li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习基本要素有：<strong>状态</strong>、<strong>动作</strong>、<strong>策略</strong>、<strong>奖励</strong>、值函数（<strong>状态值函数</strong>、<strong>动作值函数</strong>）</p><p>强化学习的基本目标是：<strong>找到最大化奖励的策略</strong>。</p><ul><li><p>状态值函数V(s)：用于评断当前状态s在给定策略π下，未来累计的期望值。<br>$$<br>V^{\pi}(s) &#x3D; \mathbb{E}<em>{\pi} \left[ \sum</em>{t&#x3D;0}^{\infty} \gamma^t R_{t+1} \mid S_0 &#x3D; s \right]<br>$$</p><img src="/2024/12/02/人工智能复习/undefined" alt="image-20240625155050199" style="zoom:50%;"><p>两条公式是<strong>等价</strong>的。</p></li><li><p>动作值函数Q(s,a)：表示在状态 s 下采取动作 a，然后遵循策略 π 时，未来累积奖励的期望值。</p></li></ul><h4 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h4><p>是一种<strong>贪心</strong>算法，学习的策略和实际的策略可能<strong>不同</strong>。<strong>异策略</strong>。</p><p>通过反复的试验和更新，逐渐逼近最优的状态值函数（Q函数），从而找到最优策略。</p><p>更新Q值的公式如下：<br>$$<br>Q(s, a) \leftarrow   r + \gamma \max_{a’} Q(s’, a’)<br>$$<br>其中r是到达s’的奖励。</p><p>更新Q值时，因为是贪心算法，所以取s’状态的<strong>max值</strong>。</p><h4 id="SARSA"><a href="#SARSA" class="headerlink" title="SARSA"></a>SARSA</h4><p>学习的策略与实际执行的策略是<strong>一致</strong>的。<strong>同策略</strong>。</p><p>更新Q值的公式如下：<br>$$<br>Q(s, a) \leftarrow  r + \gamma Q(s’, a’)<br>$$<br>更新Q值时，所以取s’状态的Q值。</p><h4 id="Q-learning-和-SARSA区别"><a href="#Q-learning-和-SARSA区别" class="headerlink" title="Q-learning 和 SARSA区别"></a>Q-learning 和 SARSA区别</h4><ol><li>策略类型<ul><li>Q-learning: Off-policy，学习的策略（最优策略）与执行的策略（探索策略）不同。</li><li>SARSA: On-policy，学习的策略与执行的策略相同。</li></ul></li><li>更新Q值的依据<ul><li>Q-learning: 更新Q值时使用的是新状态s’下的最大Q值（max⁡Q(s′,a′)）。</li><li>SARSA: 更新Q值时使用的是新状态s’下实际选择的动作的Q值（Q(s′,a′)）。</li></ul></li></ol><h4 id="TD时序差分"><a href="#TD时序差分" class="headerlink" title="TD时序差分"></a>TD时序差分</h4><p>更改Q值的时候，还会利用到原本的Q值。</p><ul><li><p>可以与<strong>Q-learning</strong>和<strong>SARSA</strong>混合使用。</p></li><li><p><strong>Q-learning TD</strong>算法公式：<br>$$<br>Q(s, a) \leftarrow (1 - \alpha)Q(s, a) + \alpha \left[ r + \gamma \max_{a’} Q(s’, a’)  \right]<br>$$</p></li><li><p><strong>SARSA TD</strong>算法公式：<br>$$<br>Q(s, a) \leftarrow (1 - \alpha)Q(s, a) + \alpha \left[ r + \gamma Q(s’, a’)  \right]<br>$$<br>α是学习率，γ是折扣因子。</p></li></ul><h4 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h4><p>是<strong>Q-learning算法</strong>和<strong>深度神经网络</strong>结合，并额外引入两个机制<strong>经验回放</strong>和<strong>目标网络</strong>。</p><ul><li><p>经验回放：将智能体探索环境得到的数据储存起来，然后随机采样小批次样本更新深度神经网络的参数。</p></li><li><p>目标网络：额外引入一个目标网络（和Q网络具有同样的网络结构），此目标网络不更新梯度，每隔一段时间将Q网络的参数赋值给此目标网络。</p></li><li><p>实现步骤：</p><ol><li><strong>初始化神经网络</strong>：包括主网络和目标网络的初始化。</li><li><strong>与环境交互</strong>：使用当前策略（通常是 ε-greedy 策略）与环境交互，收集经验数据。</li><li><strong>存储经验</strong>：将每次交互的经验（状态、动作、奖励、下一个状态）存储到经验回放缓冲区中。</li><li><strong>经验回放</strong>：从经验回放缓冲区中随机抽取小批量的经验样本，用于训练主网络。</li><li><strong>Q-learning 更新</strong>：使用抽样的经验样本，计算 Q-learning 的目标并更新主网络的参数。</li><li><strong>更新目标网络</strong>：定期更新目标网络的参数，以保持其与主网络的一致性，但更新频率较低，如每隔一定步数更新一次。</li><li><strong>迭代训练</strong>：重复上述步骤直至收敛或达到预定的训练步数。</li></ol></li><li><p>DQN和深度神经网络区别</p><ol><li><p>概括</p><ul><li>深度神经网络是一种通用的机器学习模型，用于学习输入数据中的复杂模式和特征。</li><li>DQN 是一种强化学习算法，结合了深度神经网络和Q-learning的思想。</li></ul></li><li><p>训练方法</p></li></ol><ul><li>深度神经网络训练通常使用监督学习或无监督学习的方法，通过最小化预测输出与真实标签之间的损失来优化网络参数。</li><li>DQN训练过程是通过交互式学习与环境进行，智能体通过试错和反馈来优化动作值函数。</li></ul></li></ul><h2 id="押题"><a href="#押题" class="headerlink" title="押题"></a>押题</h2><p>谓词归结一题 <strong>贝叶斯网络一题</strong> <strong>A*一题</strong>  <strong>Minimax剪枝一题</strong>  感觉爬山法可能会有一题</p><p><strong>遗传一题</strong> </p><p><strong>Qlearning一题</strong></p><p><strong>k-means一题</strong> </p><p><strong>BP一题</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><h2 id="第一章-操作系统导论"><a href="#第一章-操作系统导论" class="headerlink" title="第一章 操作系统导论"></a>第一章 操作系统导论</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>操作系统位于<strong>计算机用户和计算机硬件之间</strong>，主要目的是<strong>提供环境</strong>来方便帮助用户执行程序。简单来说，操作系统就是<strong>管理硬件资源</strong>和<strong>控制程序执行</strong>的<strong>系统软件</strong>。</p><h3 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h3><p>由<strong>用户</strong>、<strong>应用</strong>、<strong>操作系统</strong>、<strong>硬件</strong>组成。（从上往下看）<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626201011862" style="zoom:67%;"></p><h3 id="计算系统"><a href="#计算系统" class="headerlink" title="计算系统"></a>计算系统</h3><p>基本元素为：<strong>CPU</strong>、<strong>主存</strong>、<strong>IO</strong>、<strong>系统总线</strong>…</p><ol><li>CPU：中央处理器，负责计算机的计算。</li><li>主存：你知我知。<strong>断电后内容会消失</strong>。</li><li>IO：在计算机和外部环境之间移动数据。</li><li>系统总线：提供CPU、主存与I&#x2F;O模块之间的通信通道。</li></ol><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断就是打断当前执行的进程，<strong>立即处理比较紧急</strong>的进程，然后再返回当前进程继续执行。</p><blockquote><p>中断机制的出现是为了协调处理器与外部设备速度不一致的问题，以提高处理器的利用率。<br>试想我们打开了文本编辑器，处理器就不干活了，等着键盘输入，这会浪费多少处理器计算资源？<br>另一种方式是处理器忙自己的，等有输入时再通知处理器。</p></blockquote><ol><li>中断机制的主要原因是<strong>提高性能</strong>。（因为cpu计算的时间和IO的时间差距很大）</li><li>中断分类：分为<strong>硬件中断</strong>和<strong>软件中断</strong>。<ul><li>硬件中断：通常我们说的中断都是硬件中断。例子：<strong>敲击键盘</strong>、<strong>移动鼠标</strong>、<strong>timer</strong>。完成硬件中断后会返回一个<strong>signal</strong>提醒处理器。</li><li>软件中断：<strong>异常</strong>和<strong>系统调用(system call)<strong>。例子：</strong>system call函数</strong>或者<strong>除以0</strong>。</li></ul></li><li>中断实现：<ul><li>中断向量表：中断向量表存储了每种可能的<strong>中断类型</strong>对应的<strong>中断处理程序的起始地址</strong>。</li></ul></li></ol><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>按照<strong>层次</strong>分类。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626203649171" style="zoom: 50%;"></p><p>磁盘可以<strong>随机读取</strong>，可是<strong>磁带只能顺序读取</strong>。</p><h3 id="IO结构"><a href="#IO结构" class="headerlink" title="IO结构"></a>IO结构</h3><ol><li>简单理解成要数据要传输了。</li><li>通用计算机都由CPU和多个设备控制器组成，通过总线连接，每个设备管理某一特定类型的设备。</li><li>通过中断来执行IO：<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626204437935" style="zoom: 50%;">、</li></ol><p>这个设计使得cpu和io设备可以<strong>并行执行</strong>。</p><h3 id="操作系统执行"><a href="#操作系统执行" class="headerlink" title="操作系统执行"></a>操作系统执行</h3><ol><li>引导程序，找到操作系统的代码，并加载简单的内核代码（在硬件层面）。</li><li>加载内核。</li><li>启动系统服务</li><li>用户登录</li><li>用户执行程序</li></ol><h3 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h3><p>计算机要处理的一个计算问题称为<strong>作业</strong>。</p><p>就是一次处理多个作业，把多个作业加载到内存，所以CPU总是有一个作业要执行。</p><p>在作业执行时，用户<strong>不能直接干预</strong>。</p><p><strong>效率快</strong>，因为减少了调作业进内存的时间（一次调一批作业）而且cpu比较少时间空闲。</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626204946402" style="zoom:50%;"><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>有点类似RR算法，就是频繁切换作业，每个用户的作业跑一个<strong>时间片</strong>被换出。</p><p>所以多个用户们可以<strong>交互</strong>。</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>实时操作系统通常用于需要对<strong>任务执行时间</strong>有严格要求的应用领域。</p><p><strong>响应时间保证</strong>：实时操作系统能够保证任务在其要求的时间内完成或响应。</p><p><strong>任务调度机制</strong>：实时操作系统使用特殊的任务调度算法，如<strong>优先级调度</strong>和<strong>周期性调度</strong>，以确保高优先级任务能够及时执行，而不会被低优先级任务阻塞。</p><p>应用于<strong>飞行控制系统</strong>等等。</p><h3 id="双重模式"><a href="#双重模式" class="headerlink" title="双重模式"></a><strong>双重模式</strong></h3><p>包括<strong>内核模式</strong>和<strong>用户模式</strong>。</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626205303231" style="zoom:50%;"><ul><li>硬件会提供一个模式位(bit)来判断当前是内核还是用户。</li><li>当用户<strong>调用系统函数</strong>或<strong>中断</strong>时，会自动<strong>变成内核模式</strong>，返回后<strong>改回用户模式</strong>。</li><li>有些函数<strong>只有内核态</strong>才能调用。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626205754059" style="zoom:50%;"></li></ul><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>书本题目1.8：中断和陷阱的区别，用户程序能否有意产生陷阱，如果能，为什么？</p><p>答：陷阱是<strong>用户程序产生</strong>的软件中断，所以它是<strong>同步</strong>的；中断是由<strong>硬件</strong>发出的信号，接收到信号后需要<strong>异步</strong>的停止当前进程，然后执行对应中断的程序；用户程序能产生陷阱，例如像屏幕输出就是用户程序产生陷阱。</p><blockquote><p>陷阱是由用户程序发出的信号，指示操作系统立即执行某些功能。相反，中断是由硬件发出的给CPU的信号，表示需要立即处理的事件。</p></blockquote><ol start="2"><li>cpu只能读取<strong>主存</strong>和cpu内的<strong>寄存器</strong>。</li></ol><h2 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="headerlink" title="第二章 操作系统结构"></a>第二章 操作系统结构</h2><h3 id="操作系统提供的服务"><a href="#操作系统提供的服务" class="headerlink" title="操作系统提供的服务"></a>操作系统提供的服务</h3><ol><li>程序执行的环境</li><li>提供用户服务：<ul><li>用户界面<ul><li>用户界面、图形用户界面(GUI)</li></ul></li><li>程序执行<ul><li>系统必须把<strong>程序加载到内存并执行</strong></li></ul></li><li>IO操作</li><li>文件系统操作</li><li>通信<ul><li>进程在同一台计算机上交换信息</li></ul></li><li>资源分配</li></ul></li></ol><h3 id="操作系统如何提供服务"><a href="#操作系统如何提供服务" class="headerlink" title="操作系统如何提供服务"></a>操作系统如何提供服务</h3><p>操作系统通过**系统调用(system call)**来向用户提供服务。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626215521162" style="zoom: 80%;"></p><p>系统调用是一种<strong>中断</strong>。</p><h3 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h3><p>将操作系统像洋葱一样分成多层，第0层为硬件(<strong>最底层</strong>)，第N层为用户(<strong>最高层</strong>)。</p><p>每一层<strong>仅使用</strong>更低一层的功能和服务。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626221509216" style="zoom: 67%;"></p><p>操作系统分层：<strong>设备</strong>管理、<strong>文件</strong>管理、<strong>处理器</strong>管理、<strong>存储</strong>管理、<strong>作业</strong>管理。</p><h3 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h3><ul><li><p>宏内核</p><p>宏内核是大而全的管理者。</p><p>宏内核，也被称为单体内核，是一种把所有的<strong>服务都集中在一起</strong>的内核设计。</p><p>它的优点是<strong>性能高</strong>，因为所有服务都在内核中运行，调用过程简单，效率高。</p><p>这种设计也有缺点，如果内核中的一个服务<strong>出现问题</strong>，可能会<strong>影响到整个系统的稳定性</strong>。</p><p>操作系统代表：<strong>Linux</strong>、<strong>Unix</strong>。</p><blockquote><p>就像一个城市的交通系统，所有的道路、桥梁、交通信号灯都是由一个中央指挥系统控制。这种方式的优点是效率高，因为所有的交通运输都在同一个系统内部进行调度，所以调度速度快，交通流畅。然而，缺点也很明显，如果中央指挥系统出现问题，那么整个城市的交通都可能会受到影响，导致严重的交通拥堵。</p></blockquote></li><li><p>微内核</p><p>微内核是小而美的服务商。</p><p>微内核，只<strong>提供最基本的服务</strong>，如进程调度、内存管理等。</p><p>设计优点是<strong>结构简单</strong>，容易理解和修改，如果一个服务出现问题，也<strong>不会影响</strong>到其他服务。</p><p>设计缺点是<strong>性能较低</strong>，因为服务之间的调用需要在内核和用户空间之间进行切换，效率较低。</p><p>微内核提供了一种<strong>消息传递</strong>机制，让<strong>系统程序</strong>和<strong>用户程序</strong>进行交互。</p><blockquote><p>就像一个城市的交通系统中，只有最基本的道路和桥梁是由中央指挥系统控制，其他的如公交、出租车等都是由各自的调度系统进行管理。这种方式的优点是稳定性好，因为即使一个服务出现问题，也不会影响到其他的服务。然而，缺点是效率较低，因为服务之间的调度需要在内核和用户空间之间进行切换，这就像各个调度系统之间需要进行协调，导致交通运输的效率降低。</p></blockquote></li></ul><p>​操作系统代表：<strong>Mach</strong>、<strong>鸿蒙</strong>。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240626221142031" style="zoom: 80%;"></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ol><li>在现代操作系统中，最里层是硬件，最外层是用户，中间是<strong>软件系统（不是操作系统）</strong></li><li>操作系统执行完中断后，会<strong>采取调度算法</strong>从就绪队列中选择下一个进程（<strong>不是被打断的进程</strong>）</li><li>在操作系统的分层管理中，<strong>处理器管理</strong>是在<strong>最内层</strong>，<strong>作业管理</strong>是<strong>最外层</strong>。</li><li>在层次结构中，<strong>外层依赖于内层</strong>。</li></ol><h2 id="补充-中断和异常"><a href="#补充-中断和异常" class="headerlink" title="补充 中断和异常"></a>补充 中断和异常</h2><p>中断分成<strong>硬件中断</strong>和<strong>软件中断</strong>。</p><ul><li>硬件中断：就是平时讲的中断。</li><li>软件中断：分成异常和系统调用(system call)。</li></ul><p>前面介绍的<strong>陷阱是异常的一种</strong>。</p><p>区别：</p><ul><li>来源：<ol><li>中断：外设</li><li>异常：用户的程序</li><li>系统调用：用户的程序</li></ol></li><li>响应方式：<ol><li>中断：异步</li><li>异常：同步</li><li>系统调用：同步</li></ol></li><li>当前指令：<ol><li>中断：与当前指令无关</li><li>软件中断：与当前指令有关</li></ol></li></ul><p>cpu每执行完一条指令就去查看有没有中断信号。</p><p>内核态 to 用户态：执行完特权指令后操作系统主动让出cpu资源</p><p>用户态 to 内核态：只能依靠中断，任意三种中断都可以转换成内核态</p><p>中断是计算机<strong>实现并发</strong>的原因。</p><p><a href="https://blog.csdn.net/qq_26553393/article/details/122239406">1.1.5 中断的概念和作用、内部中断、外部中断、中断机制的基本原理_中断的定义-CSDN博客</a></p><h2 id="第三章-进程"><a href="#第三章-进程" class="headerlink" title="第三章 进程"></a>第三章 进程</h2><h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><p>进程是<strong>执行的程序</strong>。</p><p>一个进程由 <strong>程序</strong>、<strong>数据集合</strong>、<strong>PCB</strong>组成。</p><p>我们强调，程序本身不是进程。程序是<strong>被动实体</strong>（可执行文件），进程是<strong>活动体</strong>。</p><blockquote><p>当一个可执行文件加载到内存时，程序变成进程。</p></blockquote><p>进程是cpu<strong>分配资源</strong>的最小单位。</p><p>一个程序可以是<strong>多个进程</strong>。</p><ul><li><p><strong>进程的组成</strong></p><p>由<strong>栈</strong>、<strong>堆</strong>、<strong>数据段</strong>、<strong>文本段</strong>、<strong>PC</strong>等等组成。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627130158500.png" alt="image-20240627130158500"></p></li><li><p><strong>进程的状态</strong></p><ol><li>新建：进程在被创建。</li><li>运行：进程在被执行中。</li><li>等待：进程在等待发生某个事件（如IO完成）。</li><li>就绪：等待被调度。</li><li>结束：进程已经完成。</li></ol><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627131031378.png" alt="image-20240627131031378"></p><p>图上的中断(interrpt)应该是<strong>硬件中断</strong>，例如像**时间片(timer)**到了，进程就会到就绪队列。</p><p>当一个进程申请了IO，这个进程就会<strong>到等待队列</strong>，等待IO完成再回到就绪队列等待调度。(可以和第一章笔记的IO结构对应着看)</p><p><em><strong>需要掌握：在什么情况下进程的状态会发生什么变化。</strong></em></p></li><li><p><strong>挂起进程</strong></p><p>简单来说，就是<strong>暂时被淘汰出内存</strong>的进程；被操作系统<strong>调出主存到磁盘</strong>里，当主存内存空间<strong>足够</strong>再调用回主存。</p></li><li><p><strong>PCB(进程控制块)</strong></p><p>是<strong>进程的表示</strong>，PCB<strong>存于内核内存</strong>中。</p><p>由以下部分组成：</p><ol><li><strong>进程状态</strong>：当前进程的状态是什么。</li><li>**进程编号(PID)**：进程对应的一个唯一的编号。</li><li><strong>PC</strong>：表示当前进程执行到哪一条指令。(如果是<strong>多线程可能有多个PC</strong>)</li><li><strong>CPU寄存器</strong></li><li><strong>CPU调度信息</strong>：例如像当前进程的优先级。</li><li>…<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240627133213907" style="zoom: 67%;"></li></ol><p><strong>getpid()的原理</strong>：用户调用getpid()函数 – 操作系统转到内核态 – 访问当前进程PCB的PID – 转回用户态并返回PID。</p></li></ul><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>因为每个进程可以有多个PC(多线程)，所以每个进程可以执行多个线程。</p><p>每个线程<strong>共享</strong>进程的<strong>堆</strong>、<strong>文本段</strong>、<strong>数据段</strong>。</p><p>每个进程<strong>独立</strong>的有<strong>PC</strong>、<strong>栈</strong>、<strong>寄存器</strong>。</p><p>之后会详细介绍。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627134128488.png" alt="image-20240627134128488"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>选择<strong>下一个</strong>在CPU上运行的进程。</p><p>目标：<strong>最大化CPU的利用率</strong>。</p><p>调度队列：分为<strong>就绪队列</strong>和<strong>等待队列</strong>。</p><ol><li><p>就绪队列：里面存放着等待被调度的进程。</p></li><li><p>等待队列：等待某件事情(IO)发生的进程。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627135342369.png" alt="image-20240627135342369"></p></li></ol><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>中断机制会<strong>导致CPU从执行当前的任务变成执行系统内核的任务</strong>，所以当中断发生时，我们要<strong>保存好</strong>当前执行的任务，以便在处理中断之后能够复原当前的任务。</p><p>把进程的<strong>PCB</strong>称为进程的<strong>上下文</strong>。</p><p><strong>上下文切换步骤</strong>：</p><ol><li><strong>保存</strong>当前的上下文(PCB)。</li><li><strong>加载</strong>新的要执行的进程上下文。</li></ol><p>上下文切换是一个<strong>单纯的开销</strong>。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627142142920.png" alt="image-20240627142142920"></p><ul><li><p>模式切换 VS 上下文切换</p><p>模式切换不一定会上下文切换：例如当发生中断之后，模式切换成内核态，可是当前进程没变。</p><p>模式切换开销比上下文切换小。</p></li></ul><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><p>利用<strong>PID</strong>来标识进程。</p><p>父进程的PID<strong>小于</strong>子进程的PID。</p><ul><li><p><strong>进程创建</strong></p><p>使用fork()函数来创建新进程。并且父进程的fork()返回值为<strong>子进程的PID</strong>。子进程的fork()返回值为<strong>0</strong>。并且子进程拥有和父进程一样的资源。</p></li><li><p><strong>进程执行</strong></p><p>可以父进程和子进程<strong>并发执行</strong>或者父进程<strong>使用wait()等待子进程执行完</strong>再执行。</p><p>值得一提的是，如果子进程<strong>调用</strong>了exec()的函数，那么会<strong>新创一个program</strong>，把exec()下的代码全部<strong>覆盖</strong>了。</p></li><li><p><strong>进程终止</strong></p><p>使用wait()或者exit()。像下图的例子，父进程使用wait()阻塞自己，等待子进程完成执行后调用exit()像父进程发出一个signal，然后父进程再执行。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627144014620.png" alt="image-20240627144014620"></p></li></ul><p>进程创建的小题目：<a href="https://blog.csdn.net/donaldsy/article/details/108622940">当fork遇上for循环的问题分析 &amp; fork函数_循环中使用forok-CSDN博客</a> 要记得，fork()之后子进程连buffer内的数据也复制了。</p><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>父进程<strong>没有调用</strong>wait()就终止了，导致子进程的系统资源无法回收。成孤儿了。</p><p>解决方法：操作系统的根进程会<strong>定期调用wait()<strong>函数，</strong>回收</strong>孤儿进程的资源。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>当子进程终止可是父进程**还未调用wait()**函数回收资源。</p><p>通常所有进程终止的瞬间都会过渡到僵尸进程，但是一般只是短暂的存在，当父进程调用wait()就会回收资源了。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程根据与其他进程之间的关系分成<strong>独立</strong>和<strong>协作</strong>的。</p><ul><li>独立进程：不与其他进程共享数据的进程。</li><li>协作进程：可以被其他进程影响或者影响其他进程的进程。</li></ul><p>协作进程之间的通信分为 <strong>共享内存</strong>和<strong>消息传递</strong>。</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240627192901128" style="zoom:80%;"><ul><li><p>共享内存</p><p>希望通信的进程之间共享的内存区域，通信双方需要同时映射共享内存到自己的进程内。</p><p>通信是由用户自己控制的，不是由操作系统控制。</p><ul><li><p><strong>生产者-消费者问题</strong></p><p>生产者和消费者进程共享一个buffer(循环数组)和两个逻辑指针in(指向buffer的下一个空位)和out(指向buffer的第一个满位)。</p><ul><li>生产者进程代码：<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627193530453.png" alt="image-20240627193530453"></li><li>消费者进程代码：<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627193556549.png" alt="image-20240627193556549"></li></ul></li><li><p>Posix系统中常用的共享内存的函数：</p><ul><li>shm_open：创建一个共享的内存区域对象。</li><li>ftruncate：给这个对象分配内存。</li><li>mmap：在自己的代码内对这个共享内存区域对象进行映射。</li></ul></li></ul></li><li><p><strong>消息传递</strong></p><p>基本操作为<strong>send</strong>(发送消息)和<strong>receive</strong>(接收消息)。</p><ul><li><p><strong>直接通信</strong></p><p>进程之间必须<strong>明确</strong>命名： </p><ul><li>发送（P，消息）–向进程P发送消息 </li><li>接收（Q，消息）–从流程Q接收消息</li></ul></li><li><p><strong>间接通信</strong></p><p>通过<strong>邮箱</strong>或者端口来发送和to接收消息 </p><ul><li><p>每个邮箱都有一个唯一的id </p></li><li><p>发送（A，消息）–将消息发送到邮箱A</p></li><li><p>接收（A，消息）–从邮箱A接收消息</p></li></ul></li></ul></li><li><p><strong>同步</strong></p><p>消息传递可以是<strong>阻塞</strong>或者是<strong>非阻塞</strong>的。</p><ul><li><p>阻塞发送：在接收进程或者邮箱收到消息之前，发送进程阻塞。</p></li><li><p>阻塞接收：在消息可用之前，接收进程将被阻塞。</p></li><li><p><strong>交会</strong>：若发送和接收两个操作都是阻塞的，则双方进程会产生一个交会。</p></li><li><p>非阻塞操作是<strong>异步</strong>的。</p></li></ul></li><li><p><strong>管道</strong></p><p>把一个进程连接到另一个进程的一个数据流称为一个“管道”，<strong>通常是用作把一个进程的输出通过管道连接到另一个进程的输入</strong>。</p><p>管道内的<strong>接收</strong>和<strong>发送</strong>信息操作都是<strong>阻塞</strong>的。</p><ul><li><p><strong>普通管道</strong></p><p>无法从创建它的进程<strong>外部访问</strong>。通常是父进程用普通管道和子进程进行沟通。<strong>只能用于血缘关系的进程</strong>。</p><p>普通管道数据的流向是<strong>单向</strong>的。要么父进程写，子进程读；要么父进程读，子进程写。</p><p>使用<strong>pipe()函数</strong>创建管道。</p><p><strong>注意：父、子进程哪个功能不用就关闭。</strong>例如：<strong>父进程关闭fd[0]（读端）,子进程关闭fd[1]（写端）</strong></p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240627201459408" style="zoom:67%;"></li><li><p><strong>命名管道</strong></p><p>命名管道比普通管道功能更强大。</p><p>通信是<strong>双向</strong>的。</p><p>通信进程之间不需要父子关系。</p><p>使用**mkfifo()**创建一个文件来交换数据。</p></li></ul></li><li><p><strong>套接字</strong></p><p>每个套接字都由<strong>IP地址</strong>和<strong>端口号</strong>组成。</p><p>套接字161.25.19.8:1625：IP：161.25.19.8，端口：1625。</p></li></ul><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ol><li><p>共享内存和消息传递的区别</p><p>效率：共享内存更好</p><p>安全：消息传递更好</p><p>传输数据大小：共享内存更大</p><p>实现难度：共享内存更难实现</p></li><li><p>互相举命名管道和普通管道更好的例子</p><p><strong>普通管道更好</strong>：父子进程间通信的时候，可以不用调用mkfifo去创建文件。</p><p><strong>命名管道更好</strong>：当两个无关系的进程需要通信时，很明显命名管道更好。</p></li><li><p>shell中的’|’是普通管道还是命名管道</p><p>普通管道</p></li><li><p>fork()之后，父进程和子进程有什么是共享的，什么是不共享的。</p><p>答：共享的有代码段和已经打开的文件；不共享的有内存空间(写时复制)。</p></li></ol><h2 id="第四章-多线程编程"><a href="#第四章-多线程编程" class="headerlink" title="第四章 多线程编程"></a>第四章 多线程编程</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是<strong>CPU调度</strong>和<strong>上下文切换</strong>的基本单位。</p><p>进程 &#x3D; <strong>共享内存</strong> + <strong>多个线程</strong>。</p><p>进程是相互独立的，而线程是不独立的(共享数据)。</p><p>线程和线程间关系</p><ul><li>独立：CPU寄存器、栈、PC、TID。</li><li>共享：进程的数据段、堆、文本段、文件。</li></ul><p>线程对比进程更加<strong>经济</strong>。</p><p>多线程：操作系统在单个进程内支持多个线程并发执行的能力。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627204511454.png" alt="image-20240627204511454"></p><p><strong>简单来说，就是把一个应用程序(进程)的任务拆分了多个小任务，变成一个线程执行一个小任务。</strong></p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li><p><strong>并发</strong>：在单核上多个线程<strong>交互</strong>的执行。制造并行的假像。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627205151645.png" alt="image-20240627205151645"></p></li><li><p><strong>并行</strong>：在多核上<strong>同时执行</strong>多个线程。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240627205226462" style="zoom:150%;"></p></li><li><p>区别：可以看出，<strong>单核是不能并行</strong>的。并行一定是并发的，但并发不一定是并行的。</p></li><li><p>Amdahl定律：并行下计算效率提升多少。<br>$$<br>speedup &#x3D; \frac{1}{S + \frac{1 - S}{N}}<br>$$<br>S是串行执行的部分，1 - S是并行执行的部分，N为核数。</p></li><li><p>数据并行：将相同的数据的子集分布在多个核上，并在核上执行相同操作。**(每个核数据不一样，任务一样)**</p><p>例子：考虑对内存大小为N的数组进行求和</p><p>假设对于双核系统，在核A上计算下标为0到N&#x2F;2的和，在核B上计算下标为N&#x2F;2 + 1到N的和。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627210817105.png" alt="image-20240627210817105"></p></li><li><p>任务并行：将任务而不是数据分配到多个计算核心，每个线程执行唯一的操作，不同线程可以操作相同的数据，也可以操作不同的数据。**(每个核数据一样，任务变了)**<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627210839397.png" alt="image-20240627210839397"></p></li></ul><h3 id="线程控制块-TCB"><a href="#线程控制块-TCB" class="headerlink" title="线程控制块(TCB)"></a>线程控制块(TCB)</h3><p>由<strong>TID</strong>、<strong>线程状态</strong>、<strong>PC</strong>、<strong>CPU寄存器</strong>、<strong>指向父进程的指针</strong>组成。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627211127882.png" alt="image-20240627211127882"></p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>线程分成<strong>用户级线程</strong>和<strong>内核级线程</strong>。</p><ul><li><p>用户级线程</p><p>所有的线程管理工作都由<strong>应用程序</strong>负责 (包括进程切换)。</p></li><li><p>内核级线程</p><p>线程管理工作由<strong>内核</strong>负责。</p></li><li><p>用户级线程通过<strong>调用内核级线程</strong>使用硬件资源。</p></li><li><p><strong>多对一模型</strong></p><ul><li><p>多个用户级线程（ULTs）映射到一个内核级线程（KLT）。</p></li><li><p>在该模型中，线程的切换可以在<strong>用户态</strong>下完成，无需操作系统的干预。</p></li><li><p><strong>操作系统感受不到用户级线程的存在。</strong></p></li><li><p>如果用户级线程被阻塞，那么<strong>整个进程都会被阻塞</strong>。这是因为从操作系统来看，只有内核一个进程，所以如果这个线程被阻塞，内核会把整个进程都阻塞。</p></li><li><p>无法利用多核处理器的并行性，因为从操作系统来看只有一个线程。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627214628856.png" alt="image-20240627214628856"></p></li></ul></li><li><p><strong>一对一模型</strong></p><ul><li><p>每个用户级线程（ULT）映射到一个独立的内核级线程（KLT）。</p></li><li><p>线程创建、管理和调度都由内核负责。</p></li><li><p>一个线程阻塞不会影响其他线程，真正并行执行。</p></li><li><p>线程创建和切换开销较大，因为涉及内核操作。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627214741776.png" alt="image-20240627214741776"></p></li></ul></li><li><p><strong>多对多模型(结合上面两个的优点)</strong></p><ul><li>多个用户级线程（ULTs）映射到多个内核级线程（KLTs）。</li><li>线程调度可以在用户空间和内核空间之间共享，提供更高的灵活性和效率。</li><li>用户级线程的创建和管理灵活，同时可以利用多处理器并行能力。</li><li>一个用户级线程阻塞时，其他线程可以继续执行。</li></ul></li></ul><h3 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h3><p>两种实现：</p><ol><li>在用户空间提供一个没有system call的库。（这意味着创造线程只是调用一个函数）</li><li>实现操作系统支持的内核级的库。</li></ol><p><strong>Pthreads库</strong></p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240627215446976.png" alt="image-20240627215446976"></p><p>fork()<strong>全局变量不共享</strong>，pthread_create()<strong>全局变量共享</strong>。</p><p>就是线程内改了主线程的变量，主线程也会一起改动，因为数据是共享的。</p><p>通常在主线程调用pthread_join()类似父进程调用wait()。</p><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><ul><li><p>线程调用fork()函数：有两种情况，第一种<strong>复制所有线程</strong>；第二种<strong>只复制调用fork()的线程</strong>。</p></li><li><p>线程调用exec()函数：除了调用exec()的线程之外，其他所有线程都将立即消失。并且直接执行exec()函数。</p></li><li><p>信号处理：</p><ul><li>信号用于通知进程某个特定事件已经发生。</li><li>信号传送给进程<ul><li>使用kill(pid, signal)来传递信号</li></ul></li><li>在多线程的进程内，信号传递有三个选项：<strong>传给所有线程</strong>、<strong>传给某些线程</strong>、<strong>传给某个线程</strong>。<ul><li>线程传递信号使用pthread_kill(tid, signal)信号</li></ul></li></ul></li><li><p>线程撤销：在线程结束之前终止它。调用pthread_cancel(tid)这个函数终止线程。</p></li></ul><h3 id="隐式多线程"><a href="#隐式多线程" class="headerlink" title="隐式多线程"></a>隐式多线程</h3><p>随着线程数量的增加，程序的正确性变得越来越困难。</p><p>所以希望线程的创建和管理<strong>不是由程序员</strong>自己控制，而是交由<strong>编译器</strong>自动处理。</p><p>以下是几个方法：</p><ul><li><p>线程池：</p><p>主要思想：在进程开始的时候创建一定数量的线程，并加到池里等待工作。</p><p>使用现有线程处理请求通常比创建新线程快一点；允许将应用程序中的线程数限制到池的大小。</p></li></ul><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ol><li><p>什么时候多线程编程性能比单线程低</p><p>答：当要处理的数据比较小时，多线程编程会因为频繁的上下文切换而导致性能比单线程差。</p></li><li><p>在什么情况下，采用多核多线程方法比单处理器系统的单线程提供更好的性能？</p><p>答：当任务可以被分成多个子任务时，很明显多线程性能更好；当碰到IO密集型的任务，单线程只能进行阻塞，可是多线程可以一个线程阻塞跑去执行另一个线程先。</p><p><a href="https://blog.csdn.net/weixin_44556968/article/details/108810650">多线程就一定比单线程快吗？_多线程一定比-CSDN博客</a></p></li><li><p>有可能并发但却无并行吗？</p><p>答：可能，例如时间片轮转算法，就是单核中不停切换，在单核中实现多任务并发，可是却没有并行。</p></li><li><p>什么是多道程序设计系统？</p><p>答：一次性把一批计算问题同时装入主存并行执行的系统，就叫做多道程序设计系统。</p></li><li><p>多道程序设计提高了系统的吞吐量．但可能会<strong>延长</strong>某些程序的执行时间。</p></li></ol><h2 id="第五章-进程调度"><a href="#第五章-进程调度" class="headerlink" title="第五章 进程调度"></a>第五章 进程调度</h2><h3 id="什么是进程调度？"><a href="#什么是进程调度？" class="headerlink" title="什么是进程调度？"></a>什么是进程调度？</h3><p>从进程的角度观看：进程总是在CPU执行和IO请求中来回切换。</p><p>进程调度：通过多道程序设计获得最大CPU利用率。</p><blockquote><p>简单来说，就是如果有个进程申请IO(等待)时，操作系统就调度一个进程接管CPU，使得CPU一直都是有活干的。</p></blockquote><h3 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h3><p>分成长程调度、中程调度、短程调度。</p><p>调度的频率：长程 &lt; 中程 &lt; 短程。</p><p>主要介绍**短程调度程序(分派程序)**：</p><ul><li>短程调度是指从<strong>就绪队列</strong>中选择一个或多个进程，将处理器分配给它们，以便立即执行。</li><li>分派程序包括：切换上下文、切换到用户模式(<strong>模式切换</strong>)、跳转到用户程序合适的位置，以便重启程序。</li><li>这个程序要尽可能的快，因为每次切换进程都要使用；分派程序停止一个进程而启动另一个可用线程的时间叫分派延迟(调度延迟)。</li></ul><h3 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h3><p>需要进行CPU调度的四种情况：</p><ol><li>运行态–阻塞态(发生IO请求)</li><li>运行态–就绪态(时间片轮转)</li><li>阻塞态–就绪态(IO完成)</li><li>进程终止</li></ol><p>如果调度只发生在第一和第四种情况的话，该CPU调度就是<strong>不可抢占式</strong>的；否则，称为<strong>可抢占式</strong>的。</p><p>在<strong>非抢占式调度</strong>下，一旦CPU分配给进程，进程<strong>将保持CPU</strong>， 直到<strong>终止</strong>或<strong>切换到等待状态释放CPU</strong>为止；</p><h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul><li><strong>CPU利用率</strong>：要让CPU尽可能的忙碌起来。</li><li><strong>吞吐量</strong>：在一个时间单元内，进程<strong>完成的数量</strong>。</li><li><strong>周转时间</strong>：从进程<strong>提交</strong>到<strong>完成</strong>的时间。</li><li><strong>等待时间</strong>：进程在就绪队列中等待被调度的时间之和。</li><li><strong>响应时间</strong>：对于交互系统，周转时间并不是最优准则；响应时间是系统提交请求到产生第一次响应的时间。</li></ul><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><strong>要会画甘特图</strong></p><h4 id="先到先服务-FCFS"><a href="#先到先服务-FCFS" class="headerlink" title="先到先服务(FCFS)"></a>先到先服务(FCFS)</h4><ul><li><p><strong>非抢占</strong>的</p></li><li><p>使用<strong>FIFO队列</strong>实现</p></li><li><p>例子：turnaround time是<strong>周转时间</strong>，例如像P3是时刻2来到的，可是时刻30才完成，所以周转时间为28。</p></li></ul><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628112653761" style="zoom: 50%;"><ul><li>例子：可以发现，<strong>不同的到达顺序</strong>结果会有很大的<strong>差异</strong>。</li></ul><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628112946884" style="zoom:50%;"><h4 id="最短作业优先-SJF"><a href="#最短作业优先-SJF" class="headerlink" title="最短作业优先(SJF)"></a>最短作业优先(SJF)</h4><ul><li>可以是<strong>抢占</strong>的或者<strong>非抢占</strong>的</li><li><strong>最优的算法</strong></li><li>例子：<strong>非抢占</strong>的<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628113756942" style="zoom: 50%;"></li><li>例子：<strong>抢占</strong>的 注意！等待时间是进程在就绪对列等待的时间(<strong>看P1等待时间</strong>)<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628115320441" style="zoom:50%;"></li><li>观察到可抢占式的<strong>平均等待时间</strong>和<strong>平均周转时间</strong>都比非抢占式<strong>低</strong>，可是抢占式需要<strong>频繁上下文切换</strong>，会有不同的<strong>开销</strong>。</li></ul><h4 id="轮转调度-RR"><a href="#轮转调度-RR" class="headerlink" title="轮转调度(RR)"></a>轮转调度(RR)</h4><ul><li>为<strong>分时系统</strong>所设计的</li><li><strong>RR</strong> &#x3D; <strong>FCFS</strong> + <strong>抢占式</strong></li><li>每个进程给定一个较小的时间单位成为<strong>时间片</strong>，时间片用完后， CPU选择另外一个进程调度执行</li><li>如果进程的执行时间少于时间片，进程执行完直接释放CPU。</li><li>假设有n个进程，时间片长度为q，则每个进程等待获得下个CPU时间片的时间不会超过(n-1)*q时间。</li><li>假设有5个进程，时间片长度为20ms，则每个进程每100ms就会获得不超过20ms的CPU使用时间。</li><li>例子：            <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628121446945" style="zoom:50%;"></li><li>RR和SJF对比，虽然RR表现不好，可是它可以实现并发，就是让每个作业都感觉自己被分配了CPU。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628121548619" style="zoom:67%;"></li></ul><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ul><li>分成<strong>抢占式</strong>和<strong>非抢占式</strong>的。</li><li>CPU优先分配资源给具有最高优先级的进程。</li><li>SJF是一个特殊的优先级调度。</li><li>问题：可能会<strong>饥饿</strong>，就是某个进程优先级太低导致一直分配不到资源。</li><li>例子：           <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628163911802" style="zoom:50%;"></li></ul><h4 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h4><ul><li><p>是<strong>优先级调度</strong>(队列间)与<strong>RR</strong>(队列内)结合。</p></li><li><p>通常**前台进程(与用户交互的进程)**会比后台进程优先级更高。</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628164530777" style="zoom:67%;"></li></ul><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628164720837.png" alt="image-20240628164720837"></p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul><li>在支持线程的操作系统中，内核线程才是<strong>操作系统</strong>所调度的。</li><li>用户线程是由<strong>线程库</strong>管理的，内核并不知道。</li><li>用户线程 – 内核线程 – 硬件资源</li></ul><h4 id="用户线程调度"><a href="#用户线程调度" class="headerlink" title="用户线程调度"></a><strong>用户线程调度</strong></h4><p>采用<strong>进程竞争范围</strong>(PCS)：因为通常用户线程的竞争都是发生在<strong>同个进程</strong>内的。</p><h4 id="内核线程调度"><a href="#内核线程调度" class="headerlink" title="内核线程调度"></a>内核线程调度</h4><p>采用系统竞争范围(SCS)：与所有的线程(<strong>整个系统</strong>)竞争。</p><ul><li>API允许创建线程的时候选择哪种竞争范围：</li><li>PTHREAD_SCOPE_PROCESS：使用<strong>PCS</strong>调度来调度线程；</li><li>PTHREAD_SCOPE_SYSTEM：使用<strong>SCS</strong>调度来调度线程；</li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><ul><li><p>刚刚的讨论都是基于一个处理器的。</p></li><li><p><strong>非对称多处理</strong></p><ul><li>让其中一个处理器<strong>处理所有</strong>的调度决定、IO处理。</li><li>这样这个处理器会压力很大。</li></ul></li><li><p><strong>对称多处理(SMP)</strong></p><ul><li>每个处理器自我调度</li><li>所有进程可能处在一个<strong>共同的就绪队列</strong>或者<strong>每个处理器有自己的就绪队列</strong>。</li></ul></li><li><p>处理器亲和性</p><ul><li>尽量让进程一直运行<strong>在同一个处理器</strong>上。</li></ul></li></ul><h3 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h3><p>调度算法必须满足<strong>抢占式</strong>和<strong>优先级</strong>。</p><p>因为该系统要求<strong>高安全性</strong>和<strong>立马响应</strong>。</p><p>目标是最小化<strong>中断延迟</strong>和<strong>调度延迟</strong>。</p><ul><li><strong>中断延迟</strong>：是从CPU收到中断到中断处理程序开始的时间。</li><li><strong>调度延迟</strong>：调度程序从停止一个进程到开启一个新进程的时间</li></ul><p>实时系统分成软和硬。</p><ul><li><strong>软实时系统</strong><ul><li>保证<strong>关键进程比非关键进程先跑</strong></li><li>不保证在ddl内跑完</li></ul></li><li><strong>硬实时系统</strong><ul><li>保证一定在<strong>ddl内跑完</strong></li></ul></li></ul><p>实时系统的进程一般是具有<strong>周期性</strong>的。周期为<strong>p</strong>，截至时间是<strong>d</strong>。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628172910826.png" alt="image-20240628172910826"></p><p><strong>准入调度</strong>：保证进程完成，就承认进程；不能保证进程在ddl前完成，拒绝进程。</p><h4 id="单调速率调度"><a href="#单调速率调度" class="headerlink" title="单调速率调度"></a>单调速率调度</h4><ul><li><strong>抢占式</strong> + <strong>静态优先级</strong></li><li>进程的优先级为周期的倒数；即周期短的进程总是被优先执行。</li><li>由上一点可知，该调度是<strong>最优</strong>的。</li><li>例子：<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628174047888.png" alt="image-20240628174047888"></li></ul><h4 id="最早截至期限优先调度"><a href="#最早截至期限优先调度" class="headerlink" title="最早截至期限优先调度"></a>最早截至期限优先调度</h4><ul><li><strong>抢占式</strong> + <strong>动态优先级</strong></li><li>进程的优先级为截止期限；即截至期限越近的进程总是被优先执行。</li><li>例子：   <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628174456118.png" alt="image-20240628174456118"></li></ul><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><ol><li><p>为什么区分io密集型进程和cpu密集型进程对调度程序是重要的？</p><p>答：可以资源利用率更大化，因为io密集型进程主要都是在执行IO，会执行比较少的计算；cpu密集型也一样。与此同时，io密集型进程(前台)主要都是与用户交互，所以需要优先去处理，才能给用户更好的体验，cpu密集型进程主要是后台进程。</p></li><li><p>什么是饥饿？</p><p>在优先级调度算法中，高优先级的进程总是优先执行。如果系统中不断有高优先级的进程到达，那么低优先级的进程可能永远无法获得CPU时间片，从而陷入饥饿状态。</p></li><li><p>下面哪种算法会导致饥饿：a. fcfs b.sjf c.rr d.priority schedule</p><p>答：最短作业和优先级会导致饥饿。</p></li><li><p>题目：<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628185403693.png" alt="image-20240628185403693"></p><p>![f5eaa1eb0ca210a2da9c9ad41fe1bbe](C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\f5eaa1eb0ca210a2da9c9ad41fe1bbe.jpg)</p></li><li><p>题目：<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628191710831.png" alt="image-20240628191710831"></p></li></ol><h2 id="第六章-同步"><a href="#第六章-同步" class="headerlink" title="第六章 同步"></a>第六章 同步</h2><h3 id="什么是同步"><a href="#什么是同步" class="headerlink" title="什么是同步?"></a>什么是同步?</h3><p>进程同步的主要任务是希望并发的进程们可以有效的<strong>共享资源</strong>和<strong>合作</strong>。</p><h3 id="什么是竞争条件？"><a href="#什么是竞争条件？" class="headerlink" title="什么是竞争条件？"></a>什么是竞争条件？</h3><p>多个进程<strong>并发</strong>且访问同一个<strong>共享数据</strong>，并且该共享数据的值<strong>与进程访问顺序有关</strong>。</p><p>甚至连两个线程并发执行count++指令都会出现竞争：<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628194029709.png" alt="image-20240628194029709"></p><h3 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h3><p>每个进程都有一段代码，称为<strong>临界区</strong>。</p><p>临界区是并发进程中与共享资源有关的程序。</p><p>重要的是，<strong>当一个进程在它的临界区执行时，其他进程不能在他们的临界区执行</strong>。</p><p>临界区解决方案要包括以下三个要求：</p><ol><li><strong>互斥</strong>：如果进程P在临界区内执行，其他进程都不能在其临界区内执行。</li><li><strong>进步</strong>(无死锁)：要保证在临界区内的进程P有干活，就是<strong>临界区内的进程一定要有进展</strong>。这样等待的进程们不会无休止的等待。也可以理解成，如果没有进程在临界区内，需要选择一个进程进入临界区，并且这种选择不能无限推迟。</li><li><strong>有限等待</strong>：当一个进程提交了进临界区的请求，在该进程前进入临界区的进程存在上界。</li></ol><h4 id="Peterson解决方案-软件解决"><a href="#Peterson解决方案-软件解决" class="headerlink" title="Peterson解决方案(软件解决)"></a>Peterson解决方案(软件解决)</h4><ul><li><p>数据结构(共享)</p><ol><li>bool flag[2]：一个布尔类型数组，表示线程是否想进入临界区。</li><li>int turn：一个整型变量，表示哪个线程可以进入临界区。</li></ol></li><li><p>简单思想</p><p>就是把自己的flag设置为1，然后把turn设置为对方，让对方先进入临界区。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628200249825.png" alt="image-20240628200249825"></p></li></ul><h4 id="硬件解决方案"><a href="#硬件解决方案" class="headerlink" title="硬件解决方案"></a>硬件解决方案</h4><p>主要利用<strong>原子性</strong>(不可中断的指令)来实现。</p><p>以下两个是例子：</p><ul><li><p>test_and_set()  （函数实现是<strong>原子</strong>的）                 <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628205829894" style="zoom:67%;"></p></li><li><p>compare_and_swap()（函数实现是<strong>原子</strong>的）                 <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628205933905" style="zoom:67%;"></p></li></ul><h4 id="互斥-自旋-锁"><a href="#互斥-自旋-锁" class="headerlink" title="互斥(自旋)锁"></a>互斥(自旋)锁</h4><p>最<strong>简单解决临界区问题</strong>的工具。</p><p>要求一个进程进入临界区前要aquire()获得锁；退出临界区要release()释放锁。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628202411825" style="zoom:50%;"></p><p>aquire()和release()操作必须是原子性的。</p><ul><li><p>aquire()                                                                                                                           <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628202236154" style="zoom:50%;"></p></li><li><p>release()                                                                                                                       <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628202313057" style="zoom:50%;"></p></li></ul><p>这种实现方法称为<strong>自旋锁</strong>。</p><p>可能会<strong>浪费CPU资源</strong>，可是自旋时<strong>没有上下文切换</strong>；如果等待锁的时间<strong>比较短</strong>，互斥锁还是很<strong>有用</strong>的。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>广义上的互斥锁。</p><p>信号量S定义为整数变量。</p><p>信号量分成**二进制信号量(0,1)<strong>和</strong>计数信号量(&gt;&#x3D;0)**。</p><p>只能通过**wait()(P)<strong>和</strong>signal()(V)**两个原子操作访问。</p><ul><li><p>wait()定义                                                                                                                                           <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628202939968" style="zoom:50%;"></p></li><li><p>signal() 定义                                                                                                                                                    <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628203012713.png" alt="image-20240628203012713"></p></li></ul><p>可以发现这样的信号量实现也是<strong>自旋</strong>的。</p><p>为了避免自旋，我们可以创建一个跟信号量相关的等待队列，把发生阻塞的进程添加至这个队列(并把状态设置为阻塞)，然后让出CPU资源。</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>是一种<strong>资源管理模块</strong>。</p><p>管程是一种高级语言的数据结构，跟信号量差不多，但是更好管理和控制。</p><p>管程内是共享数据和对这些数据进行操作。</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628211207864" style="zoom:67%;"><p><strong>管程提供的功能</strong></p><ol><li>互斥访问：管程确保多个线程对共享变量的访问互斥，即同一时间只有一个线程可以访问共享资源，以避免竞态条件和数据不一致性问题。</li><li>条件等待和通知：管程提供了等待线程满足特定条件的机制，线程可以通过<strong>条件变量</strong>等待某个条件满足后再继续执行，或者通过条件变量通知其他线程某个条件已经满足。</li></ol><blockquote><p>可以将管程理解为一个房间，这个房间里有一些共享的资源，比如变量、队列等。同时，房间里有一个门，只有一把钥匙。多个线程或进程需要访问房间内的资源时，它们需要先获得这把钥匙，一次只能有一个线程或进程持有钥匙，进入房间并访问资源。其他线程或进程必须等待，直到当前持有钥匙的线程或进程释放钥匙，才能获得钥匙进入房间。</p><p>此外，管程还提供了条件变量，类似于房间内的提示牌。线程在进入房间后，如果发现某个条件不满足（比如队列为空），它可以通过条件变量来知道自己需要等待，暂时离开房间，并将钥匙交给下一个等待的线程。当其他线程满足了等待的条件（比如向队列中添加了元素），它可以通过条件变量通知告诉正在等待的线程，使其重新获得钥匙进入房间，并继续执行。</p></blockquote><p><strong>条件变量操作</strong></p><p>假设定义了condition x;</p><ol><li><p>wait()</p><p>调用x.wait()后会把调用操作的进程<strong>挂起</strong>。</p></li><li><p>signal()</p><p>调用x.signal()会<strong>恢复</strong>一个挂起进程。</p></li></ol><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628212233396" style="zoom:67%;"><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><ul><li>数据结构(信号量)<ol><li>mutex 互斥锁</li><li>empty 缓冲区中空位数量</li><li>full 缓冲区中内容数量</li></ol></li><li>生产者代码                                                                                       <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628213812765.png" alt="image-20240628213812765"></li><li>消费者                                                                                            <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628213832802.png" alt="image-20240628213832802"></li></ul><h4 id="读者作者问题"><a href="#读者作者问题" class="headerlink" title="读者作者问题"></a>读者作者问题</h4><p>一个数据集在多个并发进程之间共享。</p><ul><li>Readers—仅读取数据集；它们不执行任何更新 </li><li>Writer — 既能读又能写</li></ul><p>问题–允许多个读者同时读取</p><ul><li>只有一个写者程序可以同时访问共享数据; </li><li>写者在访问数据时，不允许读者访问数据；</li></ul><p>主要考虑<strong>第一读者-作者问题</strong>(即读者优先)</p><ul><li><p>数据结构</p><ol><li>信号量 wsem &#x3D; 1(作者的锁)</li><li>信号量 x &#x3D; 1(用来更改readcount的锁)</li><li>整型 readcount &#x3D; 0</li></ol></li><li><p>作者代码                                                                                <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628214946284.png" alt="image-20240628214946284"></p></li><li><p>读者代码<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240628215046422.png" alt="image-20240628215046422"></p><p>读者先看看有多少个读者进程，然后把读者进程数加加；如果是第一个读者进程，则申请作者的锁，如果作者还在写，第一个读者进程就阻塞；与此同时其他的读者进程(如果有的话)会被阻塞在x这个锁上；如果没有作者在写，则读者拿了作者的锁，作者就写不了了。</p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>哲学家坐在圆桌旁，中间放着一碗米饭。吃饭需要拿到左右2根筷子才能吃饭，然后在完成后释放。</p><p>对于5位哲学家，一碗饭（数据集）；信号量筷子[5]初始化为1；</p><p>代码如下：</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240628215552486" style="zoom:67%;"><p>很明显，上述代码可能会产生死锁，如果五个哲学家同时拿起自己左边的筷子，就会死锁；</p><ul><li>解决方案：只有当chop[i]和chop[i+1%N]为正时，才拿起自己左边的筷子(chop[i])。</li></ul><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><ol><li><p>信号量和互斥锁的区别</p><p>答：互斥锁是用在<strong>多线程互斥</strong>上的，主要是避免多个线程同时访问某个共享变量，即我访问了你就不能访问；信号量是用在<strong>多线程同步</strong>上的，它是多个进程互相告诉其他线程，我干了什么事情，让其他线程再执行某些动作。互斥锁是单个线程获取锁和释放锁，信号量是多个线程wait和signal。</p></li><li><p>互斥和同步的区别</p><p>答：同步侧重于协调线程的执行顺序，而互斥侧重于保护共享资源的安全访问。</p></li><li><p>进程间的互斥与同步分别表示了各个进程间的 (<strong>竞争与协作</strong> )。</p></li><li><p>记得是<strong>不同的信息</strong><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629161445985.png" alt="image-20240629161445985"></p></li></ol><h2 id="第七章-死锁"><a href="#第七章-死锁" class="headerlink" title="第七章 死锁"></a>第七章 死锁</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>当一组进程中的每个进程都在等待某事件(请求资源)，而仅有该组进程中被阻塞的其他进程可以触发某事件，就称为死锁。                                                                              <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629133258736.png" alt="image-20240629133258736"></p><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><p>死锁有四个必要条件：</p><ol><li><strong>互斥</strong>：一次只有一个进程使用一个资源, 其他进程不能访问分配给其他进程 的资源；</li><li><strong>非抢占</strong>：不能强行抢占进程已占有的资源；</li><li><strong>占有并等待</strong>：当一个进程等待其他进程时，继续占有已分配的资源；</li><li><strong>循环等待</strong>：存在一个闭合的进程链， 每个进程至少占有此链中下一个进程所需的一个资源；</li></ol><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><ul><li>P为进程，R为资源，R的小点数量为该种资源R的数量。</li><li>如果是P指向R，代表进程P申请资源R。</li><li>如果是R指向P，代表进程P获得资源R。                                                                         <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629135150815.png" alt="image-20240629135150815"></li></ul><p>如果<strong>无环</strong>则必定<strong>不会存在死锁</strong>。</p><p>如果<strong>有环</strong>则<strong>可能发生死锁</strong>。</p><p>如果<strong>有环</strong>且<strong>每个资源只有一个实例</strong>，<strong>必定发生死锁</strong>。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629135517156.png" alt="image-20240629135517156"></p><h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><p><strong>鸵鸟算法</strong>：完全忽略死锁这个问题，并假设系统永远不会出现死锁。</p><ul><li>死锁避免：银行家算法，在分配资源前得到当前使用资源的额外信息，再判断是否分配资源。</li><li>死锁预防：打破死锁四个必要条件的一个。</li><li>死锁检测：利用检测算法检测是否存在死锁。</li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>互斥、占有并等待、非抢占都比较难打破。</p><ul><li><p>打破<strong>互斥</strong></p><p>共享数据不互斥就不会有死锁了</p></li><li><p>打破<strong>占有并等待</strong></p><p>要求请求其他资源时，一定不能获得资源。</p></li><li><p>打破<strong>非抢占</strong></p><p>假设进程A申请资源a需要等待，则进程A的资源可以被其他进程抢占。</p></li><li><p>打破<strong>循环等待</strong></p><p>把所有的资源类型进行一个递增的排序，并且要求进程申请资源的时候以递增顺序。</p></li><li><p>缺点</p><p>系统性能差，因为每次获取资源都要顺序。</p></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>需要知道每个进程的每种类型资源的最大声明数量。</p><ul><li><p>安全状态</p><p>是指系统能够按某种<strong>进程序列</strong>为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利的执行完成。</p><p>进程序列被称为<strong>安全序列</strong>。</p></li><li><p>非安全状态</p><p>不存在安全序列就称为非安全状态。</p></li></ul><p><strong>安全状态</strong>一定<strong>没死锁</strong>；<strong>非安全状态可能有死锁</strong>。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629142003333" style="zoom:67%;"></p><h5 id="银行家算法-我说必考"><a href="#银行家算法-我说必考" class="headerlink" title="银行家算法(我说必考)"></a>银行家算法(我说必考)</h5><ul><li>每个进程都必须先验地给出最大需求资源的数量；</li><li>当进程请求资源时，如果不能进入安全状态，它必须等待；</li><li>当一个进程获得所有资源时，它必须在有限的时间内返回它们；</li></ul><p>假设有n个进程和m种资源</p><p>存在MAX矩阵、已分配allocate矩阵、还需要Need矩阵、available向量。</p><p>时间复杂度为<strong>O(n^2 * m)</strong></p><p><strong>算法流程</strong>：</p><ol><li>合理性检查：检查请求是否小于available向量。</li><li>试探性分配：假设分配资源后，看看是否处于安全状态；如果是安全状态，则分配；如果是不安全状态，回到一开始的值。</li></ol><ul><li>死锁避免缺点：必须要提前声明每种类型资源的最大申请数。</li></ul><h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>死锁检测算法，和银行家差不多。</p><ul><li><p>死锁恢复</p><p>当检测到死锁时，如何恢复。</p><ol><li>终止所有死锁进程：代价很大</li><li>一次终止一个进程，直到解决死锁问题。</li><li>不断抢占一些进程的资源以便给其他进程使用，直到打破死循环。</li></ol></li></ul><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><ol><li><p>饥饿和死锁的区别？</p><p>答：饥饿是一直分配不到资源，例如在优先级调度中，低优先级一直被高优先级的进程抢占；死锁是一组进程在相互等待组内其他进程的资源。死锁一定是饥饿，饥饿不一定是死锁。</p></li><li><p>可抢占的资源分配策略可以避免死锁(死锁预防)，但是只适用于<strong>主存和处理器</strong>。</p></li><li><p>什么是相关临界区？在进程并发中与涉及相同共享资源的程序段。</p></li></ol><h2 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h2><p>CPU可以直接访问的通用存储是<strong>内存</strong>和<strong>CPU内的寄存器</strong>。</p><p>程序必须从(<strong>磁盘</strong>)放入<strong>内存</strong>，CPU才能运行。</p><h3 id="基地址和限制地址"><a href="#基地址和限制地址" class="headerlink" title="基地址和限制地址"></a>基地址和限制地址</h3><p>每个进程都需要一个单独的内存空间。</p><p>为每个进程提供一个<strong>基地址寄存器</strong>和<strong>限制寄存器</strong>。                                              <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629193815616" style="zoom: 67%;"></p><p>CPU寻址访问流程：<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629194016757" style="zoom:67%;"></p><h3 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h3><p>通常，程序被放在磁盘上。如果执行程序，则需要把程序调入内存。</p><p>调入内存时，需要把程序”<strong>绑定</strong>“在某个内存地址。</p><p>绑定地址可以在<strong>编译时</strong>、<strong>加载时</strong>、<strong>执行时</strong>进行。</p><ul><li><p><strong>编译</strong>时绑定</p><p>如果在编译程序的时候，就已经<strong>知道</strong>进程在内存的地址，那么编译器可以生成<strong>绝对代码</strong>。如果内存地址更改，则需要<strong>重新编译代码</strong>。</p></li><li><p><strong>加载</strong>时绑定</p><p>如果在编译程序的时候，不确定进程的地址，编译器生成<strong>可重定位代码</strong>，绑定拖到加载时。如果地址发生更改，程序要重新加载。</p></li><li><p><strong>执行</strong>时绑定</p><p>如果程序在执行的时候要从内存中移动，那么绑定要等到执行的时候才进行。(需要硬件支持)</p></li></ul><h3 id="逻辑地址空间和物理地址空间"><a href="#逻辑地址空间和物理地址空间" class="headerlink" title="逻辑地址空间和物理地址空间"></a>逻辑地址空间和物理地址空间</h3><p>CPU生成的地址为虚拟地址。</p><p>硬件看到的地址为物理地址。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629200043490.png" alt="image-20240629200043490"></p><h3 id="内存管理单元-MMU"><a href="#内存管理单元-MMU" class="headerlink" title="内存管理单元(MMU)"></a>内存管理单元(MMU)</h3><p>CPU输入逻辑地址到MMU转换出物理地址。</p><p>考虑下面一个简单的例子，设一个重定位寄存器(值为14000)，输入一个逻辑地址346，转换出物理地址为14346。                                    <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629200529930" style="zoom:67%;"></p><p>站在用户角度，内存空间为(0 ~ Max)(逻辑地址)，实际上时(R ~ R + Max)(物理地址)。</p><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>假设如果要整个程序和数据都在内存内才能执行，内存空间利用率不高。</p><p>动态加载就是以<strong>可重定位代码</strong>保存在磁盘内。</p><p>只有一个程序被需要的时候，才会被加载。</p><blockquote><p>例如一个2000行的代码，里面某几行调用了一个函数，那么一开始这个函数可以不在主存内，直到调用这个函数再把该函数的代码调入主存。而不是一开始把2000行代码全都调入主存，浪费内存空间。</p></blockquote><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>进程必须要在内存执行，不过可以把暂时不用的进程”<strong>交换</strong>“到备份存储(磁盘)中，这样实现可能让所有进程的物理空间大于真实的物理空间。<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629201419571" style="zoom:80%;"></p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><p>整个进程的内存是<strong>连续</strong>的。</p><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>先把内存空间划分成多个”区”，然后每个区一个进程。划分的”区”可以是<strong>一样</strong>大的或者<strong>不等大</strong>的。</p><p>一般采用<strong>顺序分配</strong>。</p><p>会<strong>有内部碎片</strong>。</p><p>缺点：因为区数是一开始就决定好的，不够灵活。             <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629202832967" style="zoom:67%;"></p><h4 id="可变分区-蔡国扬实验"><a href="#可变分区-蔡国扬实验" class="headerlink" title="可变分区(蔡国扬实验)"></a>可变分区(蔡国扬实验)</h4><p>使用一个表记录<strong>可用内存</strong>和<strong>已用内存</strong>。</p><p>会<strong>有外部碎片</strong>。</p><ul><li>首次适应：分配<strong>首个</strong>满足的空间给进程。</li><li>最优适应：分配最小的满足的空间给进程。</li><li>最差适应：分配最大的空间给进程。</li></ul><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629203244118.png" alt="image-20240629203244118"></p><h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><ul><li><p>内部碎片</p><p>存在于进程内存内部。</p></li><li><p>外部碎片</p><p>存在于进程内存之间。</p></li></ul><p>解决方式：把所有的空闲的空间通过移动结合成一大块可用内存空间。</p><h3 id="分段-不连续内存分配"><a href="#分段-不连续内存分配" class="headerlink" title="分段(不连续内存分配)"></a>分段(不连续内存分配)</h3><p><strong>没有内部碎片</strong>，<strong>有外部碎片</strong>。</p><p>把程序分成多个段，例如<strong>代码</strong>、<strong>全局变量</strong>、<strong>堆</strong>、<strong>栈</strong>等等。</p><p>每个段的<strong>大小不一</strong>，并且不需要<strong>连续存储</strong>。</p><p>逻辑地址由<strong>段号</strong>和<strong>偏移</strong>组成。(需要检查偏移是否小于limit值)<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629204555029" style="zoom:80%;"></p><h3 id="分页-不连续内存分配"><a href="#分页-不连续内存分配" class="headerlink" title="分页(不连续内存分配)"></a>分页(不连续内存分配)</h3><p><strong>没有外部碎片，有内部碎片</strong>。</p><p>进程的物理地址空间可以是<strong>不连续</strong>的；</p><p>把物理空间分成大小相同的<strong>帧</strong>；逻辑空间分成大小相同的<strong>页</strong>。页和帧大小是一样的。</p><p>如果执行一个进程需要n个页，在物理内存空间需要对应有n个帧。</p><p>CPU生成的逻辑地址由<strong>页码</strong>和<strong>页偏移</strong>组成 。                                <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629205556712" style="zoom:50%;"><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629212226640.png" alt="image-20240629212226640"></p><p>物理地址转换：<img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629205808679" style="zoom:80%;"></p><ul><li><p>页表：保存在内存中，并且使用一个<strong>页表基址寄存器</strong>指向页表地址。</p></li><li><p>在这种情况下，访问数据需要两次访存。(第一次是查页表拿数据地址，第二次是取数据)</p></li></ul><h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>采用了<strong>缓存</strong>的思想。</p><p>TLB每一项由<strong>页码</strong>和<strong>帧码</strong>组成。页表只由<strong>帧码</strong>组成(把页码当下标)。</p><p>当CPU产生一个逻辑地址后，如果该逻辑地址的页码存在于TLB，则直接找到对应的帧码，然后执行。(<strong>访存一次</strong>)</p><p>若页码不在TLB中(TLB miss)，则按照上面，<strong>需要访存两次</strong>；并且把这次逻辑地址的页码加入TLB。(时间局部性)<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629211338718.png" alt="image-20240629211338718"></p><ul><li>有效内存访问时间：<br>$$<br>\begin{equation}<br>\text{Time} &#x3D; P \times T_m + (1 - P) \times 2  T_m<br>\end{equation}<br>$$<br>Tm是访存时间，P为TLB命中率。</li></ul><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>在页表条目中增加一个”有效位”。                                                              <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240629211926499" style="zoom:67%;"></p><h3 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h3><p>假设虚拟内存空间位32位，页大小为12位，那么就有2^20个页，假设每个页表条目为4Byte，那么页表需要4MB存储。我们不想在主存中为每个进程都连续分配4MB存储页表。</p><h4 id="分层分页"><a href="#分层分页" class="headerlink" title="分层分页"></a>分层分页</h4><p>假设为k层页表，访问一个数据需要访存k + 1次。</p><p>像刚刚的假设，我们可以将刚刚的页表拆分成两个页表。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629213327704.png" alt="image-20240629213327704"></p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629213408488.png" alt="image-20240629213408488"></p><p>假设32位虚拟地址为0x12345678，分层分页的具体过程如下：</p><ol><li><strong>虚拟地址分解</strong>：<ul><li>页目录索引：0x12</li><li>页表索引：0x34</li><li>页内偏移量：0x5678</li></ul></li><li><strong>查找顶级页表</strong>：<ul><li>使用0x12从页目录中找到二级页表的基址。</li></ul></li><li><strong>查找二级页表</strong>：<ul><li>使用0x34从二级页表中找到物理页框的基址。</li></ul></li><li><strong>形成物理地址</strong>：<ul><li>将物理页框基址与偏移量0x5678结合，得到最终物理地址。</li></ul></li></ol><h4 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h4><p>每个哈希页表条目都是一个链表(解决碰撞)</p><p>每个哈希页表元素为虚拟页码、物理帧号、指向链表下个元素的指针。</p><p>以虚拟页号作为哈希函数的输入，然后映射，再在映射的链表上面一一对照页码来找寻对应的帧号。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629214009967.png" alt="image-20240629214009967"></p><h4 id="倒置页表"><a href="#倒置页表" class="headerlink" title="倒置页表"></a>倒置页表</h4><p>刚刚描述的页表都是每个进程一个，现在是一个系统只有一个页表。</p><p>虚拟地址为<strong>PID</strong>、<strong>虚拟页号</strong>、<strong>偏移</strong>组成。</p><p>页表条目由<strong>PID</strong>和<strong>虚拟页号</strong>组成。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629214142856.png" alt="image-20240629214142856"></p><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><ol><li><p>请指出内部碎片和外部碎片的区别</p><p>答：首先内部碎片是在进程本身内部的很难被使用(很小)的内存空间，外部碎片是进程间的很难被使用(很小的)内存空间。</p></li><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629215710272.png"></p></li></ol><p>​![50d5b59f1488b30588acc3ce987569b](C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\50d5b59f1488b30588acc3ce987569b.jpg)</p><ol start="3"><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629221817976.png" alt="image-20240629221817976"></p><p>![ef536a6fefef00768e0ecf4b3782588](C:\Users\tam15\Documents\WeChat Files\wxid_canjzsfhjgsb22\FileStorage\Temp\ef536a6fefef00768e0ecf4b3782588.jpg)</p></li><li><p>页表分页的目的是什么？</p><p>节省内存中存储页表的空间。</p></li><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629223233453.png" alt="image-20240629223233453"></p></li><li><p>固定分区分配适合多道程序，但是<strong>有内部碎片</strong>。</p></li><li><p>固定分区分配地址转换公式：<strong>下限寄存器 &lt;&#x3D; 绝对地址(下限寄存器加逻辑) &lt;&#x3D; 上限寄存器</strong></p></li><li><p>可变分区地址转换公式：<strong>基址寄存器 &lt;&#x3D; 绝对地址(逻辑加基址寄存器) &lt;&#x3D; 基址加限长寄存器</strong></p></li><li><p>可变分区地址越界：<strong>逻辑地址 &gt; 限长寄存器</strong>。</p></li><li><p>页式分配转换地址公式：<strong>绝对地址 &#x3D; 帧号 * 帧长度 + 页内偏移</strong></p></li><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630143024076.png" alt="image-20240630143024076"></p></li><li><p>固定分区是采用<strong>静态重定位</strong>，可变分区是采用<strong>动态重定位</strong>。</p></li><li><p>某个作业在执行过程中正在等待________，则该作业不能移动。<strong>IO</strong></p></li><li><p>页式存储管理提供___________逻辑地址，而段式存储管理中段间的逻辑地址是________。 <strong>连续的</strong>，<strong>不连续的</strong></p></li><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630142533176.png" alt="image-20240630142533176"></p></li><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629223730381.png" alt="image-20240629223730381"></p></li></ol><h2 id="第九章-虚拟内存管理"><a href="#第九章-虚拟内存管理" class="headerlink" title="第九章 虚拟内存管理"></a>第九章 虚拟内存管理</h2><p>因为进程执行时应该处于物理内存，策略都倾向要求每个进程在执行前应完全处于内存。</p><p>但是很少用到整个程序，所以是很浪费的。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存：将用户<strong>逻辑内存与物理内存分离</strong>。</p><p>逻辑地址空间可以比物理地址空间<strong>大得多</strong>。</p><p>这是因为：可以执行程序的时候不把整个程序都装入物理内存，而是使用到的时候才装。所以给进程感觉自己拥有很大的内存空间。</p><ul><li>进程看自己的存储视角：通常从地址0开始，连续地址直到空间结束。</li><li>同时，物理内存按照页帧组织，分配给进程的物理帧可以不连续;</li></ul><p>虚拟地址和物理地址转换靠<strong>MMU</strong>。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629230520984.png" alt="image-20240629230520984"></p><h3 id="请求-按需-调页策略"><a href="#请求-按需-调页策略" class="headerlink" title="请求(按需)调页策略"></a>请求(按需)调页策略</h3><p>请求(按需)调页：只有在需要这个程序的时候才加载页面。是一种策略</p><p>类似带<strong>交换</strong>的分页系统。</p><p>使用<strong>调页程序</strong>来把进程<strong>要使用的页</strong>调入内存。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629231422880.png" alt="image-20240629231422880"></p><p>如果进程试图访问<strong>尚未调入内存</strong>的页(即页表有效位为无效)，则会发生<strong>缺页中断</strong>。</p><p><strong>缺页中断处理流程</strong></p><ol><li>先确认是否内存引用是否有效</li><li>然后查看页表的有效位，确认该页表在磁盘而不在内存，并发出缺页中断。</li><li>在物理内存中找个空闲帧(例如使用空闲帧链表)</li><li>从磁盘复制该页到空闲帧</li><li>更新页表和TLB</li><li>重新跑一次被中断的指令</li></ol><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240629232301318.png" alt="image-20240629232301318"></p><p>请求(按需)调页有效访问时间：T &#x3D; (1 - P) * Tm + P * 缺页错误时间</p><p>通常缺页错误时间要远远大于访存时间，所以缺页率P越低越好。</p><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>回想一下，如果进程使用fork()函数，那么子进程要完完全全复制父进程在内存中的页吗？</p><p>其实是不需要的，只有发生改动的时候才创建一个副本。</p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240630012025257" style="zoom: 33%;"><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240630012046460" style="zoom:33%;"><h3 id="Belady异常"><a href="#Belady异常" class="headerlink" title="Belady异常"></a>Belady异常</h3><p>一般来说，帧数越多，缺页率会越低。Belady异常的意思是，随着帧数的增加，缺页率可能会增加。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="FIFO页面置换"><a href="#FIFO页面置换" class="headerlink" title="FIFO页面置换"></a>FIFO页面置换</h4><p><strong>有Belady问题</strong>。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630005424400.png" alt="image-20240630005424400"></p><h4 id="最优页面置换OPT"><a href="#最优页面置换OPT" class="headerlink" title="最优页面置换OPT"></a>最优页面置换OPT</h4><ul><li>置换最长时间不会使用的页面。</li></ul><p>效果最好，缺页率最低，可是最难实现。因为要知道未来信息。</p><p><strong>没有Belady问题。</strong></p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630005626076.png" alt="image-20240630005626076"></p><h4 id="最久未使用页面置换LRU"><a href="#最久未使用页面置换LRU" class="headerlink" title="最久未使用页面置换LRU"></a>最久未使用页面置换LRU</h4><ul><li>置换最长时间没有使用的页</li></ul><p>效果不错，用的是过去的数据。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630005809225.png" alt="image-20240630005809225"></p><p><strong>没有Belady问题。</strong></p><p>可以用<strong>计数器</strong>和<strong>堆栈</strong>实现。</p><h3 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h3><p>所分配的帧必须小于可用帧的数量。</p><p>如果进程的帧减少，那么缺页率会增加，进程效率变低。</p><h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><ul><li><p>平均分配</p><p>n个进程，m个帧，每个进程分到m&#x2F;n个帧。</p></li><li><p>比例分配</p><p>有点像轮盘赌，拥有更多页的进程分配的帧更多。</p></li></ul><h3 id="全局分配和局部分配"><a href="#全局分配和局部分配" class="headerlink" title="全局分配和局部分配"></a>全局分配和局部分配</h3><ul><li>全局分配：进程在选替换帧的时候，可以从整个系统的帧集中选择。</li><li>局部分配：进程在选替换帧的时候，只可以从自己分配的帧集选择。</li></ul><h3 id="系统抖动"><a href="#系统抖动" class="headerlink" title="系统抖动"></a>系统抖动</h3><p>因为进程被分配到的帧不够多，导致一直在缺页，一直在页面置换，最终<strong>页面置换的时间大于执行时间</strong>称为系统抖动。<strong>CPU利用率很低</strong>。</p><h4 id="系统抖动的原因"><a href="#系统抖动的原因" class="headerlink" title="系统抖动的原因"></a>系统抖动的原因</h4><p>操作系统实时监控CPU利用率，如果太低，就增加多道程度；可是如果多道程度太大，就会导致新进程从其他进程抢帧来执行，导致其他进程也会缺页。导致CPU利用率更低。</p><img src="/2024/12/02/操作系统复习/undefined" alt="0b50b9577872eb869ee25805ac9da3b" style="zoom:67%;"><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>利用时间局部性原理来评断。这个Δ要选的好一点，如果太大就会整个进程的页，太小就体现不出局部性。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701003309983.png" alt="image-20240701003309983"></p><p>假设D为i时刻所有进程的工作集总和，如果D &gt; M(可用帧数)的话，将会发生抖动。因为会有进程分不到帧，一直缺页中断。</p><h3 id="分配内核内存"><a href="#分配内核内存" class="headerlink" title="分配内核内存"></a>分配内核内存</h3><p><strong>伙伴系统</strong></p><p>就是一直两个两个分下去，直到分到适合的大小。</p><p>例如：一个21kb的请求<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630012643697.png" alt="image-20240630012643697"></p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701001241796.png" alt="image-20240701001241796"></p><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><ol><li><p>题目                                                                <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240630014055226" style="zoom:67%;"></p><p>9EF -&gt; 0EF</p><p>111 -&gt; 2EF</p><p>700 -&gt; D00</p><p>0FF -&gt; EFF</p></li><li><p>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630015325112.png" alt="image-20240630015325112"></p></li><li><p>题目               <img src="/2024/12/02/操作系统复习/undefined" alt="image-20240630021131799" style="zoom: 80%;"></p></li></ol><p>​(a) 已经在抖动了。</p><p>​(b) 提高多道程度</p><p>​(c) 提高多道程度</p><ol start="4"><li><p>存储管理的目的是<strong>方便用户</strong>和<strong>增加主存利用率</strong>。</p></li><li><p>一个被置换出的页面一定要写回外存吗？</p><p>答：不一定，如果没有被更改就不写了。看修改位。</p></li><li><p>使用虚拟内存的原因：<strong>逻辑上扩展</strong>可使用的主存。</p></li></ol><h2 id="第十二章-大容量存储结构"><a href="#第十二章-大容量存储结构" class="headerlink" title="第十二章 大容量存储结构"></a>第十二章 大容量存储结构</h2><p>主要讲述的是<strong>二级存储</strong>。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630024058951.png" alt="image-20240630024058951"></p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630024307267.png" alt="image-20240630024307267"></p><p>每个盘片有两个盘面，每个盘面有多个圆形磁道，每个磁道又分成多个扇区。</p><p>下图计算磁盘的大小。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630025317616.png" alt="image-20240630025317616"></p><p>读取数据：先找到对应的磁道，再透过旋转到对应扇区读取。</p><p>随机读取耗时很久，因为<strong>需要旋转</strong>。<br>$$<br>T_{IO} &#x3D; T_{寻道时间} + T_{旋转延迟} + T_{传输速率} \<br>T_{定位时间} &#x3D; T_{寻道时间} + T_{旋转延迟}<br>$$</p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>目标：<strong>最小化磁头移动的距离</strong> 。因为磁头距离主要被寻道时间影响，也可以看成<strong>最小化寻道时间</strong>。</p><h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630030145530.png" alt="image-20240630030145530"></p><h4 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h4><p>可能会<strong>导致饥饿</strong>。</p><p>每次选择距离最近的那个柱面。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630030344405.png" alt="image-20240630030344405"></p><h4 id="SCAN调度-电梯"><a href="#SCAN调度-电梯" class="headerlink" title="SCAN调度(电梯)"></a>SCAN调度(电梯)</h4><p>磁臂从磁盘的一端开始，向另一端移动；在移动到每个柱面时处理请求。<strong>当到达磁盘的另一端时</strong>，磁头移动方向反转。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630030702033.png" alt="image-20240630030702033"></p><h4 id="C-SCAN调度"><a href="#C-SCAN调度" class="headerlink" title="C-SCAN调度"></a>C-SCAN调度</h4><p><strong>当到达磁盘的另一端时</strong>，磁臂移动到另一端并且磁头<strong>移动方向不反转</strong>。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630031013878.png" alt="image-20240630031013878"></p><h4 id="LOOK调度"><a href="#LOOK调度" class="headerlink" title="LOOK调度"></a>LOOK调度</h4><p>跟SCAN算法类似，但是<strong>不用走到磁盘的一端</strong>，只需要走到一个方向的最远请求磁盘移动方向改变。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630031151535.png" alt="image-20240630031151535"></p><h4 id="C-LOOK调度"><a href="#C-LOOK调度" class="headerlink" title="C-LOOK调度"></a>C-LOOK调度</h4><p>一样，磁头方向不改变。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630031252299.png" alt="image-20240630031252299"></p><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><ol><li>要确定磁盘上一个块所在的位置必须给出三个参数：______ 、<strong><strong><strong>和</strong></strong></strong> 。柱面号，磁头号，扇区号</li><li>磁盘输入输出时，______是磁头在移动臂带动下移动到指定柱面所花的时间；______是 指定扇区旋转到磁头下所需的时间。它们与信息在______有关。寻找时间（寻道时间）， <strong>延迟时间，磁盘上的位置</strong></li><li>为了减少磁盘移动臂移动所花费的时间，每个文件的信息不是按盘面上的______顺序 存放满一个盘面后，再放到另一个盘面上，而是按______存放。<strong>磁道，柱面</strong></li><li>存储型设备用<strong>块</strong>作传输，IO设备用<strong>字符</strong>。</li><li>题目 <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630221210666.png" alt="image-20240630221210666"></li></ol><h2 id="第十三章-IO系统"><a href="#第十三章-IO系统" class="headerlink" title="第十三章 IO系统"></a>第十三章 IO系统</h2><p>计算机的两个主要工作是<strong>计算</strong>和<strong>IO</strong>。很多时候，主要工作是IO，而不是计算，例如查看网站时。</p><h3 id="IO硬件"><a href="#IO硬件" class="headerlink" title="IO硬件"></a>IO硬件</h3><p>有关IO基本硬件有<strong>设备</strong>、<strong>设备控制器</strong>、<strong>总线</strong>。</p><p>控制设备的内核模块称为**设备驱动程序(Device Driver)**。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630145752151.png" alt="image-20240630145752151"></p><h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>由四个寄存器组成，分别是<strong>输入寄存器</strong>、<strong>输出寄存器</strong>、<strong>状态寄存器</strong>、<strong>命令寄存器</strong>。</p><h3 id="控制器与主机交互"><a href="#控制器与主机交互" class="headerlink" title="控制器与主机交互"></a>控制器与主机交互</h3><ul><li><p><strong>轮询</strong></p><ol><li><strong>从状态寄存器读取忙位，直到该位清零；</strong> </li><li>主机设置读或写位，如果写入，则将数据复制到数据输出寄存器中； </li><li>主机设置命令就绪位； </li><li>控制器设置忙位； </li><li>控制器读取命令寄存器，并看到命令。从数据输出寄存器中 读取一个字节，并向设备执行I&#x2F;O操作； </li><li>传输完成时，控制器清除忙位、错误位、命令准备位；</li></ol><p>有点像自旋锁，很浪费时间。                                                                <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701010029911.png" alt="image-20240701010029911"></p></li><li><p><strong>中断</strong></p><p>当设备准备好服务的时候，再通知CPU，让设备通知CPU准备好的机制为<strong>中断</strong>。</p><p>当CPU收到用户的IO请求，就告诉IO处理器，让他准备好，然后CPU执行其他进程。</p><p>在执行其他进程时，每执行一条指令就查看是否有中断信号。</p><p>如果有中断信号，根据中断向量表找到对应的中断处理程序。</p><p>处理完后再执行进程。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630150737522.png" alt="image-20240630150737522"></p></li></ul><p>​<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630151150386.png" alt="image-20240630151150386"></p><h3 id="设备和内存的数据传输"><a href="#设备和内存的数据传输" class="headerlink" title="设备和内存的数据传输"></a>设备和内存的数据传输</h3><p>可以用<strong>程序控制IO</strong>来传输，或者用<strong>DMA控制器</strong>来传输。</p><h4 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h4><p>DMA可以数据传输绕过CPU(<strong>从而减轻CPU的负担</strong>)，直接让<strong>I&#x2F;O设备</strong>与<strong>内存</strong>进行数据传输。</p><p>简单来说，就是专门有一个处理器DMA来帮助CPU控制传输数据。</p><p>当DMA占用内存总线时，CPU被暂时阻止访问内存。可是CPU可以执行其他工作并且可以访问cache。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630152020136.png" alt="image-20240630152020136"></p><h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><p><strong>阻塞型IO：</strong>当应用程序执行阻塞型时，自己会被调回等待队列，直到该系统调用完成再回到执行。</p><p><strong>非阻塞型IO：</strong>一个例子是用户接口，用来接收键盘输入并同时显示在荧幕上。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630153430966.png" alt="image-20240630153430966"></p><h3 id="Spooling"><a href="#Spooling" class="headerlink" title="Spooling"></a>Spooling</h3><p>就是把外设输出的buffer储存起来，例如一台打印机，我们希望多个进程同时使用，可是我们不希望打印的结果是一张进程A，一张进程B的，所以要把进程A的输出buffer储存起来，先打印完进程A，再打印进程B。</p><h3 id="buffer和高速缓存"><a href="#buffer和高速缓存" class="headerlink" title="buffer和高速缓存"></a>buffer和高速缓存</h3><ul><li><p>高速缓存</p><p>在内存中开个区域，来放置磁盘平时传输的数据，下次IO传输时，就可以先看看高速缓存内有没有这个数据。</p><p>逻辑上是磁盘的，实际上是内存。</p></li><li><p>buffer</p><p>就是高速设备和低速设备数据如果要传输数据的时候，就把数据放到一个buffer，让另一方去读。</p></li><li><p>区别</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240701140226307.png" alt="image-20240701140226307"></p></li></ul><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><ol><li><p>试述外围设备与主存储器之间的DMA数据传送控制方式。</p><p>答：当IO设备准备好，通知DMA控制器，DMA控制器占用内存总线，并且开始数据传输。这段期间，CPU是可以进行计算的，当DMA传输完成后，向CPU发出一个中断信号。</p></li><li><p>设备的独立性是指用户程序使用的设备与实际使用哪台设备无关的一种特性。</p></li><li><p>中断机制传输和DMA传输区别</p><p>答：中断机制传输传输完一次数据之后就要中断，而DMA处理器可以传输一大批数据。中断机制传输说到底还是CPU完成的，DMA传输不是。</p></li><li><p>阻塞型IO和非阻塞型IO区别</p><p><strong>阻塞IO：</strong>在阻塞IO中，一个进程发起一个IO操作后，如果数据还没有准备好，进程就会被挂起（阻塞），直到数据准备好为止。这就像是你在电话中等待对方的回答，你无法做其他的事情。</p><p><strong>非阻塞IO：</strong>在非阻塞IO中，一个进程发起一个IO操作后，如果数据还没有准备好，进程不会被挂起，而是立即返回，进程可以继续做其他的事情。这就像是你在发<a href="https://cloud.tencent.com/product/sms?from_column=20065&from=20065">短信</a>，你发送完短信后，不需要等待对方的回复，你可以做其他的事情。</p></li></ol><h2 id="第十章-文件系统"><a href="#第十章-文件系统" class="headerlink" title="第十章 文件系统"></a>第十章 文件系统</h2><h3 id="什么是文件？"><a href="#什么是文件？" class="headerlink" title="什么是文件？"></a>什么是文件？</h3><p><strong>操作系统对存储设备的物理属性加以抽象，从而定义的逻辑存储单位。</strong></p><p>是<strong>逻辑记录</strong>的一个序列。</p><p>人话：就是拿来存储的。</p><p>再人话：他是二级存储的抽象，我们不需要知道计算机怎么存储的，只需要知道把存储的东西放在文件里面。</p><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><ul><li>文件名称</li><li>文件标识符(Inode)</li><li>文件类型</li><li>文件位置</li><li>文件大小</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>创建文件</li><li>写文件：系统保留写指针。</li><li>读文件：系统保留读指针。</li><li>删除文件</li><li>重定位文件(lseek)</li><li>截断文件：就是把内容清空，但是不删除文件。</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用于<strong>管理</strong>文件系统中的文件和其他目录。</p><p>目录的主要作用是提供一种层次结构，使得文件和目录可以有条理地组织起来，方便用户和程序进行文件的查找、访问和管理。</p><p>接下来，说下目录的结构：</p><h4 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h4><p>所有文件包含在同一个目录。所以<strong>必须要有唯一的名称</strong>。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630162110406.png" alt="image-20240630162110406"></p><h4 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h4><p>每个用户都有自己的<strong>用户文件目录</strong>。不同用户<strong>可以拥有相同命名</strong>的文件，只要主文件目录中的文件名是唯一的。</p><p>这个结构可以有效的让用户隔离，如果用户之间要合作会比较麻烦。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630162332765.png" alt="image-20240630162332765"></p><h4 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h4><p>将二级目录进行推广。允许用户创建自己的子目录和文件。</p><p><strong>不能共享文件或目录</strong>。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630162720120.png" alt="image-20240630162720120"></p><h4 id="无环图目录"><a href="#无环图目录" class="headerlink" title="无环图目录"></a>无环图目录</h4><p>要求目录不能有环。</p><p>允许用户之间可以共享目录。两个程序员可以更好的合作。</p><ul><li>使用<strong>软链接</strong>和<strong>硬链接</strong>进行目录共享。</li><li>软链接：创建一个新文件(新Inode)，内容是path1.</li><li>硬链接：等价于一个Inode有path1和path2。</li></ul><p>可是搜索和<strong>删除变得更加复杂</strong>了。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630163219387.png" alt="image-20240630163219387"></p><h4 id="通用型目录"><a href="#通用型目录" class="headerlink" title="通用型目录"></a>通用型目录</h4><p>在共享文件时更加方便。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630163725766.png" alt="image-20240630163725766"></p><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><ol><li>题目对顺序文件进行读文件操作时，总是从 ( ) 按顺序读出信息。 A．文件头部向后 B．文件尾部向前 C．文件中部开始 D．当前位置开始 <strong>答案是D</strong>           </li><li>文件管理实际上是对<strong>辅助存储空间</strong>管理。</li><li>打开文件的步骤<ol><li>用户使用open函数</li><li>系统拿着file_name去目录找对应的Inode(FCB)</li><li>找到FCB之后，更新进程的已打开文件表</li><li>为该文件分配一个文件描述符。</li><li>返回fd，之后可以用fd对文件进行操作。</li></ol></li><li>题目                                                                    <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630221457916.png" alt="image-20240630221457916"></li></ol><h2 id="第十一章-文件系统实现"><a href="#第十一章-文件系统实现" class="headerlink" title="第十一章 文件系统实现"></a>第十一章 文件系统实现</h2><p>为了提高IO效率，<strong>内存和磁盘之间的IO传输是以块为单位的</strong>。</p><p>一个块为多个扇区。</p><h3 id="什么是文件系统"><a href="#什么是文件系统" class="headerlink" title="什么是文件系统"></a>什么是文件系统</h3><p>文件系统提供高效的磁盘访问，实现对文件的<strong>按名访问</strong>。</p><p>文件系统本身由很多层组成。每层设计用更底层的功能来创建更高层的服务。</p><p>从外到内：<strong>应用程序 – 逻辑文件系统 – 文件组织模块 – 基本文件系统 – IO控制 – 设备</strong></p><img src="/2024/12/02/操作系统复习/undefined" alt="image-20240630190736078" style="zoom:67%;"><h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><p>在<strong>磁盘</strong>上，文件系统包括<strong>如何启动存储在那里的操作系统</strong>、<strong>总的块数</strong>、<strong>空闲块的数量和位置</strong>。</p><ul><li>引导控制块：包含该卷引导操作系统的所需信息。(就是上电之后启动操作系统)</li><li>卷控制块：如分区块的大小、空闲块的数量和指针、空闲的FCB数量。</li><li>目录结构：其实就是一个链表，&lt;filename, inode&gt;。</li><li>每个文件的FCB。</li><li>等等</li></ul><p>类似进程一样，每个文件都有一个FCB(唯一的标识号)。</p><ul><li>FCB文件控制块包括：<strong>文件权限</strong>、<strong>文件日期</strong>、<strong>文件所有者</strong>、<strong>文件大小</strong>、<strong>文件数据块</strong>。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630193751751.png" alt="image-20240630193751751"></li></ul><p>在内存里，文件系统包括<strong>安装表</strong>、<strong>目录缓存</strong>、<strong>系统的打开文件表</strong>、<strong>进程的打开文件表</strong>。</p><h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3><p>目录的操作有<strong>查找</strong>、<strong>增加</strong>、<strong>删除</strong>。</p><p>目录实质上是文件名和Inode的映射。</p><p>所以要实现<strong>按名存取</strong>和<strong>让用户更好的共享</strong>。</p><h4 id="线性列表"><a href="#线性列表" class="headerlink" title="线性列表"></a>线性列表</h4><p>就是<strong>文件名</strong>和<strong>数据块指针</strong>的线性列表。</p><p>你妈的就是拿name去找对应的inum。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630201451936.png" alt="image-20240630201451936"></p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>key为filename去映射。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630201555893.png" alt="image-20240630201555893"></p><h3 id="文件分配空间"><a href="#文件分配空间" class="headerlink" title="文件分配空间"></a>文件分配空间</h3><p>为文件在磁盘分配的常用方法为连续、链接、索引。</p><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>有点类似可变分区算法(可是这是在磁盘)</p><p><strong>连续分配要求，每个文件在磁盘上占有一组连续的块。</strong></p><p>因为每个文件的块都是紧邻着的，所以寻道时间是最短的。</p><p>支持<strong>顺序访问</strong>和<strong>直接访问</strong>。</p><p>缺点：难以在磁盘中找到对应的空间。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630203014236.png" alt="image-20240630203014236"></p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>链接分配解决了连续分配的问题。</p><p>链接分配，每个文件是磁盘块的链表。</p><p>容易增加文件(只需要找到空闲块并加入链表尾部即可)</p><p>缺点：只能顺序访问文件，需要为指针分配额外空间。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630203427208.png" alt="image-20240630203427208"></p><p>链表分配一个重要的变种是文件分配表FAT的使用。</p><p>FAT表的使用与链表相同，优点是查询的时候不用再移动磁头来查询下一个磁盘块的位置，直接查表即可。特别是如果把FAT表加在缓存中。</p><p>可以很好的改善随机访问的时间。(可以查完表之后就知道哪一块)<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630203945904.png" alt="image-20240630203945904"></p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>索引分配：每个文件把指针放在一个<strong>索引块</strong>。</p><p>支持直接访问。</p><p>缺点：专门用一个索引块来储存指针开销很大，会比链表指针大，特别是一个文件只有两三个磁盘块的时候。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630204324189.png" alt="image-20240630204324189"></p><p>因为每个文件都需要一个索引块，索引块应尽可能小。可是如果太小，它不能为大的文件提供足够的指针。</p><p>用多级索引来解决这个问题。</p><p><img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630204752913.png" alt="image-20240630204752913"></p><ul><li><p>要会计算每种块指针能索引多少文件块。文件最大的大小要会算。</p></li><li><p>直接地址索引的表示的文件大小 &#x3D; 直接地址索引数 * 数据块大小</p></li><li><p>一级间接地址索引表示的文件大小 &#x3D; 一级间接地址索引数 * (索引块大小 &#x2F; 地址大小) * 数据块大小</p></li><li><p>二级间接地址索引表示的文件大小 &#x3D; 二级间接地址索引数 * (索引块大小 &#x2F; 地址大小)^2 * 数据块大小</p></li><li><p>就是要先把一个索引块能索引多少个地址算出来，再看情况。</p></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>对于任何类型的访问，连续分配都只需要访问一次就能获得磁盘块。</p><p>对于链接分配，很明显直接访问效能很差。</p><p>索引分配更复杂，效能要看索引结构。</p><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><h4 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h4><p>无脑bit map                          <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630205439347.png" alt="image-20240630205439347"></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>将所有空虚的磁盘块用链表链接起来。<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630205527563.png" alt="image-20240630205527563"></p><h4 id="组"><a href="#组" class="headerlink" title="组"></a>组</h4><p>在第一块空闲磁盘块中存储n个空闲块地址，n-1个磁盘块都是空闲的，第n个磁盘块又有n个空闲地址。</p><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>通常，多个连续分配的文件要同时释放。</p><p>000001111000</p><p>可以表示为(0:5), (9,3)</p><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><ol><li>题目<img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630213332844.png" alt="image-20240630213332844"></li></ol><p>​答：4个直接地址索引为1k，2个一级间接地址索引为 2 * (256 &#x2F; 4) * 256 &#x3D; 32k，一个二级间接地址索引为 (256 &#x2F; 4) * (256 &#x2F; 4) * 256 &#x3D; 1024k，答案是1057k。</p><ol start="2"><li>题目             <img src="/2024/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Users\tam15\AppData\Roaming\Typora\typora-user-images\image-20240630213801015.png" alt="image-20240630213801015"></li></ol><p>​512M</p><ol start="3"><li><p>扇区和块的区别</p><p>扇区是磁盘中<strong>最小的存储单位</strong>。块是操作系统中<strong>最小的逻辑存储单位</strong>。块是抽象(虚拟)出来的。</p></li><li><p>比较三种磁盘分配(连续，链接，索引)的优缺点</p><ol><li><p>连续分配：支持直接访问和顺序访问，但会产生外部碎片。</p></li><li><p>链接分配：只支持顺序访问，不产生外部碎片，但指针需要空间存放，且指针如果丢失，会导致访问文件出错。</p></li><li><p>索引分配：支持直接访问，顺序访问，不产生外部碎片，但也要耗费空间</p></li></ol></li><li><p>链接分配中FAT的优点是什么？</p><p>可以提升随机访问的时间，并且可以直接访问中间的块了，不需要再去一块一块访问。</p></li><li><p>对输入输出设备，输入输出操作的信息传输单位为 ( )。字符</p></li><li><p>对存储型设备，输入输出操作的信息是以 ( ) 为单位传输的。块</p></li><li><p>索引结构为每个文件建立一张索引表，用来存放 ( )。 A．逻辑记录的地址 B．部分数据信息 C．主关键字内容 D．逻辑记录存放位置的指针 D是答案。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
