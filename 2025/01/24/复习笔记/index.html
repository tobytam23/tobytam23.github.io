

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="tanzhuoheng">
  <meta name="keywords" content="">
  
    <meta name="description" content="欢迎大家来看我的笔记~希望对大家有所帮助！">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络复习">
<meta property="og:url" content="https://tobytam23.github.io/2025/01/24/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="TAM CHEOK HANG">
<meta property="og:description" content="欢迎大家来看我的笔记~希望对大家有所帮助！">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tobytam23.github.io/img/computer_network.png">
<meta property="article:published_time" content="2025-01-24T14:39:28.000Z">
<meta property="article:modified_time" content="2025-01-24T15:35:32.030Z">
<meta property="article:author" content="tanzhuoheng">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tobytam23.github.io/img/computer_network.png">
  
  
  
  <title>计算机网络复习 - TAM CHEOK HANG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tobytam23.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Tobytam&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        tanzhuoheng
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-24 22:39" pubdate>
          January 24, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          284 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络复习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="计算机网络温习资料"><a href="#计算机网络温习资料" class="headerlink" title="计算机网络温习资料"></a>计算机网络温习资料</h1><p>作者：哈利波特👑</p>
<p>相信自己，I can do it！</p>
<p>希望可以帮助到大家，祝大家都考100！</p>
<h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><h3 id="什么是因特网？"><a href="#什么是因特网？" class="headerlink" title="什么是因特网？"></a>什么是因特网？</h3><p><strong>定义：</strong>因特网是一个世界范围的计算机网络，，即一个互联了全世界的数十亿计算设备的网络。</p>
<p><strong>组成结构：</strong>端系统（主机）、通信链路、分组交换机（路由器、链路层交换机）、因特网服务提供商（ISP）。</p>
<ul>
<li><strong>端系统（主机）：</strong>例如个人电脑、智能手机、服务器等，通过通信协议相互连接，形成因特网的终端。根据功能可分成<strong>客户</strong>和<strong>服务器</strong>。</li>
<li><strong>通信链路：</strong>包括光纤、电缆、无线信号等，用于在端系统之间传输数据。负责在两点之间传输数据，提供基础的物理连接。</li>
<li><strong>分组交换机：</strong>包括路由器和链路层交换机，用于在网络中转发分组数据，确保数据从源端传递到目的端。负责将传输数据从一个通信链路转发到另一通信链路，实现数据的路由和中转。</li>
<li><strong>因特网服务提供商：</strong>帮助端系统连接入因特网。</li>
</ul>


<blockquote>
<p>可以发现因特网是网络的网络。</p>
</blockquote>
<p><strong>其他概念：</strong></p>
<ul>
<li><strong>分组：</strong>发送端将数据分段，并为每个数据段增加新的头部成为数据包。这个操作叫做分组。</li>
</ul>
<h3 id="什么是协议-（感觉会考）"><a href="#什么是协议-（感觉会考）" class="headerlink" title="什么是协议?（感觉会考）"></a>什么是协议?（感觉会考）</h3><p><strong>定义：</strong>确定多个通信实体之间交换报文的格式以及顺序和收到报文后执行的操作。</p>
<p>网络协议的三要素：<strong>语法、语义和同步</strong>。</p>
<h3 id="什么是网络边缘？"><a href="#什么是网络边缘？" class="headerlink" title="什么是网络边缘？"></a>什么是网络边缘？</h3><p><strong>网络结构</strong> &#x3D; <strong>网络边缘</strong>（应用、主机）+ <strong>网络核心</strong>（路由器）+ 接入网和通信链路</p>
<ul>
<li><strong>接入网：</strong>将端系统物理连接至<strong>边缘路由器</strong>的网络。</li>
<li><strong>边缘路由器：</strong>端系统到其他远程端系统路径上经过的第一个路由器。</li>
</ul>
<blockquote>
<p>计算机网络设计的理念：尽量让复杂的事情在网络边缘处理，使得网络核心越简单越好！</p>
</blockquote>
<h3 id="什么是网络核心？"><a href="#什么是网络核心？" class="headerlink" title="什么是网络核心？"></a>什么是网络核心？</h3><p><strong>定义：</strong>由<strong>分组交换机</strong>和<strong>数据链路</strong>组成的网状结构。</p>
<p><strong>功能：</strong>实现数据交换。</p>
<ul>
<li><p><strong>存储转发传输</strong></p>
<p><strong>定义：</strong>交换机开始向输出链路传输该分组的第一个比特之前，必须先接收到整个分组，即将前面该分组的比特都缓存起来。</p>
<p><strong>链路的传输时间：</strong>假设一条链路发送$$L $$ bit 的分组，链路的传输速率为$$R$$ bps，则链路传输该分组的时间为$$\frac{L}{R}$$ s。 （是将数据包从路由器传向链路）</p>
<blockquote>
<p>记得区分传输时间和传播时间的定义！</p>
</blockquote>
<p>通过$$ N$$条速率为$$R$$的链路组成的路径（所以一共有$$N-1$$个路由器），从源到目的地发送一个分组，端对端时延为。<br>$$<br>d_{end-end}&#x3D;N\frac{L}{R}<br>$$</p>
</li>
<li><p><strong>排队时延和分组丢失</strong></p>
<p><strong>排队时延：</strong>由于节点存储有限，如果不能及时转发出去，会导致收到的信息等一段时间才能转发出去。</p>
<p><strong>分组丢失：</strong>大概率由于缓存满了，导致新接收的包被丢弃。</p>
</li>
<li><p><strong>转发表和路由选择协议</strong></p>
<p>转发表可以看成路牌，告诉分组交换机（路由器）将该分组传向哪个分组交换机。</p>
<p>路由选择协议看成 GPS，告诉你源端系统到目的端系统的最佳路径。</p>
</li>
</ul>
<h3 id="互联网络结构与ISP"><a href="#互联网络结构与ISP" class="headerlink" title="互联网络结构与ISP"></a>互联网络结构与ISP</h3><p>ISP的中心目标：使所有端系统能够彼此发送分组。</p>
<ul>
<li><strong>多层等级结构</strong>：接入（本地）ISP，区域（地区）ISP，第一层（主干）ISP（层级由低到高）。</li>
<li><strong>对等</strong>：同一层相互连接，降低成本。</li>
<li><strong>IXP</strong>：提供多个ISP的对等。</li>
</ul>


<p>为了更快地转发分组，<strong>IXP</strong> 允许两个网络直接连接并交换分组，而不需要通过第三个网络来转发分组。例如上图中，主机 A 和主机 B 通过2个<strong>地区ISP</strong>连接起来了，就不必经过最上层的的<strong>主干ISP</strong>来转发分组。</p>
<h3 id="分组交换网络中的延迟与丢失（本章重点）"><a href="#分组交换网络中的延迟与丢失（本章重点）" class="headerlink" title="分组交换网络中的延迟与丢失（本章重点）"></a>分组交换网络中的延迟与丢失（本章重点）</h3><h4 id="总时延定义"><a href="#总时延定义" class="headerlink" title="总时延定义"></a>总时延定义</h4><p>节点总时延 &#x3D; 处理时延 + 排队时延 + 传输时延 + 传播时延</p>
<ul>
<li><p><strong>处理时延</strong></p>
<p>决定将该分组导向何处所需要的时间（即查看路由转发表），基本上不会考虑。</p>
</li>
<li><p><strong>排队时延</strong></p>
<p>分组在链路上等待被传输的时间。</p>
</li>
<li><p><strong>传输时延</strong></p>
<p>假设用$$L$$表示该分组的长度，对于 $$10Mbps$$ 的以太网链路，速率$$R&#x3D;10Mbps$$，传输时延为$$\frac{L}{R}$$。</p>
<p>简单理解就是，传输时延是路由器将分组推向链路的时间。</p>
<p>与<strong>分组大小</strong>和<strong>传输速率</strong>有关。</p>
</li>
<li><p><strong>传播时延</strong></p>
<p>从链路的起点到达链路终点的所需时间。假设链路长度为$$d$$，传播速率为$$s$$，传播时延为$$\frac{d}{s}$$。</p>
<p>与<strong>链路长度</strong>与<strong>链路的物理媒介</strong>（光纤）有关。</p>
</li>
</ul>
<h4 id="流量强度与排队时延的关系"><a href="#流量强度与排队时延的关系" class="headerlink" title="流量强度与排队时延的关系"></a>流量强度与排队时延的关系</h4><p>假设$$\alpha$$为分组到达队列的平均速率（即每秒到达$$\alpha$$个分组），所有分组的长度为$$L bit$$，传输速率为$$R$$。</p>
<p>定义**流量强度为$$\frac{L\alpha}{R}$$**。($$L\alpha$$为每秒到达队列的比特总数，$$R$$为每秒分组交换机向链路推送的比特总数)</p>
<blockquote>
<p>流量强度一定不能大于1，大于1则表示到达队列的比特数量大于交换机处理的比特数量，即永远处理不完分组，排队时延接近无穷！</p>
</blockquote>


<p>如果流量强度接近 0，排队时延接近 0；当流量强度接近 1，排队时延迅速增加，甚至接近无穷。</p>
<p>当到达速率小于传输速率时，队列中的分组数量将会减少。</p>
<h4 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h4><p>因为排队容量是有限的，如果到达的分组发现排队容量已满，则<strong>路由器会丢弃该分组</strong>。</p>
<p>所以实际上，当流量强度接近 1 时，<strong>排队时延并不会真正的趋向无穷</strong>，因为会丢包。</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul>
<li>瞬时吞吐量：主机 B 接收到文件的速率。</li>
<li>平均吞吐量：主机 B 接收所有$$F bit$$用去$$Ts$$，平均吞吐量为$$\frac{F}{T}$$。</li>
<li><strong>瓶颈链路定义：</strong>一个路径中带宽（传输速率）最小的链路。</li>
</ul>
<p>考虑下列情况：</p>


<p>在一个服务器和一个客户之间具有 $$N $$条链路的网络，这N条链路的传输速率分别是$$R_1, R_2, … , R_N$$。应用短板效应（瓶颈链路）的分析方法，在理想状态下从服务器到客户的文件传输吞吐量是$$min{R_1, R_2, … , R_N}$$。</p>
<p>再考虑下列情况：</p>
<img src="/2025/01/24/复习笔记/35a9d5218c094ab830cebaeff974e223.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<p>在例子中有 10 台服务器和 10 个客户与计算机网络连接。在该核心中有一条所有 10 个下载通过的链路$$R$$，设其传输速率为 $$R$$。假定所有服务器的接入链路具有相同的速率$$R_s$$，所有客户接入链路具有相同的速率$$R_C$$。求该例子的下载吞吐量是多少？<br>**如果$$R$$比$$R_s$$和$$R_C$$要大的太多（而事实上往往如此），那么吞吐量为 $$min {Rs,RC}$$**；而假如$$R$$并不大，假定$$RS&#x3D;2Mbps，RC&#x3D;1Mbps，R&#x3D;5Mbps$$，那么下载的吞吐量则不再是由$$ min {R_S,R_C} $$决定，而是为$$500kbps$$。</p>
<blockquote>
<p>吞吐量与带宽的比较：带宽是单位时间内，链路能传输的最大比特数量；吞吐量是单位时间内，链路传输的真实比特数量。</p>
</blockquote>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换有<strong>分组交换</strong>和<strong>电路交换</strong>两种方式。</p>
<h3 id="协议层次及其服务类型（感觉也重点）"><a href="#协议层次及其服务类型（感觉也重点）" class="headerlink" title="协议层次及其服务类型（感觉也重点）"></a>协议层次及其服务类型（感觉也重点）</h3><p>协议层次(5层因特网协议栈)</p>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="center">协议</th>
<th align="center">封装</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">HTTP、DNS、SMTP等</td>
<td align="center">报文</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">TCP、UDP</td>
<td align="center">报文段</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">IP</td>
<td align="center">数据报</td>
</tr>
<tr>
<td align="center">链路层</td>
<td align="center">Ethernet、802.11</td>
<td align="center">帧</td>
</tr>
<tr>
<td align="center">物理层</td>
<td align="center">~</td>
<td align="center">~</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>链路层交换机：</strong> 实现了链路层协议（第二层协议），在局域网中通过 MAC 地址进行数据转发，因此不需要解析网络层的 IP 地址。</p>
<p><strong>路由器：</strong> 实现了网络层协议（第三层协议），需要解析 IP 地址以确定数据分组的转发目标，从而实现跨网段的通信。</p>
</li>
<li><p><strong>封装：</strong>是指当数据从发送端应用层向下传输到物理层时，每一层都会在数据前或后添加的控制信息。</p>
<blockquote>
<p>对每一层而言，上一层的整个分组被视为有效载荷字段，再加上这一层的首部字段，形成新的数据单元。</p>
</blockquote>
</li>
<li><p><strong>解封装：</strong>当数据到达接收端时，数据从物理层向上传输到应用层的过程中，每一层会<strong>移除</strong>对应的控制信息，并将处理后的数据交给上一层，直到应用层获得原始数据。</p>
</li>
<li><p><strong>分组结构：</strong><br>在每一层，一个数据单元由两部分组成：</p>
<ol>
<li><strong>首部字段：</strong> 包含与该层相关的控制信息。</li>
<li><strong>有效载荷字段：</strong> 即从上一层传递过来的数据。</li>
</ol>
</li>
</ul>


<blockquote>
<p>注意主机实现了整个5层协议，链路交换机和路由器分别实现了2层与3层。这与：网络体系结构把更多的复杂性放在了网络的边缘的观点 不谋而合。</p>
</blockquote>
<h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><p>研发网络应用的核心是写出能够<strong>运行在不同的端系统</strong>和<strong>通过网络彼此进行通信</strong>的程序。</p>
<h3 id="网络应用原理"><a href="#网络应用原理" class="headerlink" title="网络应用原理"></a>网络应用原理</h3><h4 id="应用体系结构"><a href="#应用体系结构" class="headerlink" title="应用体系结构"></a><strong>应用体系结构</strong></h4><p>由应用程序开发者所设计，规定了如何在各种端系统上运行程序。</p>
<p>主要使用的两种应用体系结构是<strong>客户-服务器</strong>和<strong>对等（P2P）体系结构</strong>。</p>
<ul>
<li><p><strong>客户-服务器体系结构</strong></p>
<p>有一个总是打开的主机，称为<strong>服务器</strong>，总是接收很多称为<strong>客户</strong>的其他主机的请求。</p>
<p><strong>特征：</strong></p>
<ul>
<li>服务器具有固定的、<strong>周知的</strong> IP 地址，并且总是打开，所以客户通过向服务器周知的 IP 位置发送分组来表示请求。</li>
<li>客户之间不会进行直接通信，集中式服务，可扩展性差。</li>
</ul>
</li>
<li><p>对等（P2P）体系结构</p>
<p>任何主机都可以作为<strong>服务器方</strong>和<strong>客户方</strong>。</p>
<p><strong>特征：</strong></p>
<ul>
<li><p>基本没有专门作为服务器的主机。</p>
</li>
<li><p>分布式服务，可扩展性好和成本低。</p>
</li>
</ul>
</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h4><p>发送端和接收端通过计算机网络<strong>交换报文</strong>进行通信。</p>
<blockquote>
<p>主要考虑的是运行在不同端系统的进程（程序）进行通信。发起通信的进程称为客户，接收通信的进程是服务器。</p>
</blockquote>
<p>进程通过<strong>套接字</strong>（Socket）向网络<strong>发送报文</strong>和<strong>接收报文</strong>。</p>


<p>类似于寄信，<strong>进程可类比于一座房子</strong>，而它的<strong>套接字可以类比于它的门</strong>。当一个进程想向位于另一套主机上的进程发送报文时，它把报文推出该门（套接字）。该发送进程假定该门到另外一侧之间有运输的基础设施（下层网络结构），该设施将报文传送到目的进程（另一座房子）的门口。一旦该报文抵达目的主机，它通过接收进程的门（接收进程的套接字）传递，然后接收进程对该报文进行处理。</p>
<h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>在一台主机上运行的客户进程为了向另一台主机运行的进程发送分组，需要得知接收进程的地址。接收进程的地址由<strong>主机地址</strong>和该<strong>接收进程在目的主机上的标识符</strong>（因为一个主机可能同时运行多个网络应用）。</p>
<ul>
<li>主机地址：即主机的 IP 地址。</li>
<li>接收进程在目的主机上的标识符：即目的端口号。</li>
</ul>
<p>即通过 <strong>IP地址 + 端口号</strong> 来唯一地标识网络上的进程。</p>
<h4 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h4><p>因特网为应用程序提供 TCP 和 UDP 两个运输层协议。</p>
<ul>
<li>TCP协议：提供<strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong>。</li>
<li>UDP协议：只提供最低限度的服务，提供一种不可靠数据传输服务。开销比TCP协议小。</li>
</ul>
<p>当一个运输层协议不提供可靠数据传输服务，可能会导致从发送进程发送的某些分组不能到达接收进程。</p>
<ul>
<li><strong>容许丢失的应用：</strong>某些应用允许丢包的情况，例如打电话。容许丢失的应用可以使用 UDP 协议。</li>
</ul>
<p>具有吞吐量要求的应用程序称为<strong>带宽敏感的应用</strong>，能够根据当前可用的带宽或多或少的利用可使用的吞吐量的应用程序称为<strong>弹性应用</strong>。</p>
<ul>
<li>带宽敏感的应用：视频会议的音频和视频、交互式游戏。</li>
<li>弹性应用：文件传输、电子邮件、Web文档、智能手机讯息。</li>
</ul>
<h4 id="应用层协议内容"><a href="#应用层协议内容" class="headerlink" title="应用层协议内容"></a>应用层协议内容</h4><ul>
<li>交换的报文类型（请求&#x2F;响应报文）</li>
<li>各种报文之间的语法（报文内包括了哪些字段）</li>
<li>报文中字段的含义（字段如何解读）</li>
<li>报文的响应规则（何时以及如何发送报文）</li>
</ul>
<h3 id="Web和HTTP（本章重点）"><a href="#Web和HTTP（本章重点）" class="headerlink" title="Web和HTTP（本章重点）"></a>Web和HTTP（本章重点）</h3><p>Web 可以想象成是一个应用，HTTP 是 Web 的应用层协议。</p>
<h4 id="Web（不重要）"><a href="#Web（不重要）" class="headerlink" title="Web（不重要）"></a>Web（不重要）</h4><p>首先先介绍 Web 的组成：</p>
<ul>
<li><p><strong>Web页面：</strong>由<strong>对象</strong>组成，对象可以是 HTML文件，JP、EG图像 等，Web页面包含一个基本的 HTML文件 和多个引用对象。通过<strong>URL</strong>对每个对象进行引用。</p>
</li>
<li><p><strong>URL地址</strong> ：存放该对象的服务器名（主机名）+ 对象在该服务器中的路径名。</p>
<p>例如<code>URL：http://www.someschool.edu/somedepartment/picture.gif</code>，其中的<code>www.someschool.edu</code>就是主机名，<code>/somedepartment/picture.gif</code> 就是路径名。</p>
</li>
</ul>
<h4 id="HTTP（非常重要）"><a href="#HTTP（非常重要）" class="headerlink" title="HTTP（非常重要）"></a>HTTP（非常重要）</h4><p>Web的应用层协议就是<strong>HTTP协议</strong>(超文本传输协议)，它是Web的核心。</p>
<ul>
<li><p>Web浏览器实现了 <strong>HTTP 客户端</strong>，Web服务器实现了 <strong>HTTP 服务器端</strong>，用于存储 Web 对象。</p>
</li>
<li><p>HTTP使用了<strong>TCP</strong>作为它的支撑运输协议。</p>
<blockquote>
<p>这里我们看到分层结构的优点，即HTTP不用担心分组会丢失，也不关心TCP协议如何处理丢失的分组如何恢复。</p>
</blockquote>
</li>
<li><p>HTTP是一个<strong>无状态协议</strong>，即服务器不会记录任何有关客户的状态信息。</p>
</li>
<li><p>端口号为<strong>80</strong>。</p>
</li>
</ul>
<h4 id="非持续连接和持续链接"><a href="#非持续连接和持续链接" class="headerlink" title="非持续连接和持续链接"></a>非持续连接和持续链接</h4><p>首先先介绍<strong>RTT（往返时间）：</strong>是指一个分组从客户发送到服务器然后再从服务器到达客户所用的时间。</p>
<ul>
<li><p><strong>非持续连接</strong>：每个请求\响应报文都经一个单独的TCP连接进行传送。</p>
<p>假设采用<strong>非持续连接</strong>的情况从服务器向客户发送一个Web页面：</p>
<ul>
<li>一个Web页面有1个HTML基本文件和10个其他对象，每次都建立TCP连接、请求响应，共11次。</li>
</ul>
<p>粗略的讲，<strong>传输一个对象所用的时间 &#x3D; 两个RTT + 服务器传输对象文件所用的时间</strong>。</p>




<blockquote>
<p>TCP建立连接需要三次握手，前两次握手算作一个RTT，第三次握手时客户实际上已经向服务器发送 HTTP请求了，所以一共是两个RTT。</p>
</blockquote>
</li>
<li><p><strong>持续链接</strong>：所有的请求\响应报文都经同一个TCP连接进行传送。</p>
<p>减少了TCP连接<strong>创建</strong>和<strong>关闭</strong>的开销。</p>
</li>
</ul>
<h4 id="HTTP报文格式（这里简单看看）"><a href="#HTTP报文格式（这里简单看看）" class="headerlink" title="HTTP报文格式（这里简单看看）"></a>HTTP报文格式（这里简单看看）</h4><p>HTTP报文格式分为两种，<strong>请求报文</strong>和<strong>响应报文</strong>。</p>
<h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5>

<p>请求报文的第一行叫做<strong>请求行</strong>，其后续的行叫做<strong>首部行</strong>，最后的是<strong>实体体</strong>（实体体和首部行中有一个空行）。</p>
<p>请求行由三个字段组成：<strong>方法字段</strong>、<strong>URL字段</strong>、<strong>HTTP版本字段</strong>。</p>
<ul>
<li><p>方法字段：可以取很多不同的值（不单单只是 GET）。</p>
<img src="/2025/01/24/复习笔记/178a072a39d6a45accbccefd7e2b75af.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%;">

<blockquote>
<p>使用GET方法时，实体体（即回车换行符右边的部分）是全空的。</p>
<p>当使用POST方法才会使用实体体，例如用户在搜索引擎打出关键字搜索时，（如果使用POST方法）客户的HTTP请求报文的实体体内容是该关键词。</p>
<p>用户在搜索引擎打出关键字搜索时，也可以使用GET方法，不过要更改请求行中URL结构，例如输入关键词banana，monkey，则URL &#x3D; 原本URL?name1&#x3D;banana&amp;name2&#x3D;monkey，如果输入重要信息可能会泄露！</p>
</blockquote>
</li>
<li><p>URL字段：请求对象的标识。</p>
</li>
<li><p>HTTP版本字段：表示 HTTP 使用的版本。</p>
</li>
</ul>
<p>首部行由 <strong>Host字段</strong>、<strong>Connection字段</strong>、<strong>User-agent字段</strong>、<strong>Accept-language字段</strong>组成。</p>
<ul>
<li><p>Host字段：表示所请求对象在的主机。</p>
</li>
<li><p>Connection字段：表示是否持续连接。</p>
</li>
<li><p>User-agent字段：向服务器发送的浏览器的类型。</p>
<blockquote>
<p>User-agent字段可以让服务器根据不同的浏览器，返回相同对象的不同版本。即类似iphone和电脑浏览相同网页，但是网页的输出大小肯定不一样。</p>
</blockquote>
</li>
<li><p>Accept-language字段：表示客户想得到该对象的语言版本。</p>
</li>
</ul>
<h5 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h5><p>由三个字段：<strong>初始状态行</strong>、<strong>首部行</strong>、<strong>实体体</strong>组成。</p>


<p>状态行由三个字段组成：<strong>协议版本字段</strong>、<strong>状态码</strong>、<strong>相应状态信息</strong>。</p>
<ul>
<li>一些常见的状态码：<strong>200</strong>（请求成功，信息在返回的报文内）、<strong>404</strong>（被请求的文档不在服务器上）、<strong>301</strong>（请求的对象被永久转移了，新的URL定义在响应报文的<code>Location</code>字段中）…</li>
</ul>
<p>首部行由<strong>Connection字段</strong>、<strong>Date字段</strong>、<strong>Server字段</strong>、<strong>Last-Modified字段</strong>、<strong>Content-Length字段</strong>、<strong>Content-Type字段</strong>组成。</p>
<ul>
<li>Date字段：表示服务器检索到请求对象并加入到响应报文发送的时间。</li>
<li>Server字段：表示这份报文由哪个类型的服务器产生。</li>
<li>Last-Modified字段：表示该请求对象最后更改的日期。</li>
<li>Content-Length字段：表示该请求对象的字节数。</li>
<li>Content-Type字段：表示请求对象的类型。（例如Html文本之类的）</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>HTTP服务器是<strong>无状态</strong>的，但是一个Web网站希望去识别一个用户，就出现了cookie，可以对用户进行跟踪。</p>
<blockquote>
<p>cookie被认为是一种对用户隐私的侵害！</p>
</blockquote>
<p>cookie有以下四个组件：</p>
<ol>
<li>在HTTP请求报文中有一个cookie首部行。</li>
<li>在HTTP的响应报文中有一个cookie首部行。</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理。</li>
<li>位于Web服务器的一个后端数据库。</li>
</ol>


<p>注意客户端系统中<strong>保留一个cookie文件</strong>，由<strong>客户端系统的浏览器进行管理</strong>，发现客户主机的cookie文件中一开始有<code>ebay</code>表项，说明该客户主机之前已经访问过<code>ebay</code>网站。</p>
<p>当第一次访问<code>amazon.com</code>网站时，服务器为它创建一个ID，并携带在HTTP响应报文中，客户端浏览器收到HTTP响应报文后，该浏览器会在它管理的cookie文件中添加一个新表项，用以记录该ID的访问记录。</p>
<p>过了一段时间之后，再次使用该浏览器访问<code>amazon.com</code>网站时，浏览器首先在cookie文件下找到了记录访问<code>amazon.com</code>的数据表项，将ID携带在HTTP的请求报文中发送给服务器，服务器后端数据库查找到这个ID的记录，假如这个ID之前收藏了什么想要购买的物品（购物车），那么后端服务器都有记录，当用户想要查询之前的收藏记录时，服务端自然能把该id对应的收藏的物品信息发送过去。</p>
<h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><p><strong>目的：不访问原始服务器，就满足客户的请求。</strong></p>
<p>Web缓存器也被称为<strong>代理服务器</strong>。</p>
<p>Web缓存器有自己的存储空间，可以<strong>记录最近请求过的对象的副本</strong>。</p>
<p>Web缓存访问流程如下：</p>
<ol>
<li>浏览器(HTTP客户端)向Web缓存器建立一个TCP连接，并向Web缓存器的对象发送一个HTTP请求。</li>
<li>Web缓存器检查自己的磁盘存储空间，<strong>看看本地是否有存储该对象</strong>。如果有的话直接HTTP响应报文返回。</li>
<li>如果没有该对象，<strong>则Web缓存器向存储该对象的服务器建立TCP连接并发送该对象的HTTP请求</strong>。收到该请求后，存储该对象的服务器向Web缓存器发送该对象(HTTP响应报文)。</li>
<li>Web缓存器接收到该对象之后，首先在<strong>自己本地先存储一份副本</strong>，然后再透过HTTP响应报文发送该对象给浏览器(透过先前建立的TCP连接)。</li>
</ol>
<blockquote>
<p>值得一提的是，Web缓存器既是服务器端也是客户端。</p>
</blockquote>
<h5 id="Web缓存的优点"><a href="#Web缓存的优点" class="headerlink" title="Web缓存的优点"></a>Web缓存的优点</h5><ul>
<li><p>Web缓存器大大减少了客户的响应时间，特别是从浏览器到初始服务器的瓶颈带宽远远小于浏览器到Web缓存器的瓶颈带宽时。</p>
<blockquote>
<p>瓶颈带宽就是数据流经过的最慢的环节所能提供的最大带宽。可以想象为一条宽大的高速公路，如果其中某个狭窄的路段（即瓶颈）限速，那么即使其他路段很宽阔，整体的车流速度也无法超过这个限速。</p>
</blockquote>
</li>
<li><p>Web缓存器大大减少了局域网(机构)的接入链路的通信量，使得接入链路的带宽可以大大减少。</p>
</li>
</ul>
<h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>高速缓存减少响应时间的同时也引入了一个问题：存放在缓存器中的副本可能是陈旧的，即原对象可能已经被更新修改了。</p>
<p>而HTTP协议有一种机制，允许缓存器证实它的对象是最新的，这种机制就是<strong>条件GET方法</strong>。</p>
<p><strong>目的：确认Web缓存器中的对象是否有被更改。</strong></p>
<p>格式：如果请求报文是 GET 方法，并且包含 <strong>If-Modified-Since: 首部行</strong>，那么就是一个条件 Get 请求报文。</p>
<p><strong>If-Modified-Since</strong>记录了存储<strong>在Web缓存器中该对象最后的修改时间</strong>，在Web缓存器向初始服务器获取该对象的请求报文中的Last-Modified首部行中得到。</p>
<p>流程如下：</p>
<ol>
<li><p>客户 A 发送 HTTP 请求报文给 Web 缓存器。</p>
</li>
<li><p>Web 缓存器有该对象，然后向初始服务器发送<strong>条件 Get</strong> (包含If-Modified-Since: 首部行)。</p>
</li>
<li><p>初始服务器上的对象若没有改动，于是返回 HTTP 响应报文，状态码为 304（返回的 HTTP 响应报文并没有该对象实体）。</p>
<blockquote>
<p>因为如果包含该对象就会浪费带宽。</p>
</blockquote>
</li>
<li><p>Web 缓存器使用本地存储的对象返回给客户端。</p>
</li>
</ol>
<h3 id="因特网中的电子邮件系统"><a href="#因特网中的电子邮件系统" class="headerlink" title="因特网中的电子邮件系统"></a>因特网中的电子邮件系统</h3><p>由三个部分组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>、**简单邮件传输协议(SMTP)**。</p>
<img src="/2025/01/24/复习笔记/image-20241208152556510.png" srcset="/img/loading.gif" lazyload alt="image-20241208152556510" style="zoom:67%;">

<ul>
<li><p>用户代理：这是用户用来发送、接收和管理电子邮件的软件或应用程序。</p>
</li>
<li><p>邮件服务器： 每个邮件服务器上会对应每个接收方有个邮箱。邮箱管理和维护着接收方的报文。</p>
<p>具体流程：</p>
<ol>
<li><strong>发送方代理</strong>将邮件发送到<strong>发送方的服务器邮箱</strong>。</li>
<li><strong>发送方的服务器</strong>将邮件发送到<strong>接收方的服务器邮箱</strong>。</li>
<li><strong>接收方的服务器</strong>再将邮件发送给<strong>接收方代理</strong>。</li>
</ol>
</li>
<li><p>简单邮件传输协议(SMTP)：是因特网电子邮件的主要应用层协议。</p>
</li>
</ul>
<h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>邮件服务器之间借助 <strong>SMTP</strong> 发送 Email 报文，它定义了邮件服务器之间交换电子邮件的规则和格式。</p>
<ul>
<li>SMTP 使用 <strong>TCP</strong> 在客户端和服务器之间传送报文，端口号为25。</li>
<li>SMTP 要求各个服务器之间不存在中间服务器。也就是发送方服务器和接收方服务器之间不存在其他中介服务器。</li>
<li>要求报文必须转化成 <strong>ASCII 码</strong>再进行传输。</li>
<li>SMTP 要求报文（首部和主体）必须都是<strong>7位的ASCII编码</strong>。</li>
</ul>
<p>邮件发送的流程：</p>
<ol>
<li>邮件从发送方 A 的用户代理开始，传输到发送方 A 的邮件服务器，邮件放在报文队列中（不会立即发送，而是<strong>定时统一</strong>进行发送）</li>
<li>SMTP 的客户端打开到接收方B邮件服务器的 TCP 连接，通过 TCP 连接发送邮件（可以发现这里 TCP 的连接是由发送方的机器发起的）</li>
<li>接收方 B 的邮件服务器将邮件放到 B 的邮箱中，B 调用他的用户代理来阅读邮件。</li>
</ol>
<h4 id="SMTP与HTTP的区别"><a href="#SMTP与HTTP的区别" class="headerlink" title="SMTP与HTTP的区别"></a>SMTP与HTTP的区别</h4><p>二者都采用请求 命令 - 响应 模型。</p>
<ul>
<li><p><strong>SMTP是推协议</strong>：邮件从发送方主动“推”到接收方的服务器。<strong>HTTP是拉协议</strong>：客户端（如浏览器）向服务器发出请求，服务器返回相应的数据。</p>
<blockquote>
<p>在网络通信中，“拉协议”指的是客户端主动向服务器请求数据，服务器根据请求返回相应的数据。这与“推协议”（如 SMTP）相对，推协议是服务器主动将数据发送给客户端。</p>
</blockquote>
</li>
<li><p>SMTP <strong>要求 ASCII 码格式</strong>。HTTP 不需要。</p>
</li>
<li><p>SMTP 是<strong>面向电子邮件传输</strong>的文本协议（以文本为主），而 HTTP 是<strong>面向超文本传输</strong>的应用层协议（以传输网页内容、图片为主）。</p>
</li>
</ul>
<h4 id="SMTP报文格式"><a href="#SMTP报文格式" class="headerlink" title="SMTP报文格式"></a>SMTP报文格式</h4><ul>
<li><p>每一个典型的邮件报文都包含<strong>首部行</strong>和<strong>报文体</strong>。</p>
</li>
<li><p>每个报文的首部行都会包含 <strong>From: 首部行</strong>和 <strong>To: 首部行</strong>。</p>
</li>
<li><p>首部行与报文体中间有一个间隔。</p>
</li>
<li><p>格式类似如下：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">From:</span> ilovesysu<span class="hljs-subst">@123</span>.com<br><span class="hljs-symbol">TO:</span> sysuloveme<span class="hljs-subst">@123</span>.com<br><br>ASCII data...<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>邮件访问协议是<strong>拉协议</strong>，因为接收用户代理主动向接收方邮件服务器请求并获取邮件内容。</p>
<p>常见的邮件访问协议有：<strong>IMAP</strong>…</p>


<h3 id="DNS（本章重点）"><a href="#DNS（本章重点）" class="headerlink" title="DNS（本章重点）"></a>DNS（本章重点）</h3><p>识别一部主机的方式：<strong>主机名</strong>、<strong>IP地址</strong>。</p>
<blockquote>
<p>人们喜欢便于记忆的主机名，但路由器喜欢格式统一的IP地址。</p>
</blockquote>
<p>目的：实现主机名与 IP 地址之间的转换，可以去识别主机。</p>
<ul>
<li><p>DNS是一个<strong>分层的 DNS 服务器</strong>实现的<strong>分布式数据库</strong>。</p>
</li>
<li><p>是<strong>应用层协议</strong>。</p>
<blockquote>
<p>但是与一般的应用层协议不同，DNS是与客户的应用程序打交道而不是与客户打交道。</p>
</blockquote>
</li>
<li><p>使用 UDP 协议作为运输层协议。</p>
</li>
</ul>
<h4 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h4><ol>
<li><p><strong>域名解析</strong></p>
<p>DNS 的核心服务是将域名与对应的 IP 地址互相解析。</p>
<ul>
<li><strong>正向解析</strong>：将域名解析为 IP 地址（如 <code>www.example.com</code> → <code>93.184.216.34</code>），便于用户访问网站或其他网络服务。</li>
<li><strong>反向解析</strong>：将 IP 地址解析为域名（如 <code>93.184.216.34</code> → <code>www.example.com</code>），通常用于网络故障排查或安全认证。</li>
</ul>
</li>
<li><p><strong>负载均衡</strong></p>
<p>DNS 可以根据用户的地理位置或其他策略，将请求分配给不同的服务器，实现<strong>流量分发和负载均衡</strong>。例如，访问同一域名时，可能解析到不同的数据中心的 IP 地址，从而优化访问速度。</p>
</li>
</ol>
<h4 id="DNS的层次结构"><a href="#DNS的层次结构" class="headerlink" title="DNS的层次结构"></a>DNS的层次结构</h4><p>大致说来，一共有三种不同类型的DNS服务器：<strong>根DNS服务器</strong>、<strong>顶级域DNS服务器(TLD)<strong>、</strong>权威DNS服务器</strong>。</p>


<ul>
<li><strong>根DNS服务器</strong><ul>
<li>根域名服务器存储了<strong>所有顶级域（TLD）服务器的地址信息</strong>（每一个根域名服务器并不存储全部顶级域服务器的地址信息，而是只存储一部分TLD服务器的地址信息）</li>
<li><strong>主要功能</strong>是告诉查询者<strong>下一步应该访问哪个顶级域 DNS 服务器</strong>（如 <code>.com</code>、<code>.org</code>、<code>.cn</code> 等）。</li>
</ul>
</li>
<li><strong>顶级域DNS服务器(TLD)</strong><ul>
<li>负责<strong>顶级域名</strong>（如com，org，net等）和<strong>所有国家级的顶级域名</strong>（如cn，uk，jp等）。</li>
</ul>
</li>
<li><strong>权威DNS服务器</strong><ul>
<li>权威 DNS 服务器<strong>负责存储特定域名的实际记录</strong>，包括正向解析（域名到 IP）和反向解析（IP 到域名）的映射。</li>
</ul>
</li>
</ul>
<blockquote>
<p>你可以把这三类服务器比作一个分布式的导航系统：</p>
<ol>
<li><strong>根服务器</strong>：像是地图的目录，告诉你去哪个分区（比如 <code>.com</code>）。</li>
<li><strong>TLD 服务器</strong>：像是分区内的管理员，指向目标（比如 <code>example.com</code> 的权威服务器）。</li>
<li><strong>权威服务器</strong>：像是目的地的接待员，直接告诉你最终答案（域名对应的 IP 地址）。</li>
</ol>
</blockquote>
<p>以上三种 DNS 服务器都属于 DNS 服务器的层次结构中，但是还有一种重要的 DNS 服务器，它不属于 DNS 层次结构，但是它非常重要，就是<strong>本地服务器</strong>。</p>
<ul>
<li><strong>本地DNS服务器</strong><ul>
<li>每一个 ISP 都有一台本地 DNS 服务器。</li>
<li>当一个主机发起 DNS 查询时，查询被送到其本地 DNS 服务器，起着代理的作用，将查询转发到层次结构中。</li>
<li><strong>优点：</strong>可以实现缓存！</li>
</ul>
</li>
</ul>
<p>DNS 查询分为<strong>迭代查询</strong>和<strong>递归查询</strong>。</p>
<p><strong>迭代查询：</strong>在迭代查询中，客户端向本地 DNS 服务器发送查询请求，本地 DNS 服务器若无法解析该请求，会返回一个指向下一个 DNS 服务器的参考。客户端自己继续向返回的 DNS 服务器发送查询，直到找到最终答案。</p>
<p><strong>递归查询：</strong>在递归查询中，客户端将查询请求发送给本地 DNS 服务器。如果本地 DNS 服务器无法直接返回结果，它会继续向其他 DNS 服务器发起查询，直到找到最终的答案。</p>
<p><strong>区别：</strong>递归查询下，<strong>根 DNS 服务器的压力较大</strong>。主机向本地 DNS 服务器查询常使用递归查询，为了减少根 DNS 服务器的压力，域名服务器之间的查询常使用下面这种方式：</p>
<ul>
<li><p>从主机到本地 DNS 是递归查询，其余查询都是迭代查询。</p>
</li>
<li><p>所有查询都是递归查询：                                  </p>
</li>
</ul>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><ul>
<li>如果在 DNS 服务器中缓存了一个 主机名&#x2F;IP地址对，另一个对相同主机名的查询到达该 DNS 服务器时，该 DNS 服务器就能立刻返回对应的 IP 地址，<strong>即使它并不是该主机名的权为服务器</strong>。</li>
<li>经过了 TTL 时间后，DNS 服务器就会删除缓存中的资源。<ul>
<li><strong>优势</strong><ul>
<li><strong>速度提升</strong>：减少了域名解析所需的时间和网络延迟。</li>
<li><strong>减少负载</strong>：降低了 DNS 服务器的压力，尤其在高访问量的网络中。</li>
</ul>
</li>
<li><strong>问题</strong><ul>
<li><strong>缓存过期</strong>：当缓存记录的 TTL 到期时，必须重新查询，可能导致短暂延迟。</li>
<li><strong>更新延迟</strong>：当域名的 IP 地址发生变化时，旧的缓存记录可能导致访问失败或错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h4><p>实现 DNS 分布式数据库的所有 DNS 服务器存储了<strong>资源记录（Resource Record，RR）</strong>，RR 提供了主机名到IP地址的映射。</p>
<p>RR 是一个四元组：**(Name, Value, Type, TTL)**</p>
<ul>
<li><p>TTL 是该记录的生存时间，决定了该资源记录应当从缓存中删除的时间。</p>
</li>
<li><p>Name 和 Value 的意义取决于 Type。</p>
<table>
<thead>
<tr>
<th align="center">TYPE</th>
<th align="center">NAME</th>
<th align="center">VALUE</th>
<th align="center">EXAMPLE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">主机规范名</td>
<td align="center">对应的IPV4地址</td>
<td align="center">example.com → 192.0.2.1</td>
</tr>
<tr>
<td align="center">NS</td>
<td align="center">域名</td>
<td align="center">请求链中的下一个域名</td>
<td align="center">example.com → dns.example.com</td>
</tr>
<tr>
<td align="center">CNAME</td>
<td align="center">主机别名</td>
<td align="center">主机规范名</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> → example.com</td>
</tr>
<tr>
<td align="center">MX</td>
<td align="center">邮件服务器别名</td>
<td align="center">邮件服务器规范名</td>
<td align="center">example.com → mail.example.com</td>
</tr>
</tbody></table>
<blockquote>
<p>一个主机只会有一个主机规范名，但可以有很多个主机别名。</p>
<p>不记得了看看这篇博客：[计算机网络之域名、主机名、IP地址和URL-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45437521/article/details/109037537#:~:text=%E4%B8%BB%E6%9C%BA%E5%88%AB%E5%90%8D%EF%BC%88%E5%BD%93%E5%AD%98%E5%9C%A8%E6%97%B6%EF%BC%89%E6%AF%94%E4%B8%BB%E6%9C%BA%E8%A7%84%E8%8C%83%E5%90%8D%E6%9B%B4%E5%8A%A0%E5%AE%B9%E6%98%93%E8%AE%B0%E5%BF%86%E3%80%82">https://blog.csdn.net/weixin_45437521/article/details/109037537#:~:text=主机别名（当存在时）比主机规范名更加容易记忆。</a> 应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址。 主机别名不是一定要有的，也有很多主机只有一个主机名。,规范主机名具有唯一性。 规范主机名对应多个别名，多个IP地址。 一个别名也可以对应多个IP地址。 计算机名称是在我的电脑–&gt;属性–&gt;计算机名称，它是表明这台计算机的名称叫什么。)</p>
</blockquote>
<ul>
<li><p><strong>CNAME 记录本身不直接关联 IP 地址</strong>，它只会提供一个域名到另一个域名的映射。然后，后续的 DNS 查询会继续解析这个规范主机名（<code>VALUE</code>）到其对应的 IP 地址。</p>
<blockquote>
<p>从实现的功能来看，A记录和CNAME记录并无太大差别。但是CNAME记录在做IP地址变更时要比A记录方便。</p>
<p>CNAME记录允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即：CNAME)到A记录的域名上。</p>
</blockquote>
</li>
<li><p>当一个 DNS 服务器是某个特定主机名的<strong>权威 DNS 服务器</strong>时，它负责存储和管理该主机名的所有 DNS 记录。这时，权威服务器通常会包含该主机名的 <strong>A 记录</strong>（将域名映射到其对应的 IP 地址）。</p>
<blockquote>
<p>即使不是权威 DNS 服务器，也有可能缓存一条 A 记录。</p>
</blockquote>
</li>
<li><p>当一个 DNS 服务器不是某个特定主机名的<strong>权威 DNS 服务器</strong>时，它并没有该域名的直接记录（如 A 记录）。这时，非权威 DNS 服务器会通过 <strong>NS 记录</strong> 指向该主机名的权威 DNS 服务器，并通过 <strong>A 记录</strong> 提供该权威 DNS 服务器的 IP 地址。<br>这意味着非权威 DNS 服务器并没有该域名的最终 IP 地址，而是通过查询权威 DNS 服务器来获取正确的记录。</p>
</li>
</ul>
</li>
</ul>
<h4 id="DNS报文格式"><a href="#DNS报文格式" class="headerlink" title="DNS报文格式"></a>DNS报文格式</h4><p>DNS 请求和应答都是用相同的报文格式，分成5个段（有的报文段在不同的情况下可能为空），如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+---------------------+<br>  |<span class="hljs-string">        Header       </span>|<span class="hljs-string"> 报文头</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">       Question      </span>|<span class="hljs-string"> 要查询的问题</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">        Answer       </span>|<span class="hljs-string"> 服务器的应答</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">      Authority      </span>|<span class="hljs-string"> 权威的应答</span><br><span class="hljs-string">  +---------------------+</span><br><span class="hljs-string">  </span>|<span class="hljs-string">      Additional     </span>|<span class="hljs-string"> 附加信息</span><br><span class="hljs-string">  +---------------------+</span><br></code></pre></td></tr></table></figure>



<h4 id="DNS域名解析流程"><a href="#DNS域名解析流程" class="headerlink" title="DNS域名解析流程"></a>DNS域名解析流程</h4><ol>
<li><p><strong>客户端查询</strong></p>
<ul>
<li>当用户在浏览器中输入一个域名（如 <code>www.example.com</code>）时，首先会检查操作系统的本地 DNS 缓存，看是否已经有该域名对应的 IP 地址。</li>
</ul>
</li>
<li><p><strong>查询本地 DNS 服务器</strong></p>
<ul>
<li>如果操作系统没有缓存结果，客户端会将 DNS 查询请求发送给 <strong>本地 DNS 服务器</strong>（通常是 ISP 提供的 DNS 服务器）。这就是 DNS 查询的起点。</li>
<li>本地 DNS 服务器会首先检查自己是否有该域名的解析记录，如果有，则直接返回该 IP 地址给客户端。</li>
</ul>
</li>
<li><p><strong>本地 DNS 服务器查找（递归或迭代查询）</strong></p>
<ul>
<li>如果本地 DNS 服务器没有该域名的解析记录，它会以<strong>递归查询</strong>或<strong>迭代查询</strong>的方式向更高级别的 DNS 服务器请求解析。</li>
</ul>
</li>
<li><p><strong>根 DNS 服务器查询</strong></p>
<ul>
<li>如果本地 DNS 服务器需要从根 DNS 服务器开始查询，它会向根 DNS 服务器发起请求。根 DNS 服务器返回一个 <strong>顶级域（TLD）DNS 服务器</strong> 的地址，如 <code>.com</code> 的 TLD 服务器。</li>
</ul>
</li>
<li><p><strong>TLD DNS 服务器查询</strong></p>
<ul>
<li>本地 DNS 服务器根据根 DNS 服务器提供的指引，查询到对应的 <strong>TLD DNS 服务器</strong>（例如：<code>com</code> 域名的 TLD DNS 服务器）。TLD DNS 服务器返回指向 <strong>权威 DNS 服务器</strong> 的地址。</li>
</ul>
</li>
<li><p><strong>权威 DNS 服务器查询</strong></p>
<ul>
<li>本地 DNS 服务器向 <strong>权威 DNS 服务器</strong> 发起查询，权威 DNS 服务器知道该域名的最终解析结果（即对应的 IP 地址）。</li>
<li>权威 DNS 服务器返回该域名的 <strong>A 记录</strong>（如果是 IPv4）或者 <strong>AAAA 记录</strong>（如果是 IPv6）给本地 DNS 服务器。</li>
</ul>
</li>
<li><p><strong>返回结果</strong></p>
<ul>
<li>本地 DNS 服务器将查询到的 IP 地址返回给客户端。客户端就可以使用这个 IP 地址与目标服务器建立连接（例如加载网页）。</li>
</ul>
</li>
</ol>
<h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>目前我们讨论的都是<strong>客户 - 服务器(CS) 模型</strong>：</p>
<ul>
<li><p><strong>结构：</strong>在 CS 模型中，网络中有明确的角色分配。<strong>客户端</strong>发起请求，而<strong>服务器</strong>提供资源或服务。服务器通常是强大的计算机或设备，负责管理和处理客户端的请求。</p>
</li>
<li><p><strong>通信：</strong>客户端向服务器发送请求，服务器响应并处理这些请求。客户端和服务器之间通常有一对多的关系。</p>
<blockquote>
<p>客户之间是不会进行通信的。</p>
</blockquote>
</li>
<li><p>极大地依赖总是打开的基础设施服务器。</p>
</li>
</ul>
<p>而在P2P模型中</p>
<ul>
<li><strong>结构：</strong>节点没有明确的角色区分，所有节点既可以是资源的提供者，也可以是资源的请求者。</li>
<li><strong>通信：</strong>节点之间直接相互通信，数据和资源可以在节点之间共享，不依赖于中心服务器。</li>
</ul>
<h4 id="C-S与P2P模型分发时间比较"><a href="#C-S与P2P模型分发时间比较" class="headerlink" title="C&#x2F;S与P2P模型分发时间比较"></a>C&#x2F;S与P2P模型分发时间比较</h4><ul>
<li>$$u_s$$表示服务器接入链路的上载速率。</li>
<li>$$u_i$$表示第$$ i$$ 个对等方接入链路的上载速率。</li>
<li>$$N$$表示想要获得该文件副本的对等方数量。</li>
<li>$$F$$表示被分发的文件长度(bit)。</li>
<li><strong>分发时间：</strong>所有 N 个对等方得到该文件的副本所需要的时间。</li>
</ul>


<h4 id="C-S分发时间"><a href="#C-S分发时间" class="headerlink" title="C&#x2F;S分发时间"></a>C&#x2F;S分发时间</h4><ul>
<li><p>服务器需要向 $$N$$ 个对等方传输该文件的副本，一共是$$NF$$ bit。服务器上载速率为$$u_s$$。**因此服务器分发该文件的时间必定至少为$$\frac{NF}{u_s}$$**。</p>
</li>
<li><p>令$$d_{min} &#x3D; min{d_1,d_2,…,d_N}$$，具有$$d_{min}$$下载速率的对等方至少需要$$\frac{F}{d_{min}}$$下载该副本，**因此分发该文件的时间至少为$$\frac{F}{d_{min}}$$**。</p>
</li>
<li><p>综合以上两点可以得出：<br>$$<br>D_{cs} \geq max{\frac{NF}{u_S},\frac{F}{d_}}<br>$$<br>可以发现，当$$N$$很大的时候，分发时间被第一项所支配了。并且还是<strong>线性增长</strong>的。</p>
</li>
</ul>
<h4 id="P2P分发时间"><a href="#P2P分发时间" class="headerlink" title="P2P分发时间"></a>P2P分发时间</h4><ul>
<li><p>在分发开始的时候，只有服务器有文件，**分发该文件至少需要$$\frac{F}{u_s}$$**。</p>
</li>
<li><p>令$$d_{min} &#x3D; min{d_1,d_2,…,d_N}$$，具有$$d_{min}$$下载速率的对等方至少需要$$\frac{F}{d_{min}}$$下载该副本，**因此分发该文件的时间至少为$$\frac{F}{d_{min}}$$**。</p>
</li>
<li><p>考虑整个系统的上载，一共需要上传 $$NF$$ bit的文件，整个系统的上载速率为$$u_{total}&#x3D;u_s+u_1+u_2+…+u_N$$，因此最小的分发时间至少为$$\frac{NF}{U_{total}}$$。</p>
</li>
<li><p>综合以上三点可以得出：<br>$$<br>D_{P2P} \geq max{\frac{F}{u_S},\frac{F}{d_},\frac{NF}{U_{total}}}<br>$$<br>可以发现，当$$N$$很大的时候，第三项的$$u_{total}$$也会相应增大。</p>
</li>
</ul>
<h4 id="分发时间随N变化图"><a href="#分发时间随N变化图" class="headerlink" title="分发时间随N变化图"></a>分发时间随N变化图</h4>

<p>发现 C&#x2F;S 模型是线性增长的，但是 P2P 模型不是。</p>
<h3 id="BitTorrent（这个真的不太重要，感觉不太重要）"><a href="#BitTorrent（这个真的不太重要，感觉不太重要）" class="headerlink" title="BitTorrent（这个真的不太重要，感觉不太重要）"></a>BitTorrent（这个真的不太重要，感觉不太重要）</h3><p>一种用于文件分发的P2P协议。</p>
<p>一些术语定义如下：</p>
<ul>
<li><strong>洪流：</strong>参与一个特定的文件分发的所有对等方集合。在一个洪流中的对等方彼此下载等长度的文件块。</li>
<li><strong>文件块：</strong>将一个文件拆分成很多个块，典型的一个块为256KB。</li>
<li><strong>追踪器：</strong>每个洪流都有一个追踪器。</li>
</ul>


<p>当有一个新节点 Alice 加入洪流，会有以下流程：</p>
<ol>
<li>向追踪点注册自己，并且周期性的通知追踪器自己仍在洪流中。</li>
<li>追踪点会随机选择洪流中对等方的节点子集告诉新节点 Alice，Alice会与这些节点并行建立 TCP 连接。</li>
<li>Alice 从这些邻居中获取它们拥有哪些块，并思考做出以下两个决定：<ul>
<li>应该从哪个邻居当中获取哪些块</li>
<li>应该向哪个向她发出请求块的邻居发送块</li>
</ul>
</li>
<li>应该从哪个邻居当中获取哪些块：<ul>
<li><strong>最稀缺算法</strong>：选择在所有的邻居中副本数量最少的块来获取。</li>
</ul>
</li>
<li>应该向哪个向她发出请求块的邻居发送块<ul>
<li>Alice 根据当前能够以<strong>最高速率</strong>向她提供数据的邻居中选择。</li>
</ul>
</li>
</ol>
<h3 id="内容分发网-cdn（看看概念就行）"><a href="#内容分发网-cdn（看看概念就行）" class="headerlink" title="内容分发网 cdn（看看概念就行）"></a>内容分发网 cdn（看看概念就行）</h3><p>简单来说，就是想让客户访问距离客户最近的服务器，增快访问速度。</p>
<p>流程如下：</p>
<ol>
<li>用户向 Local DNS 服务器发起请求</li>
<li>DNS 服务器将请求重定向到 CDN 服务器。</li>
<li>CDN 服务器提供最优 CDN 服务器的 IP 地址。</li>
<li>用户向该 CDN 服务器请求内容。</li>
<li>该 CDN 服务器提供内容。</li>
</ol>
 

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>HTTPS 是 HTTP（应用层协议）+ TLS&#x2F;SSL 的结合，而 HTTP 数据通过 TLS 加密后，再传输到 TCP（传输层协议）进行数据传输。</li>
</ul>
<h3 id="题目（随便选几题）"><a href="#题目（随便选几题）" class="headerlink" title="题目（随便选几题）"></a>题目（随便选几题）</h3><ul>
<li><p><strong>R3：</strong>对于两个进程的通信而言，哪个进程是用户，哪个进程是服务器？</p>
<p>答：一般而言，主动发起通信的进程是用户，等待接受通信的是服务器。</p>
</li>
<li><p><strong>R6：</strong>假定你想尽快处理从远程客户到服务器的事务，你会选择TCP还是UDP？</p>
<p>答：选择 UDP，因为 UDP 进行通信成本更低，不需要向 TCP 一样进行三次握手等等。</p>
</li>
<li><p><strong>R10：</strong>什么是握手协议？</p>
<p>答：实际上是一个<strong>同步机制</strong>，类似交换信息，双方都告诉对方自己的信息，以及一些预备动作。</p>
</li>
<li><p><strong>R19：</strong>一个机构的 Web 服务器和邮件服务器可以有完全相同的主机名别名（例如：foo.com） 吗？包含邮件服务器主机名的 RR 有什么样的类型？</p>
<p>答：可以有相同的主机名别名，包含邮件服务器主机名的 RR 可以有 <strong>MX</strong>、<strong>A</strong>类型。</p>
<ul>
<li><strong>MX 类型</strong>完成邮件服务器主机名到邮件服务器规范主机名的映射。</li>
<li><strong>A 类型</strong>完成邮件服务器规范主机名到邮件服务器 IP 地址的映射。</li>
</ul>
</li>
<li><p><strong>R22：</strong>考虑一个新对等方 Alice 加入 BitTorrent 而不拥有任何文件块。没有任何块，因此她没有任何东西可上载，她无法成为任何其他对等方的前 4 位上载者。那么 Alice 将怎样得到她的第一个文件块呢？</p>
<p>答：太工程了，感觉不会考。</p>
</li>
<li><p><strong>R26：</strong>2.7 节中所描述的 UDP 服务器仅需要一个套接字，而 TCP 服务器需要两个套接字。为什么？如果 TCP 服务器支持 n 个并行连接，每条连接来自不同的客户主机，那么 TCP 服务器将需要多少个套接字？</p>
<p>答：UDP 没有欢迎套接字，UDP 的连接和发送都是通过一个套接字进行的。而 TCP 需要一个欢迎套接字建立三次握手过程，当连接建立时，又创建一个新套接字用于通信，所以如果 TCP 服务器需要支持 n 个并行连接，那么需要有 n + 1 个套接字。</p>
</li>
<li><p><strong>R27：</strong>对于 2.7 节所描述的运行在 TCP 之上的客户-服务器应用程序，服务器程序为什么必须先于客户程序运行？对于运行在 UDP 之上的客户-服务器应用程序，客户程序为什么可以先于服务器程序运行？</p>
<p>答：基于 TCP 的程序，客户端必须与服务器程序建立持续性的连接，服务器必须先通过 <strong><code>bind()</code></strong> 和 <strong><code>listen()</code></strong> 在一个固定的端口上等待客户端的连接请求，所以服务器程序必须先于客户程序打开。基于 UDP 的程序，因为 UDP 的客户程序本身并不期待报文能无差错可靠的到达。</p>
</li>
</ul>
<h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><p>经典的运输层协议有：<strong>TCP</strong>、<strong>UDP</strong>。</p>
<p><strong>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信。</strong></p>
<p>运输层协议是在<strong>端系统中实现的</strong>，而不是在路由器中实现。</p>
<p>实现方法如下：</p>
<ul>
<li>将应用报文拆分成很多小块，并且每个小块加上运输层头部形成运输层报文段。</li>
<li>在发送端系统中，运输层将运输层报文段交给网络层，网络层进行封装成网络层分组，并向目的地发送。</li>
<li>接收端系统中，网络层提取出分组的运输层报文段并交给接收端运输层进行处理。</li>
</ul>
<h3 id="运输层与网络层区别"><a href="#运输层与网络层区别" class="headerlink" title="运输层与网络层区别"></a>运输层与网络层区别</h3><p>运输层位于网络层之上。</p>
<p>运输层提供了应用进程之间的逻辑通信。</p>
<p>网络层提供了主机之间的逻辑通信。</p>
<p><strong>运输层实际上是透过网络层实现的。</strong></p>
<blockquote>
<p>设想一下有两所房子，每所房子里都住着12个小孩。两所房子里的孩子喜欢互相通信，每一封信都由老式的邮局分别用信封来寄。在每一家里面都由一个孩子——西海岸的房子里的Ann和东海岸房子里的BilI——负责邮件的收集和分发。每周Ann都从她的兄弟姐妹那里收集起来信件，并将这些信件送到每天都来的邮递服务员那里。当信件到达西海岸的房子，Ann又将这些信件分发给她的兄弟姐妹。BilI在东海岸有着同样的工作。</p>
<p>在这个例子中，邮递服务提供着两所房子之间的逻辑通信——邮递服务在两所房子之间传递邮件，而不是针对每个人的服务。</p>
<p>另一方面，Ann和BilI提供堂兄妹之间的逻辑通信——Ann和BilI从他们的兄弟姐妹那里收集邮件并将邮件递送给他们。</p>
<p>注意，从这些堂兄妹的角度看，Ann和BilI是邮件的服务人，尽管他们俩只是端到端寄送服务的一部分(终端系统部分)。</p>
<ul>
<li>主机(也称为终端系统)&#x3D;房子</li>
<li>进程&#x3D;堂兄妹</li>
<li>应用程序消息&#x3D;信封里的信</li>
<li>网络层协议&#x3D;邮递服务(包括邮递员)</li>
<li>传输层协议&#x3D;Ann和Bill</li>
</ul>
</blockquote>
<h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li>提供可靠的、面向连接的服务。</li>
<li>提供拥塞控制。</li>
<li>提供流量控制。</li>
<li>多路复用、解复用。</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul>
<li>提供不可靠、无连接的服务。</li>
<li>基本上只有最基本的运输层功能。</li>
<li>没有为<strong>尽力而为</strong>的 IP 服务添加更多功能。</li>
<li>多路复用、解复用。</li>
</ul>
<h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>我们已经知道，网络层向传输层提供的提供的服务是<strong>主机-主机</strong>的，而传输层提供的服务是<strong>进程-进程</strong>的，如何在传输层实现这一细分的服务的实现，所依靠的就是<strong>端口号</strong>。</p>
<ul>
<li>端口号实际上是将收到的报文定位到相应的套接字，再由相应的套接字发送给对应的进程。</li>
</ul>
<p>通常一部主机上都会运行多个网络应用程序进程，即<strong>一部主机会同时运行多个套接字</strong>。</p>
<p>考虑接收主机如何将一个到达的运输层报文段定向到合适的套接字。</p>
<p><strong>多路分解(接收方)：</strong> 根据报文段的头部信息中的<strong>IP地址</strong>和<strong>端口号</strong>将接收到的报文段发给正确的套接字(和对应的应用进程)。</p>
<p><strong>多路复用(发送方)：</strong>从多个套接字接收来自多个进程的报文，根据套接字对应的<strong>IP地址</strong>和<strong>端口号</strong>等信息对报文段用头部加以封装。</p>
<blockquote>
<p>考虑到上述的例子：当 Bill 从邮递员收到一批信件，并且通过查看收件人来分发信件，就是多路分解；当 Ann从兄弟姐妹收集要发送的信件给邮递员，就是一个多路复用。</p>
</blockquote>
 

<h4 id="UDP的多路复用与多路分解"><a href="#UDP的多路复用与多路分解" class="headerlink" title="UDP的多路复用与多路分解"></a>UDP的多路复用与多路分解</h4><p>一个 UDP 套接字由一个二元组全面标识，包含一个<strong>目的 IP</strong> 和<strong>目的端口号</strong>。</p>
<blockquote>
<p>若两个 UDP 报文段具有不同的源地址IP和源端口号，但是具有相同的目的IP和目的端口号，则两个报文段会经过相同的目的套接字被定向到相同的进程。</p>
</blockquote>
<p>当一个 UDP 报文段到达接收主机，接收主机运输层检查该报文段中的目的端口号，并将该报文段交付给目的端口号所标识的套接字。</p>


<h4 id="TCP的多路复用与多路分解"><a href="#TCP的多路复用与多路分解" class="headerlink" title="TCP的多路复用与多路分解"></a>TCP的多路复用与多路分解</h4><p>一个 TCP 套接字由一个四元组全面标识，包含一个<strong>目的 IP</strong> 和<strong>目的端口号</strong>和一个<strong>源 IP</strong> 和<strong>源端口号</strong>。</p>
<blockquote>
<p>两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字。</p>
<p>UDP 是传输到同一套接字，TCP 为每个客户创建一个 socket。</p>
</blockquote>
<p>当一个 TCP 报文段到达接收主机，接收主机利用上述四个值来定向(分解)一个套接字，并将该报文段交付给该套接字。</p>
<p>查看下图，就算主机 A 和主机 C 都分配源端口 26145，但是服务器 B 仍然能够正确分解这两个具有相同端口号的连接，因为<strong>具有不同的 IP 位置</strong>。</p>


<h3 id="无连续运输：UDP"><a href="#无连续运输：UDP" class="headerlink" title="无连续运输：UDP"></a>无连续运输：UDP</h3><h4 id="UDP-提供的服务"><a href="#UDP-提供的服务" class="headerlink" title="UDP 提供的服务"></a>UDP 提供的服务</h4><ul>
<li>尽力而为的服务，数据包可能会丢，乱序。</li>
<li>在发送报文段之前，发送方和接收方的运输层实体之间没有握手（无连接）。</li>
</ul>
<h4 id="UDP-好处（对比-TCP）"><a href="#UDP-好处（对比-TCP）" class="headerlink" title="UDP 好处（对比 TCP）"></a>UDP 好处（对比 TCP）</h4><ul>
<li><p><strong>应用层可以更好的控制发送数据的时间</strong></p>
<p>因为 TCP 有拥塞控制机制，所以当网络情况变得极度拥塞的时候，就会抑制 TCP 发送方。</p>
</li>
<li><p><strong>无需建立连接</strong></p>
<p>因为 TCP 需要三次握手建立连接，UDP 没有连接时延。</p>
</li>
<li><p><strong>无连接状态</strong></p>
<p>TCP 需要维护连接状态，例如发送和接收方缓存。</p>
</li>
<li><p><strong>分组首部开销更小</strong></p>
<p>UDP 首部只需要 8 个字节，TCP 首部需要 20 个字节。</p>
</li>
</ul>
<h4 id="UDP报文段"><a href="#UDP报文段" class="headerlink" title="UDP报文段"></a>UDP报文段</h4><p> UDP 头部只有四个字段，每个字段占两个字节。</p>
<p>分别是 源端口号，目的端口号，长度，检验和。</p>
 

<h4 id="UDP-检验和"><a href="#UDP-检验和" class="headerlink" title="UDP 检验和"></a>UDP 检验和</h4><p>检验和计算：就是当加法溢出后，回卷，然后再执行反码运算。</p>
<p>如何检验：将所有的分组和检验和相加，结果需要为全1。</p>
 

<p>如果未通过检验则说明数据报存在差错，<strong>但通过检验也只能说明未检测到差错，不能证明接收到的数据报一定正确无误。</strong></p>
<blockquote>
<p>举个简单的例子：0000 和 1111，检验和计算为 0000；若出现差错，为0001 和 1110，则检验和计算不出来。</p>
</blockquote>
<h3 id="可靠数据传输原理（很重要这部分）"><a href="#可靠数据传输原理（很重要这部分）" class="headerlink" title="可靠数据传输原理（很重要这部分）"></a>可靠数据传输原理（很重要这部分）</h3><p>可靠数据传输协议为上层实体提供的抽象是<strong>可以通过一条可靠的信道进行传输</strong>。</p>
<p>但是实际上可靠传输协议的下层协议是<strong>不可靠的</strong>。</p>
<p>利用不可靠的协议来实现可靠的信道。</p>
 

<h4 id="rdt-1-0（在可靠信道上的可靠数据传输）"><a href="#rdt-1-0（在可靠信道上的可靠数据传输）" class="headerlink" title="rdt 1.0（在可靠信道上的可靠数据传输）"></a>rdt 1.0（在可靠信道上的可靠数据传输）</h4><p>假设信道是完全可靠的。</p>
<p>有限状态机为：</p>
 

<h4 id="rdt-2-0（经具有比特差错信道的可靠数据传输）"><a href="#rdt-2-0（经具有比特差错信道的可靠数据传输）" class="headerlink" title="rdt 2.0（经具有比特差错信道的可靠数据传输）"></a>rdt 2.0（经具有比特差错信道的可靠数据传输）</h4><p>引入了**否定确认(NAK)<strong>和</strong>肯定确认(ACK)**控制报文。</p>
 

<p>发送端有两个状态，当它在等待接收端传控制报文的时候，它不能从上层获取数据。</p>
<p>类似这种行为的协议叫做<strong>停等协议</strong>。</p>
<h4 id="rdt-2-2（无NAK）"><a href="#rdt-2-2（无NAK）" class="headerlink" title="rdt 2.2（无NAK）"></a>rdt 2.2（无NAK）</h4><blockquote>
<p>rdt 2.1和 rdt 2.2都一样，只不过 2.1 有 NAK，2.2 是全部使用 ACK 包了。</p>
</blockquote>
<p>但是有个问题，当控制报文（ACK NAK）分组受损，要怎么办？</p>
<p>因此在数据分组中<strong>增加序号</strong>，让发送方对于其数据分组编号（0 &#x2F; 1），并且当发送方收到重复的 ACK 序号则重发。</p>
<p>接收方接受到序号为什么的包，就 ACK 什么序号回去。</p>
 

<h4 id="rdt-3-0（经具有比特差错的丢包信道的可靠数据传输）"><a href="#rdt-3-0（经具有比特差错的丢包信道的可靠数据传输）" class="headerlink" title="rdt 3.0（经具有比特差错的丢包信道的可靠数据传输）"></a>rdt 3.0（经具有比特差错的丢包信道的可靠数据传输）</h4><p>现在假设底层信道除了比特会出差错，还假设会丢包。</p>
<p>引入超时重传机制，以解决丢包问题。</p>
<p>但是有可能只是网络塞车，并不是丢包，这个时候导致冗余数据分组；但是因为我们有序列号，所以可以解决这个问题。</p>
<p>也称为<strong>比特交替协议</strong>。</p>
<p>下面展示rdt 3.0在无丢包操作、分组丢失、ACK丢失、过早超时四种情况下的运行流程：</p>
 

 

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>rdt 1.0：完全正常</li>
<li>rdt 2.0：可能会出比特差错<ul>
<li>引入 ACK&#x2F;NAK 控制报文，重传机制，序号。</li>
</ul>
</li>
<li>rdt 3.0：可能会丢包<ul>
<li>引入超时重传机制。</li>
</ul>
</li>
</ul>
<p>重传是无敌的！！</p>
<h4 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h4><p>因为 rdt 3.0 是一个停等协议，即发送方发送完包之后需要等待接收方的响应控制报文。</p>
<p>这个效率是非常慢的，考虑已知链路带宽R为1Gbps，端到端传播延时T为15ms，分组大小L为1kB。</p>
<p>传输延时为：$$8us$$。</p>
<p>往返传播延时RTT为：$$30ms$$。</p>
<p>利用率为：$$\frac{8us}{30ms+8us}$$   十分的低效！！</p>
 

<p>所以考虑流水线：<strong>允许发送方发送多个分组而无需等待确认</strong>。</p>
<p>但是必须满足：</p>
<ul>
<li>增加序号范围：每个运输中的分组和多个在传输中的未确认报文。</li>
<li>发送方和接收方需要缓存分组：发送方需要缓存发送但是没有确认的分组，接收方需要缓存已正确接收但是还没有处理的分组。</li>
</ul>
 

<p>对于流水线的差错恢复，可以用<strong>回退N步</strong>和<strong>选择重传</strong>进行解决。</p>
<h4 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h4><p>设定流水线中未确认的分组数不能超过 N。</p>
<p>N 也被称为窗口长度，GBN也被称为滑动窗口协议。</p>
 

<p>简单来说，就是将 N 个未确认分组看成一个整体（窗口），如果其中一个包丢失了，则整个窗口的包重传。</p>
<p>使用<strong>累计确认</strong>，即假设发送方接收到对序号为 n 的分组的确认，则表明接收方已正确接收到序号为 n 和 n 以前的包。</p>
<p>下图为 N 为4的一个情况。</p>
 

<h4 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h4><p>刚刚的 回退N步 有个很明显的问题，就是假设只有一个包出错了，但是却需要重传全部窗口内的分组。</p>
<p><strong>选择重传的基本思想是只重传可能出错的包。</strong></p>
 

<p>接收方将确认一个正确接收的分组而不管它是不是按序的（先放到缓存）。</p>
<p>在图 3.26 中接收方初始缓存了分组3 4 5，最后接收到分组 2 之后再一并上传给上层。</p>
 

<p><strong>需要限制窗口长度小于等于序号空间的一半！！</strong></p>
 

<h3 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h3><p>TCP是<strong>面向连接</strong>的，这是因为两个应用进程发送数据之前，必须先进行<strong>握手</strong>。</p>
<p>TCP是<strong>点对点</strong>的，因为<strong>单个发送方</strong>和<strong>单个接收方</strong>。</p>
<p>TCP是<strong>全双工</strong>的，因为建立连接之后数据可以<strong>从任意一方流向另一方</strong>。</p>
<p>TCP是<strong>流水线协议</strong>，有<strong>拥塞控制</strong>和<strong>接收窗口大小</strong>。</p>
<h4 id="TCP数据传输流程"><a href="#TCP数据传输流程" class="headerlink" title="TCP数据传输流程"></a>TCP数据传输流程</h4> 

<ul>
<li>进程将数据给 TCP 套接字后，TCP 将数据引导至发送缓存。</li>
<li>TCP 会在合适的时间点从发送缓存中取出数据，加上TCP头部，并传递给网络层。<ul>
<li>因数据链路层最大传输单元为1500字节，TCP头部和IP头部各需要20个字节，所以最多可取出1460字节的数据。</li>
</ul>
</li>
<li>TCP 的另一端接收该报文段后，应用程序从接收缓存中读取数据。</li>
</ul>
<h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4><p>TCP报文段由首部字段（<strong>20字节</strong>）和一个数据字段组成：</p>
 

<p><strong>源端口号（16位）和目标端口号（16位）</strong>：</p>
<ul>
<li><strong>源端口号</strong>：表示发送数据的进程的端口号，用于标识发送方的应用。</li>
<li><strong>目标端口号</strong>：表示接收数据的进程的端口号，用于标识接收方的应用。</li>
<li>这两个字段共同完成了端到端的通信连接。</li>
</ul>
<p><strong>序号（32位）</strong>：</p>
<ul>
<li>用于标识数据字节流中的每一个字节的位置。</li>
<li>在连接建立时，初始序列号（ISN）是随机生成的，后续每发送一个字节，序号会递增。</li>
</ul>
<p><strong>确认号（32位）</strong>：</p>
<ul>
<li>用于确认接收到的数据，表示期望收到的下一个字节的序列号。</li>
<li>例如，如果接收到的最后一个字节的序列号是 100，那么确认号会是 101。</li>
<li>只有当 ACK 标志位被设置时，确认号字段才有效。</li>
</ul>
<p><strong>窗口大小（16位）</strong>：</p>
<ul>
<li>用于流量控制，表示接收端当前能够接收的最大字节数。</li>
</ul>
<p><strong>标志位（6位，常用位如下）</strong>：</p>
<ul>
<li><strong>URG</strong>（紧急标志）：标志该段包含紧急数据，通常不使用。</li>
<li><strong>ACK</strong>（确认标志）：标志确认号字段有效。</li>
<li><strong>PSH</strong>（推送标志）：表示要求接收方立即将数据交付给应用层。</li>
<li><strong>RST</strong>（重置标志）：用于重置连接。</li>
<li><strong>SYN</strong>（同步标志）：用于建立连接。</li>
<li><strong>FIN</strong>（终止标志）：用于断开连接。</li>
</ul>
<h5 id="TCP序列号和确认号"><a href="#TCP序列号和确认号" class="headerlink" title="TCP序列号和确认号"></a>TCP序列号和确认号</h5><p>最重要的两个部分：<strong>序列号</strong>、<strong>确认号</strong>。</p>
<p>TCP 将数据看成一种字节流，所以序列号和确认号是基于字节上定义的，而不是按照报文段的序列。</p>
<p><strong>TCP序号表示的是当前报文段数据部分第一个字节的序号</strong>，序列号用于跟踪数据流的顺序和确保数据包的完整性，接收方通过序列号来重新排序数据包，以便正确重组原始数据流。</p>
<p><strong>确认号表示期望收到的下一部分数据的首字节序号</strong>，代表确认号之前的数据（不包括确认号本身）已被成功接受。(累计确认)</p>
<p>如下图，第一个报文段的序号为0，第二个报文的序列号为1000…</p>
 

 

<h4 id="TCP往返时间的估计与超时（感觉不是重点）"><a href="#TCP往返时间的估计与超时（感觉不是重点）" class="headerlink" title="TCP往返时间的估计与超时（感觉不是重点）"></a>TCP往返时间的估计与超时（感觉不是重点）</h4><p>假设你有一个估计RTT的值，并且还有一个测量RTT跟估计RTT的偏离程度的值：偏离RTT。</p>
<p>一般TCP设置超时时间为 估计RTT + 4 * 偏离RTT。</p>
<h4 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h4><p>TCP在IP不可靠的尽力而为服务之上创建了一种<strong>可靠数据传输服务</strong>。</p>
<p>TCP的可靠数据传输是一种流水线协议，是GBN和SR两种协议的混合体。</p>
<ul>
<li><p>TCP采用累计确认（类GBN）</p>
</li>
<li><p>TCP使用单个重传计时器（类GBN）</p>
<p>这个重传计时器与最早的未被确认的报文段相关联</p>
</li>
<li><p>TCP触发超时重传时只重发那个最早的未确认的段（类SR）</p>
</li>
</ul>
<h5 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h5><p>每当有超时事件发生，TCP只重传当前未被确认的最小序号的报文段，然后<strong>设置超时间隔为先前值的两倍</strong>，而不是刚刚的用估计RTT和偏移RTT所计算的值。</p>
<p>这是因为发生超时事件，意味着网络很堵塞，所以超时时间长点。</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>接收方接收到报文段后，发出ACK有四种情况：</p>
 

<p>我只分析第一和第三种情况：</p>
<ul>
<li>当接收方接收到期望序号的报文后，选择等500ms再发送ACK，这是因为假设下个期望序号的报文若此时到达，则只需要发送一次ACK（TCP是累计确认）。</li>
<li>发送ACK的序号为当前的期望序号。</li>
</ul>
<p>当发送方根据上面的第三种情况连续收到三次冗余ACK，则意识到这个冗余ACK的期望序号的报文没有成功到达，所以<strong>立即重传</strong>。 </p>
 

<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>主要考虑的是发送端和接收端的速率差太大，即发送方发的很快，但是接收方处理的很慢，并且接收方缓存会慢慢变满。</p>
<p><strong>流量控制服务可以消除接收方缓存溢出的可能。</strong></p>
<p>TCP 让发送方维护一个<strong>接收窗口</strong>的变量来控制流量，接收窗口可以用来给发送方一个指示–接收方还有多少可用的缓存空间。</p>
<p>这个变量就是TCP头部的窗口大小值。</p>
<p>发送方根据接收到的接收窗口值，调整接下来要发送的数据量。如果接收窗口值较大，发送方可以加快数据发送速率；如果接收窗口较小，发送方会减缓发送速率，甚至停止发送数据，直到接收窗口再次打开。</p>
<blockquote>
<p>若是UDP协议，若接收方在缓存中读取数据的速度不够快，则缓存会满，报文段会丢失。</p>
</blockquote>
<h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>主要讲的是<strong>三次握手</strong>和<strong>四次挥手</strong>。</p>
<p>刚刚前面有说到，TCP是面向连接的，即发送方和接收方会先进行握手协议。</p>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5> 

<ul>
<li>第一步：<strong>客户端生成 SYN 报文</strong>，将 TCP首部的SYN位置 1，随机生成一个初始序号值 X，没有任何数据内容。</li>
<li>第二步：<strong>服务器端返回 SYN-ACK报文</strong>，将 TCP首部的SYN位和ACK位置 1，随机生成一个初始序号值 Y，确认号为 X+1，并且为该 TCP 连接分配缓存。</li>
<li>第三步：<strong>客户端生成 ACK 报文</strong>，将 TCP首部的ACK位置 1，确认号为 Y+1，在客户端分配缓存。在这个时候已经可以携带数据传输了。</li>
</ul>
<p>为什么不使用二次握手呢？</p>
 

<ul>
<li>因为可能服务器响应不够快，客户端直接重传了。</li>
</ul>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5> 

<ul>
<li>第一步：<strong>客户端生成 FIN 报文</strong>，将 TCP首部的FIN位置 1，随机生成一个初始序号值 X，没有任何数据内容。</li>
<li>第二步：<strong>服务端生成 ACK 报文</strong>，将 TCP首部的ACK位置 1，确认号为 X+1。</li>
<li>第三步：<strong>服务端生成 FIN 报文</strong>，将 TCP首部的FIN位置 1，随机生成一个初始序号值 Y，没有任何数据内容。</li>
<li>第四步：<strong>客户端生成 ACK 报文</strong>，将 TCP首部的ACK位置 1，确认号为 Y+1。</li>
</ul>
<blockquote>
<p>需要记得FIN报文和SYN报文是会占据序列号的，ACK报文不会。</p>
</blockquote>
<h4 id="TCP拥塞管理"><a href="#TCP拥塞管理" class="headerlink" title="TCP拥塞管理"></a>TCP拥塞管理</h4><p>需要在发送方增加多一个变量–拥塞窗口值。</p>
<blockquote>
<p>拥塞窗口是<strong>发送方维护的变量</strong>，表示网络当前能够安全传输的数据量上限。</p>
<p>接收窗口是<strong>接收方维护的变量</strong>，表示接收方当前能够接收并缓存的数据量上限。</p>
</blockquote>
<p>拥塞窗口对一个TCP发送方能向网络中发送流量的速率进行了限制，在一个发送方中未被确认的数据量不会超过cwnd与rwnd中的最小值。<br>$$<br>\text{LastByteSent} - \text{LastByteAcked} \leq \min{\text{cwnd}, \text{rwnd}}<br>$$<br>在每个往返时间RTT的起始点，允许发送方向该连接发送cwnd个字节的数据，在该RTT结束时发送方接收对数据的确认报文。因此发送方发送的数据大概为<strong>cwnd&#x2F;RTT</strong> 字节&#x2F;秒。可以调整cwnd的值来控制发送方速率。</p>
<blockquote>
<p>这里主要考虑拥塞管理，所以假设接收窗口为无穷大。</p>
</blockquote>
<p>TCP发送方定义的<strong>丢包事件</strong>为：</p>
<ul>
<li>超时。</li>
<li>收到三个冗余ACK报文。</li>
</ul>
<p>拥塞控制算法思想：当TCP发生丢包事件，就减少cwnd的值；如果接收到ACK，就增加cwnd的值（ACK意味着一切安好）。</p>
<h5 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h5><ol>
<li><p><strong>慢启动</strong></p>
<p>在<strong>慢启动</strong> 阶段，cwnd的值以一个MSS开始，并且每当传输的报文段被确认就增加一个MSS。</p>
<p>在这个过程中，每经过一个RTT，发送速率就会翻倍。</p>
 

<ul>
<li><p><strong>若发生超时事件</strong></p>
<p>当出现超时情况后，TCP发送方会把cwnd的大小设置为1并重新开始慢启动过程，同时将慢启动阈值ssthresh设置为cwnd大小的一半，即ssthresh&#x3D;cwnd&#x2F;2。</p>
<p>后面当cwnd到达或超过慢启动阈值后，说明此时快要触碰到上限了，继续指数增长过于鲁莽，因此会结束慢启动阶段，进入拥塞避免阶段。</p>
<p>在拥塞避免阶段，cwnd线性增长。当再次发生超时事件，发送方会更新慢启动阈值，将其设置为当前cwnd大小的一半，然后把cwnd的大小设置为1重新开始慢启动，以此类推。</p>
</li>
<li><p><strong>若接收到三个冗余ACK</strong></p>
<p>因为这个情况没有<strong>超时</strong>这么严重，会将慢启动阈值设置为cwnd大小的一半，然后进入快速恢复阶段。</p>
</li>
</ul>
</li>
<li><p><strong>拥塞避免</strong></p>
<p>一旦进入了拥塞控制阶段，cwnd的值大约是上次遇到拥塞时值的一半，说明距离拥塞已经不远。</p>
<p>TCP选择采用了一种更保守的方式，即每个RTT只将cwnd增加一个MSS。</p>
<ul>
<li><p><strong>若发生超时事件</strong></p>
<p>若触发超时，会更新慢启动阈值并进入慢启动阶段。</p>
</li>
<li><p><strong>若接收到三个冗余ACK</strong></p>
<p>更新慢启动阈值为cwnd的一半并且将cwnd设置为cwnd&#x2F;2 + 3，进入快速恢复状态。</p>
</li>
</ul>
</li>
<li><p><strong>快速回复</strong></p>
<p>分成早期版本TCP Tahoe和新版本TCP Reno。</p>
<ul>
<li><p><strong>TCP Tahoe</strong></p>
<p>将收到三个冗余ACK的事件跟超时事件处理一样，将cwnd设置为1，阈值为cwnd一半，并进入慢启动阶段。</p>
</li>
<li><p><strong>TCP Reno</strong></p>
<p>将cwnd设置为cwnd&#x2F;2 + 3，阈值为cwnd一半，继续拥塞避免阶段。</p>
</li>
</ul>
</li>
</ol>
<h5 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h5><p>TCP拥塞控制算法是<strong>加性增，乘性减</strong>的。</p>
 

<p>假设 W 为拥塞窗口极限大小，每次cwnd的值一到达W就会发生三次冗余ACK。</p>
<p>TCP的发送速率在0.5*W&#x2F;RTT 和W&#x2F;RTT 反复横跳。</p>
<p>最终：<br>$$<br>一条连接的平均吞吐量 &#x3D; \frac{0.75*w}{RTT}<br>$$</p>
<h4 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h4><p>如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R&#x2F;K，我们将TCP的这种特点称之为<strong>TCP的公平性</strong>。</p>
 

<ul>
<li><p>我们首先假设两条连接最开始的状态位于A点，此时连接1的吞吐量大于连接2，由于A点位于RR的下方，说明两条连接都处于拥塞控制状态（忽略慢启动）。</p>
</li>
<li><p>此时每过一个RTT，两条连接的cwnd都会加一，也就是说此时的状态会由A点45度向右上角移动。</p>
</li>
<li><p>当到达B点后，由于B点位于RR上方，超过了带宽的承受能力，两条连接的吞吐量都会回退到原本来的一半（依旧忽略慢启动）。</p>
</li>
<li><p>因为连接1的吞吐量比较大，减半后减少的吞吐量会更多，所以会退到C点，然后继续进入拥塞控制状态慢慢移动到D点。</p>
</li>
<li><p>以此类推，最终会收敛到两条连接的吞吐量相等的位置。</p>
</li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul>
<li>  
</li>
<li><p>TCP的流量控制主要是防止发送方发送的数据量超过接收方的处理能力，避免接收端的缓冲区溢出。</p>
<p>而拥塞控制是防止发送方过快地向网络中注入数据，避免造成网络拥塞。</p>
</li>
</ul>
<h2 id="第四章-网络层（数据平面）"><a href="#第四章-网络层（数据平面）" class="headerlink" title="第四章 网络层（数据平面）"></a>第四章 网络层（数据平面）</h2><p>为<strong>主机和主机</strong>之间提供了逻辑通信。</p>
<p>网络层提供的功能其实就是<strong>转发</strong>和<strong>路由选择</strong>。</p>
<ul>
<li>转发（做搬运工）：将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。</li>
<li>路由选择：指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。计算路径的算法叫<strong>路由选择算法</strong>，在网络中交换路由信息的通信协议被称为<strong>路由选择协议</strong>。</li>
</ul>
<p>网络层可以分解成<strong>数据平面（转发）</strong>和<strong>控制平面（路由选择）</strong>。</p>
<h3 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h3><p>目的是实现<strong>转发</strong>功能。</p>
<p>每个路由器都有一个<strong>转发表</strong>。</p>
<p>传统：<strong>基于目标地址 + 转发表</strong></p>
<ul>
<li>路由器会检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，通过这种方法来转发分组。</li>
</ul>
<p>SDN 方法：<strong>基于多个字段 + 流表</strong></p>
<ul>
<li>传统方法只使用目标地址进行转发，SDN 方法利用了更多信息（如源IP地址和目的IP地址）。</li>
<li>SDN 中流表指分组交换机中用于转发的表（即记录流转发方式的表）。SDN使用流表取代传统路由器中的转发表。</li>
</ul>
<h3 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h3><p>目的是<strong>决定数据报从源到目标主机之间的端到端路径</strong>。</p>
<p>传统：<strong>分布式计算转发表</strong></p>
<ul>
<li>路由选择算法运行在每台路由器中，并且在<strong>每台路由器中都包含转发和路由选择两种功能</strong>。</li>
<li>一台路由器中的路由选择算法与其他路由器中的路由选择算法通信，以计算出它的转发表的值。</li>
</ul>
<p>SDN方法：<strong>集中计算流表</strong></p>
<ul>
<li>SDN 方式下控制平面路由选择功能与物理的路由器是分离的，即<strong>路由器选择设备仅执行转发</strong>，而远程控制器计算并分发流表。</li>
<li>SDN 允许网络管理员在不手动处理网络硬件设备的前提下，使用集中化程序重新规划网络，控制复杂网络拓扑以及网络流量。<strong>将传统的分布式规则计算演变为集中计算</strong>。</li>
</ul>
<blockquote>
<p>SDN 方法了解即可。</p>
</blockquote>
<p>网络层提供了单一的服务，称为<strong>尽力而为服务</strong>。</p>
<h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>路由器由四个组件组成：输入端口、输出端口、交换结构、路由选择处理器。</p>
 

<ul>
<li><p>上方为控制平面，负责路由：运行路由选择算法&#x2F;协议（RIP、OSPF、BGP） - 生成路由表。</p>
</li>
<li><p>下方为数据平面，负责转发：从输入到输出链路交换数据报 - 根据路由表进行分组的转发。</p>
</li>
</ul>
<h4 id="输入端口处理和基于目的地转发"><a href="#输入端口处理和基于目的地转发" class="headerlink" title="输入端口处理和基于目的地转发"></a>输入端口处理和基于目的地转发</h4>

<p>流程：数据链路的帧进入到通信链路输入端口，将帧拆封，在路由器内进行查找（按照转发表选择对应的输出端口）、转发、排队（等待将IP数据包传输到输出端口）。</p>
<h5 id="最长前缀匹配（必考）"><a href="#最长前缀匹配（必考）" class="headerlink" title="最长前缀匹配（必考）"></a>最长前缀匹配（必考）</h5><p>在基于目的地转发模式下，我们使用<strong>最长前缀匹配规则</strong> 来查找路由。</p>
<p>路由器使用分组目的地址（IP）的前缀与路由表中的表项进行匹配。</p>
<p>当有多个匹配时，在该表中寻找最大的匹配项。</p>
 

<p>例如 11001000 00010111 0011000 11111111，则同时匹配第二项和第三项，根据最长前缀匹配规则，转发至链路接口2。</p>
<h5 id="输入端口缓存"><a href="#输入端口缓存" class="headerlink" title="输入端口缓存"></a>输入端口缓存</h5><p>如果来自其他输入端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被阻塞，所以需要存放在输入端口缓存。</p>
<h4 id="交换-1"><a href="#交换-1" class="headerlink" title="交换"></a>交换</h4><p>交换结构位于一台路由器的核心部位。</p>
<p>有三种方式实现：内存、总线、互联网。</p>
 

<ul>
<li><p><strong>内存</strong></p>
<p>该交换结构下，输入端口与输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。</p>
<p>在这种情况下，如果内存带宽为每秒可写进内存或从内存读出最多B个分组，则总的转发吞吐量（分组从输入端口被传送带输出端口的总速率）必然小于B&#x2F;2，因为每个数据包需要写入和读出这两次操作。</p>
<p>一次只能转发一个分组。</p>
</li>
<li><p><strong>总线</strong></p>
<p>该交换结构下，数据报通过共享总线，从输入端口转发到输出端口。</p>
<p>如果多个分组同时到达路由器，每个位于不同的输出端口，除了一个分组外所有其他分组必须等待，<strong>因为一次只有一个分组能够跨越总线</strong>。</p>
<p>因为每个分组必须跨过单一总线，故路由器的交换带宽受总线速率的限制；</p>
</li>
<li><p><strong>互联网</strong></p>
<p><strong>该交换结构下，同时并发转发多个分组</strong>，克服单一、共享式总线带宽限制。</p>
<p>纵横式网络能够并行转发多个分组。例如当分组达到端口A，需要转发到端口Y时，交换机控制器闭合总线A和Y交叉部位的的交叉点，然后端口A在其总线上发送该分组，该分组仅由总线Y接收。</p>
<p>而来自端口B的一个分组在同一时间能够转发到端口X，因为A到Y和B到X的分组使用不同的输入和输出总线。</p>
</li>
</ul>
<h4 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h4> 

<p>与输入端口对应，输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。</p>
<blockquote>
<p>缓存并不是越大越好，虽然更大的缓存可以降低路由器的分组丢失率，但是意味着更长的排队时延！！</p>
</blockquote>
<h4 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h4><p>这里跟操作系统的原理一样，我就不细写了。</p>
<ul>
<li><p><strong>先进先出（FIFO）</strong></p>
 
</li>
<li><p><strong>优先权排队</strong></p>
 

<p>在<strong>非抢占式优先权排队</strong> 规则下，一旦分组开始传输，就不能打断。例如在下面的这个过程中，分组1、3和4属于高优先权类，分组2和5属于低优先权类。分组4到达时，分组2正在传输中，分组4不会将其打断，而是排队等待传输，等其传输完成后开始传输。</p>
 
</li>
<li><p><strong>循环排队</strong></p>
<p>传输完类1的一个分组后，开始传输类2的一个分组，然后是类3，以此类推，最后循环到类1。</p>
<p>分组1 2 4属于第一类，分组3 5属于第二类。</p>
 
</li>
<li><p><strong>加权平均排队</strong></p>
 

<p>在<strong>加权公平排队</strong> 规则下，分组会被分到不同的类，WFQ调度器也以循环的方式为各个类提供服务。但是由于每个类在任何时间间隔内可能收到不同数量的分组，因此每个类都会被分配一个权w，每一个类在一个循环中获得不同权重的服务量。</p>
<blockquote>
<p>每个队列得到的服务时间并不是严格按照权重比例的，因为它不会打断一个分组的传输来开始传输另一个分组。</p>
</blockquote>
</li>
</ul>
<h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h3><h4 id="IPV4-数据包格式"><a href="#IPV4-数据包格式" class="headerlink" title="IPV4 数据包格式"></a>IPV4 数据包格式</h4> 

<ul>
<li><strong>版本：</strong>占4比特，指ip协议版本号，ipv4分组中此处应为4。</li>
<li><strong>首部长度：</strong>占4比特，表示ip首部的长度，以4字节为单位，最小值为5（即20字节）。</li>
<li><strong>服务类型</strong>：占8比特，用于指定服务质量需求，如延迟、吞吐量和可靠性。</li>
<li><strong>数据报总长度：</strong>占16比特，表示整个ip数据报（包括首部和数据）的总长度，单位是字节，最大值为65535字节。</li>
<li><strong>标识：</strong>占16比特，用于唯一标识每个ip数据报，在分片传输时帮助分片重组。</li>
<li><strong>标志：</strong>占3比特，用于控制数据报的分片行为，包括是否允许分片（df）和是否有更多分片（mf）。</li>
<li><strong>片偏移：</strong>占13比特，用于指示当前分片在原始数据报中的相对位置，单位是8字节。</li>
<li><strong>生存时间</strong>：占8比特，表示数据报的最大生存周期，<strong>每经过一个路由器减1，防止数据报在网络中无限循环。</strong></li>
<li><strong>上层协议</strong>：占8比特，表示数据报承载的上层协议类型，例如tcp（值为6）或udp（值为17）。</li>
<li><strong>首部校验和：</strong>占16比特，用于检测ip首部在传输过程中是否损坏，不校验数据部分。</li>
<li><strong>源ip地址：</strong>占32比特，表示数据报的发送方ip地址。</li>
<li><strong>目标ip地址：</strong>占32比特，表示数据报的接收方ip地址。</li>
<li><strong>选项：</strong>可变长度，用于携带额外控制信息，例如路由记录或时间戳，不是必选字段。</li>
<li><strong>数据部分：</strong>可变长度，承载实际应用层或传输层的数据内容，其长度等于数据报总长度减去首部长度。</li>
</ul>
<p><strong>要记得IP头部至少为20字节！</strong>TCP头部是20字节，UDP头部为8字节。</p>
<p>数据链路的帧的数据部分最大（MTU）为1500字节，<strong>如果IP数据包过大则会分片</strong>。</p>
<p>假设一个无分片的TCP报文封装的数据帧，至少承载了<strong>40字节的首部信息</strong>！！</p>
<h4 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h4><p><strong>IP地址</strong>是对主机或者路由器与网络的<strong>接口</strong>的编址，共32位。</p>
<p>IP地址不能唯一的识别设备，MAC地址可以。</p>
<h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p>一个子网内的节点（主机或者路由器）的IP地址的高位部分相同，这些节点构成的网络的一部分叫做<strong>子网</strong>，IP地址的<strong>高位表示子网部分</strong>，<strong>低位表示主机部分</strong>。</p>
<p>子网内的各主机之间通信无需路由器能直接连通，因为数据链路层连通。</p>
 

<p>例如为左边的子网分配地址223.1.1.0&#x2F;24，其中的&#x2F;24就是<strong>掩码</strong>，意味着前24个比特组成了子网地址。</p>
<p>划分子网时，将每一个接口从主机或路由器上分开，构成一个个网络的孤岛，每一个孤岛都可称之为子网。以下图为例，将其划分为6个子网，因为每个路由器之间的网络也是一个子网。</p>
 

<h4 id="IP地址分配"><a href="#IP地址分配" class="headerlink" title="IP地址分配"></a>IP地址分配</h4><p><strong>分类编址：</strong>将IP地址分成A B C三类，三类的网络部分比特分别为8 16 24。</p>
<p>CIDR编址：就是我们现在用的方法，将IP地址用a.b.c.d&#x2F;x来分类。</p>
<h4 id="获取IP地址"><a href="#获取IP地址" class="headerlink" title="获取IP地址"></a>获取IP地址</h4><p>可以从一个大子网（主机比特更多）拆分成多个小子网（主机比特更少）。</p>
 

<p>将一个 ISP 拆分成了8个子 ISP。可以观察主机部分的比特，原本为12位，拆分之后变成9位，即每个小子网的主机数量是原本子网的1&#x2F;8。</p>
<p>要记得IP地址全0和全1都是保留的，不可以使用！</p>
<ul>
<li>全1是广播地址。</li>
</ul>
<h5 id="DHCP（动态主机配置协议）重要"><a href="#DHCP（动态主机配置协议）重要" class="headerlink" title="DHCP（动态主机配置协议）重要"></a>DHCP（动态主机配置协议）重要</h5>

<p>DHCP允许主机自动获得一个IP地址。</p>
<p>使用UDP作为传输层。</p>
<p>DHCP是应用层协议。</p>
<p>除了为主机发送IP地址之外，<strong>还会发送网关IP，DNS服务器IP</strong>。</p>
  

<p>DHCP一共有四个流程：DHCP发现、DHCP提供、DHCP请求、DHCP ACK：</p>
<ol>
<li><p><strong>DHCP服务器发现</strong>：新接入网络的主机会尝试获取 IP 地址，它会向网络发送一个<strong>DHCP发现报文</strong>。该报文是广播报文，<strong>目的是寻找网络中可用的 DHCP 服务器</strong>。</p>
<p>由于主机在初始阶段还没有 IP 地址，所以报文是从源 IP <code>0.0.0.0</code> 广播到目的 IP <code>255.255.255.255</code>。</p>
<p>这个过程使 DHCP 服务器得知有新设备需要分配 IP 地址。</p>
</li>
<li><p><strong>DHCP服务器提供</strong>：DHCP服务器收到一个DHCP发现报文时，会从其可用的 IP 地址池中选取一个地址，并用<strong>DHCP提供报文</strong>向客户做出回应，告知主机它可以使用这个 IP 地址，该报文依旧使用IP广播地址<code>255.255.255.255</code>。</p>
</li>
<li><p><strong>DHCP请求</strong>：新到达的客户从一个或多个服务器提供中选择一个，并向其发送<strong>DHCP请求报文</strong>，来告知 DHCP 服务器它选择了哪个提供的 IP 地址。</p>
</li>
<li><p><strong>DHCP ACK</strong>：当 DHCP 服务器收到主机的请求报文后，会发送一个<strong>DHCP确认报文</strong>给主机，告知其正式使用提供的 IP 地址及配置信息。</p>
</li>
</ol>
<blockquote>
<p>一直都将目的IP设为广播。</p>
</blockquote>
<h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>将家庭中的私有地址和公网地址进行映射。</p>
<p>可以实现一块局域网内部的设备公共一个IP地址，而不需要从ISP分配一块地址。</p>
 

<p>主要是通过NAT路由器的NAT转换表工作！</p>
<p>流程如下：</p>
<ol>
<li><p>主机<code>10.0.0.1</code>向<code>128.119.40.186</code>，80号端口发送数据报，该数据报的源地址为<code>10.0.0.1</code>，3345号端口，目标地址为<code>128.119.40.186</code>，80号端口。</p>
</li>
<li><p>该数据报到达NAT路由器后，路由器将其源地址修改为此内网公用的IP地址，并选一个没有被占用的端口号来代表该内网主机，此时数据报的源地址为<code>138.76.29.7</code>，5001号端口。</p>
</li>
<li><p>然后将这种映射关系记录在NAT转换表中。</p>
</li>
<li><p>当NAT路由器收到广域网返回的响应数据报时，该数据报的目标地址为<code>138.76.29.7</code>，5001号端口。NAT路由器查找表项后发现，5001号端口对应的是内网的<code>10.0.0.1</code>，3345号端口。</p>
</li>
<li><p>于是将数据报中的目标地址修改为<code>10.0.0.1</code>，3345号端口后，发送给对应内网主机。</p>
</li>
</ol>
<p><strong>广域网返回的响应经过NAT路由器更改了目的IP和目的端口！！</strong></p>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>因为IPV4的32位地址即将用完，所以开发了IPV6，IPV6有128位地址。</p>
<p>IPV6没有分片功能，因为这会增加路由器的工作，不符合复杂事情都在网络边缘干的设计思想。</p>
<h4 id="IPV6数据包格式"><a href="#IPV6数据包格式" class="headerlink" title="IPV6数据包格式"></a>IPV6数据包格式</h4> 

<ul>
<li><p><strong>版本</strong>：占4比特，用于表示IP版本号，这里毫不意外地将值设置为6。</p>
</li>
<li><p><strong>流量类型</strong>：占8比特，相当于IPv4的服务类型字段，用于区分优先级。</p>
</li>
<li><p><strong>流标签</strong>：占20比特。可以理解为同一个IP发出来的属于同一个会话的数据，可以为其打上同样的一个流标签，试图让网络对同一个流的数据做出同样的处理。</p>
</li>
<li><p><strong>有效载荷长度</strong>：占16比特，该值作为一个无符号整数，给出了IPv6数据报中在定长的40字节数据报首部后面的字节数量。</p>
</li>
<li><p><strong>下一个首部</strong>：占8比特，标识数据报中的内容需要交付给哪个协议（如TCP或UDP），使用与IPv4首部中协议字段相同的值。</p>
</li>
<li><p><strong>跳限制</strong>：占8比特，转发数据报的每台路由器将对该字段的内容减1，如果跳限制计数达到了0，则该数据报将被丢弃。</p>
</li>
</ul>
<p>IPV6头部占了40字节（源地址目的地址一共占了32字节）！</p>
<p>对比IPV4头部内容更加简化了。</p>
<h4 id="IPV4到IPV6的迁移"><a href="#IPV4到IPV6的迁移" class="headerlink" title="IPV4到IPV6的迁移"></a>IPV4到IPV6的迁移</h4><p>通过<strong>隧道</strong>实现，实际上还是一种抽象。</p>
 



<p>假定两个IPV6节点是依靠IPV4路由器互联的，将依靠的IPV4路由器的集合成为<strong>隧道</strong>。</p>
<p>在上图中，B和E路由器是同时支持IPv4和IPv6的。</p>
<p>流程如下：</p>
<ol>
<li>借助于隧道，在隧道发送端的IPv6节点可将整个IPv6数据报放到一个IPv4数据报的数据字段中，进行运输。（IPv6此时很像传输层协议）。</li>
<li>隧道接收端的IPv6节点最后收到该IPv4数据报，并确定其包含一个完整的IPv6数据报（通过观察IPv4数据报中的协议号字段是41）后，从中取出IPv6数据报，继续为其进行路由。</li>
</ol>
<h3 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h3><p>这里我就简单的描述概念。</p>
<p>主要思想是因为传统的路由选择算法是只依靠<strong>目的IP</strong>这个单一的信息进行计算，并且是每个路由器自己<strong>独立</strong>、<strong>分布式计算</strong>的，而我们想利用<strong>更多的信息</strong>（例如源IP和传输层源端口和目的端口）来进行路由，并且希望是由一个远程控制器来计算路由，路由器只负责转发。</p>
<ul>
<li><p><strong>更多的信息</strong>也被称为流。</p>
</li>
<li><p>实现了控制平面和数据平面的分离，传统的方法路由器需要计算转发表（路由）和进行转发。</p>
</li>
</ul>


<h2 id="第五章-网络层（控制平面）"><a href="#第五章-网络层（控制平面）" class="headerlink" title="第五章 网络层（控制平面）"></a>第五章 网络层（控制平面）</h2><p>本章的目标是学习路由器中的<strong>转发表</strong>和<strong>流表</strong>是如何计算的。</p>
<p>完成这个工作有两种实现方法：</p>
<ul>
<li><p><strong>每路由器控制：</strong></p>
<p>在每台路由器中运行一种路由选择算法，每台路由器都包含转发和路由选择功能（即数据平面和控制平面没有独立）。</p>
<p>路由器之间会进行通信。</p>
 
</li>
<li><p><strong>逻辑集中式控制：</strong></p>
<p>控制器计算并分发转发表给每一台路由器，每一台路由器都只负责转发功能（实现数据平面和控制平面的独立）。</p>
<p>路由器之间不会进行通信。</p>
</li>
</ul>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>目的是从发送方到接收方的过程中找到一条<strong>具有最低开销</strong>的路径。</p>
<p>路由选择算法可以根据输入分为<strong>集中式路由选择算法</strong> 和 <strong>分散式路由选择算法</strong>。</p>
<ul>
<li><strong>集中式路由选择算法</strong>：所有的路由都拥有完整的全局拓扑信息，这样的算法被称作<strong>链路状态算法</strong>。</li>
<li><strong>分散式路由选择算法</strong>：路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径，这样的算法被称为<strong>距离向量算法</strong>。</li>
</ul>
<p>路由选择算法也可以根据算法是静态的还是动态的进行分类：</p>
<ul>
<li><strong>静态路由选择算法</strong>： 路由随时间的变化非常缓慢，通常是人工进行调整；</li>
<li><strong>动态路由选择算法</strong> ：会随着网络流量负载或拓扑发生变化而改变路由选择路径。</li>
</ul>
<h4 id="链路状态路由选择算法-LS"><a href="#链路状态路由选择算法-LS" class="headerlink" title="链路状态路由选择算法 LS"></a>链路状态路由选择算法 LS</h4><p>因为输入就是全局拓扑（代价），每个路由器使用 Dijkstra 算法来计算自己到每个节点的最小代价，计算自己的路由表。</p>
 

<p>对上图的 u 节点进行 Dijkstra 算法如下，详细这里就不写了。 </p>
<h4 id="路由选择的振荡"><a href="#路由选择的振荡" class="headerlink" title="路由选择的振荡"></a>路由选择的振荡</h4><p>每次执行一次LS算法，最短路都会发生改变。（这个有点太细了）</p>


<h4 id="距离向量路由选择算法-DV"><a href="#距离向量路由选择算法-DV" class="headerlink" title="距离向量路由选择算法 DV"></a>距离向量路由选择算法 DV</h4><p>每个节点维护一张路由表，跟邻居交换路由表，根据交换后的信息，计算最低代价并且更新自己的路由表。</p>
<p>计算最低代价与 Bellman-Ford 方程相关：<br>$$<br>d_x(y) &#x3D; \min_v { c(x, v) + d_v(y) }<br>$$<br>下图有一个书本的例子：</p>
 



<p>DV算法流程：</p>
<ol>
<li>一开始每个路由器的路由表只有自己到自己邻居的代价。</li>
<li>跟邻居互相交换信息（传送自己的距离向量给邻居），并将邻居的信息加入路由表并计算自己的距离向量。</li>
<li>如果自己的距离向量因为邻居的信息而变小，将更新后的距离向量发给邻居。<strong>只有在自己的最低开销改变，才会发送距离向量给邻居！！</strong></li>
<li>直到无更新为止。</li>
</ol>
<h4 id="链路开销改变"><a href="#链路开销改变" class="headerlink" title="链路开销改变"></a>链路开销改变</h4> 

<p>情况 a：</p>
<ul>
<li>t0时刻：y发现链路状态更新，更新其距离向量，并发送给邻居。</li>
<li>t1时刻：z发现到x的最小代价减少，更新其距离向量，并发送给邻居。</li>
<li>t2时刻：y收到z的更新，但y自己的最低代价没有改变，所以算法停止。</li>
</ul>
<p>情况 b：</p>
<ul>
<li>t0时刻：y发现链路状态更新，更新其距离向量到x的距离有6（因为它知道z可以以代价5到达x），发送给邻居。</li>
<li>t1时刻：z收到y的更新，并更新其距离向量到达x的距离为7（因为z直连到x需要50，但y到x只需要代价6）。</li>
<li>t2时刻：y收到z的更新，并将自己的距离向量改为到x的距离为8…</li>
<li>t3时刻：z收到y的更新，并将自己的距离向量改为到x的距离为9…</li>
<li>…</li>
<li>直到当z经由y到x的距离大于50（一共需要44次迭代！！）</li>
</ul>
<p>这个问题就是<strong>路由选择环路</strong>。</p>
<p>解决方法就是<strong>增加毒性逆转</strong>，即类似<strong>z通过y到达x</strong>，则<strong>z告诉y自己是没有直连到x的</strong>。</p>
<h4 id="LS和DV路由选择算法的比较"><a href="#LS和DV路由选择算法的比较" class="headerlink" title="LS和DV路由选择算法的比较"></a>LS和DV路由选择算法的比较</h4><p>LS算法是<strong>全局</strong>性的，DV算法是<strong>分布式</strong>的、<strong>局部</strong>的。</p>
<ul>
<li>报文复杂性：LS更复杂，因为要有全局信息。</li>
<li>收敛速度：LS收敛更快，DV可能遇到路由选择环路。</li>
<li>健壮性：LS健壮性更好。</li>
</ul>
<h3 id="自治系统内部的路由选择（必考）"><a href="#自治系统内部的路由选择（必考）" class="headerlink" title="自治系统内部的路由选择（必考）"></a>自治系统内部的路由选择（必考）</h3><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p>自治系统通常由一组处在<strong>相同管理控制下的路由器</strong>组成。</p>
<p>在相同AS中的路由器都运行<strong>相同的路由选择算法</strong>并且<strong>拥有彼此的信息</strong>。</p>
<p>在一个自治系统内部运行的路由选择算法叫做<strong>自治系统内部路由选择协议</strong>。</p>
<p><strong>下面的两个算法都是iBGP</strong>。</p>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p>其实书本上没有RIP，但我怕考到就RIP了，所以还是简单的写一下。</p>
<p>RIP是一种<strong>基于距离向量的路由选择协议</strong>，RIP以 <strong>跳数</strong> 作为代价，每经过一个路由器就加一。RIP允许一条路径最多只能包含15个路由器，距离16相当于不可达，每个DV通告最多可以包含 25 个目标网络。因此RIP只适用于小型互联网。</p>
<h4 id="OSPF（必考）"><a href="#OSPF（必考）" class="headerlink" title="OSPF（必考）"></a>OSPF（必考）</h4><p>基于<strong>链路状态算法</strong>实现的，使用<strong>泛洪链路状态信息</strong>和 <strong>Dijkstra</strong> 最低开销路径算法。</p>
<p>使用OSPF时，路由器向整个自治系统内的路由器广播<strong>路由选择信息</strong>和<strong>链路状态信息</strong>。</p>
<p>OSPF的优点：</p>
<ul>
<li>安全</li>
<li>负载均衡</li>
</ul>
<p>OSPF 可以分层（<strong>一个主干区域</strong>和<strong>多个非主干区域</strong>），并且每个区域运行自己的OSPF链路状态路由选择算法。</p>
<p>但是主干区域一定包含本AS中<strong>所有的区域边界路由器</strong>。</p>
 

<ul>
<li>区域边界路由器（area border router）负责连接多个区域，并在不同区域之间传播路由信息。</li>
<li>骨干路由器（backbone router）仅在骨干区域内，运行OSPF路由。</li>
<li>边界路由器（boundary router）用于连接其他的AS。</li>
</ul>
<p>AS中的区域间的路由器传输流程如下：</p>
<ul>
<li><p>分组先到达自己区域的区域边界路由器</p>
</li>
<li><p>通过主干区域到达目的区域的区域边界路由器</p>
</li>
<li><p>到达目的路由器</p>
<blockquote>
<p>在每个区域内的路由器都知道自己去往自己边界路由器的最短路径！</p>
</blockquote>
</li>
</ul>
<h3 id="ISP-之间的路由选择：BGP（必考）"><a href="#ISP-之间的路由选择：BGP（必考）" class="headerlink" title="ISP 之间的路由选择：BGP（必考）"></a>ISP 之间的路由选择：BGP（必考）</h3><p>刚刚分析的是AS内部的路由选择协议，现在考虑AS之间的路由选择协议。</p>
<p>在因特网中，所有的AS间都运行边<strong>界网关协议BGP</strong>。</p>
<p>BGP实际上是<strong>DV距离向量</strong>算法，但是它不只记录了代价和下一跳路由器，还记录了详细路径（AS序号的列表）。</p>
 

<p>考虑上图：我们可以将AS间的路由器分成<strong>网关路由器</strong>和<strong>内部路由器</strong>。</p>
<p>还有一些简单的术语定义：</p>
<ul>
<li><strong>外部BGP（eBGP）</strong>：跨越两个AS的BCP连接。</li>
<li><strong>内部BGP（iBGP）</strong>：在相同AS中的两台路由器之间的BGP连接。</li>
</ul>
 

<p>一个简单流程：</p>
<ul>
<li>网关路由器3a先向网关路由器2c发送一个eBGPb报文“AS3 x”，表示x存在且位于AS3中。</li>
<li>网关路由器2c然后向AS2中的所有其他路由器（包括网关路由器2a）发送iBGP报文“AS3 x”。网关路由器2a接下来向网关路由器1c发送一个eBGP报文“AS2 AS3 x”，报文中包括了AS序号形式的到达x的详细路径。</li>
<li>最后网关路由器1c使用iBGP向ASI中的所有路由器发送报文“AS2 AS3 x”。</li>
<li>在这个过程完成后，AS1和AS2的每个路由器都知道了x的存在并且也都知道了通往x的AS路径。</li>
</ul>
<h4 id="确定最好的路由"><a href="#确定最好的路由" class="headerlink" title="确定最好的路由"></a>确定最好的路由</h4><p>还要介绍一些BGP属性，其中两个最重要的属性是 <strong>AS-PATH</strong> 和 <strong>NEXT-HOP</strong> 。</p>
<ul>
<li><p><strong>AS-PATH</strong> 属性包含了该通告已经通过的AS列表，例如下图中，AS1到子网x有两条路，一条使用AS-PATH“AS2 AS3”，而另一条使用AS-PATH“AS3”。</p>
<blockquote>
<p>该属性还可以用来检测和防止通告环路，如果一台路由器在路径列表中看到了包含自己的AS，它将拒绝通告。</p>
</blockquote>
</li>
<li><p><strong>NEXT-HOP</strong> 是<strong>AS-PATH</strong> 起始的路由器接口的IP地址，例如下图中的2a和3d分别是从AS1到x的两条路径的NEXT-HOP。</p>
</li>
</ul>


<p>这里每条BGP路由包含3个组件：<strong>NEXT-HOP</strong>，<strong>ASPATH</strong>，<strong>目的地前缀</strong>。</p>
<blockquote>
<p>可以把每个 x 看成一个子网，目的地前缀就是子网的网络部分。</p>
</blockquote>
<h4 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h4><p>基本思想：尽可能快地将分组送出其AS，就像丢烫手的土豆一样。</p>
<p><strong>选择具备最小内部区域代价的网关作为往X的出口。</strong></p>
<p>以上图中的1b为例，如果想到达子网x，它可选的两条路径的NEXT-HOP分别为2a和3d。因为1b到达2a的最短距离为2，到达3d的最短距离为3，因此选择到达NEXT-HOP开销更小的路径“AS2 AS3”。</p>
<p>但是很明显，送往3d开销会小一些。</p>
<h4 id="路由选择算法-1"><a href="#路由选择算法-1" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><p>简单的来说，就是路由器被指定一个<strong>本地偏好值</strong>的属性，使得将分组送往本地偏好值最高的路由。</p>
<p>若几个路由器都有最高的本地偏好值，再利用DV向量算法来选择路由。（这里使用的距离是AS间的跳数）</p>
<p>最后使用热土豆路由选择算法。</p>
<h3 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN 控制平面"></a>SDN 控制平面</h3><p>前面已经简单介绍了。</p>
<p>路由控制平面实现转发表和流表的计算可以分成<strong>每路由器控制</strong>和<strong>逻辑集中控制</strong>。</p>
<p>SDN是逻辑集中控制的。</p>
<h3 id="ICMP（我觉得重点）"><a href="#ICMP（我觉得重点）" class="headerlink" title="ICMP（我觉得重点）"></a>ICMP（我觉得重点）</h3><p>ICMP中文名为因特网 控制 消息 协议。</p>
<p>目的是被主机和路由器用来彼此沟通网络层的信息。</p>
<p>因为ICMP报文是作为IP有效载荷承载的，就像TCP与UDP报文段作为IP有效载荷被承载那样，所以ICMP是<strong>运输层</strong>的（这里有歧义）。</p>
<p>使用UDP作为运输层协议。（所以我说有歧义）</p>
 

<p>记得ping请求报文的类型是8编码为0。</p>
<p>ping响应报文的类型是0编码为0。</p>
<p>ttl过期报文的类型为11编码为0。</p>
<p><strong>tracert 原理：</strong></p>
<ul>
<li>从源主机向目的主机发出一系列具有不可达UDP端口号的报文，并且TTL从1，2，3…逐渐上升，并且对每个报文开始计时。</li>
<li>当路径上的路由收到该报文，并检查TTL值，发现过期，就向源主机发送ICMP（类型11编码0TTL过期）报文。</li>
<li>因为ICMP报文会有IP地址，这样源主机就可以得到整条路径上的路由器IP和RTT了。</li>
<li>当报文到达目的主机时，因为报文是具有UDP不可达端口号的，所以目的主机会向源主机发送ICMP（类型3编码3）报文，这样源主机就知道哪个是目的主机的IP了。</li>
</ul>
<p>实际上，tracert是每个TTL值发送3个分组，即10跳有30个分组！！</p>
<h3 id="网络管理-SNMP（了解概念）"><a href="#网络管理-SNMP（了解概念）" class="headerlink" title="网络管理 SNMP（了解概念）"></a>网络管理 SNMP（了解概念）</h3><p>简单网络管理协议 SNMP 是一个应用层协议，用于管理服务器和被管设备的网络管理代理之间。</p>
<blockquote>
<p>网络管理代理实际上是运行在被管设备的一个应用，用于跟SNMP管理服务器通信。</p>
</blockquote>
<p>SNMP 一共有两种模式，一种是请求响应，一种是陷阱报文（中断）。</p>
<ul>
<li><p><strong>请求响应</strong></p>
<p>SNMP管理服务器定时向网络代理发送请求（类似问你还好吗），代理再响应（类似说我很好）。</p>
</li>
<li><p><strong>陷阱报文</strong></p>
<p>聪明的你一定可以想到，管理服务器需要定期向网络代理发送”关怀”报文，这太麻烦了和浪费资源了。所以参考操作系统的中断概念，只有当被管设备自己出现问题的时候，网络代理才会向管理服务器发送<strong>陷阱报文</strong>，提示管理服务器要管管自己了。</p>
</li>
</ul>
<h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><p>可以刷作业12到15题。</p>
<h2 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h2><p>通信链路一般分两种，分别是<strong>点对点链路</strong>和<strong>广播信道</strong>。</p>
<ul>
<li><p><strong>点对点链路</strong></p>
<p><strong>定义：</strong> 点对点通信链路指的是两个网络设备之间的直接连接，数据只能在这两个设备之间传输。</p>
<p>适用于<strong>长距离通信</strong>和<strong>企业内部两个办公室之间使用专线连接</strong>。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">设备A</span> &lt;<span class="hljs-literal">----</span><span class="hljs-comment">点对点链路</span><span class="hljs-literal">----</span>&gt; <span class="hljs-comment">设备B</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>长距离通信不适合广播信道因为可能会发生很多碰撞。</p>
</blockquote>
</li>
<li><p><strong>广播信道</strong></p>
<p><strong>定义：</strong> 广播信道通信链路指的是多个网络设备共享同一传输介质，数据在该介质上以广播方式传输，所有连接在该信道上的设备都能接收传输的数据。</p>
<p>适用于<strong>以太网</strong>和<strong>无线局域网</strong>。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">设备A</span><br>   <span class="hljs-comment">\</span><br>    <span class="hljs-comment">\</span><span class="hljs-literal">---</span> <span class="hljs-comment">广播信道</span> <span class="hljs-literal">---</span> <span class="hljs-comment">设备B</span><br>    <span class="hljs-comment">/                  /</span><br><span class="hljs-comment">设备C               设备D</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>前面有讲到，同一个子网内的分组可以直接传送，这是因为它们使用了广播信道，。</p>
</blockquote>
</li>
</ul>
<p>定义一些术语：</p>
<ul>
<li>节点：运行链路层协议的一切设备。例如主机，wifi接入点，路由器，交换机。</li>
<li>链路：沿着通信路径连接相邻节点的通信信道。</li>
<li>在通过特定的链路时，传输节点将数据报封装在<strong>链路层帧</strong>中，并将该帧传送到链路中。</li>
</ul>
<p>为了将一个数据报从源主机传输到目的主机，数据包必须通过<strong>沿端到端路径上的各段链路传输</strong>。</p>
<h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><h4 id="数据链路层提供的服务"><a href="#数据链路层提供的服务" class="headerlink" title="数据链路层提供的服务"></a>数据链路层提供的服务</h4><p>链路层是为<strong>节点与节点</strong>之间提供逻辑通信的；网络层是为<strong>源主机和目的主机</strong>提供逻辑通信的；运输层是为<strong>源主机上的进程与目的主机上的进程</strong>提供逻辑通信的。</p>
<p>提供的具体服务如下：</p>
<ul>
<li><strong>封装成帧</strong></li>
<li>链路接入</li>
<li>可靠交付</li>
<li><strong>差错检错和纠正</strong></li>
</ul>
<p>链路层的主体部分实在<strong>网络适配器</strong>中实现的，也被称为<strong>网络接口卡</strong>，就是我们通常说的<strong>网卡</strong>。网络适配器实现链路层功能和相应的物理层功能。</p>
 

<h3 id="差错检测和纠正技术（重点）"><a href="#差错检测和纠正技术（重点）" class="headerlink" title="差错检测和纠正技术（重点）"></a>差错检测和纠正技术（重点）</h3><p>在发送节点，为了保护比特免受差错，使用<strong>差错检测和纠正比特（EDC）</strong> 对数据D进行增强，D即为我们需要保护的数据，它不仅包括从网络层传递下来的数据报，还包括链路帧首部中的链路级的寻址信息、序号。</p>
<p>接收方的任务是在只接收到D’和EDC’的情况下，确认D’和D是否相同。</p>
 

<p>要记得：<strong>检测出差错一定错！！未检测出差错不一定对！！</strong></p>
<p>使用三个方法来检测差错：奇偶校验、检验和、CRC。</p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>使用<strong>单个奇偶校验位</strong>。</p>
<ul>
<li><strong>偶校验方案：</strong>使得整个帧中（原始数据<strong>加上奇偶校验位</strong>）的”1”比特数量为偶数。</li>
<li><strong>奇校验方案：</strong>使得整个帧中（原始数据<strong>加上奇偶校验位</strong>）的”1”比特数量为奇数。</li>
</ul>
<blockquote>
<p>只能检验出现奇数个比特出错。</p>
</blockquote>
 

<p>为了能够查询出错误并且纠正，将 D 中的 d 个比特划分成 i 行 j 列，并且对它的每一行计算奇偶校验值（一共有i+j+1个），这个方案称为<strong>二维奇偶校验</strong>。</p>
 

<h4 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h4><p>跟运输层的实现方法一样，将数据 D 拆分成 16 个比特的序列处理，将整个序列加起来（记得回滚）并取反码就是检验和。</p>
<p>检验和方法开销比较小（检验和字段只需要16个比特），但是提供的差错保护没有CRC好。</p>
<blockquote>
<p>为什么运输层常用Checksum，但是链路层常使用CRC检测差错呢？</p>
<p>因为运输层有一部分是通过系统的软件实现的，所以采用简单而快速的Checksum方法来检测是很重要的。并且链路层的CRC检验在网络适配器中有专门的设计，可以更快的计算CRC。</p>
</blockquote>
<h4 id="循环冗余检测（CRC）（必考）"><a href="#循环冗余检测（CRC）（必考）" class="headerlink" title="循环冗余检测（CRC）（必考）"></a>循环冗余检测（CRC）（必考）</h4><p>首先，先介绍一下模2运算，所有的<strong>CRC计算都采用模2运算</strong>：</p>
<p>加法不进位，减法不借位，位与位之间无关。这意味着加法和减法是相同的，这种操作等价于异或（XRO）。</p>
 

<p>CRC 编码的操作如下：对于一个 d 比特的数据D，在发送前，发送方和接收方先约定一个 r+1 比特模式，称为生成多项式（G），要求 G 的最高有效位为 1。</p>
<p>发送方要选择 r 个附加比特 R，并将他们附加到 D 上，使得得到的 d+r 比特模式用模 2 算术恰好能够被 G 整除。</p>
 

<p>接收方进行差错检测：用G去除接收到的 d+r 比特，如果余数非零，则说明出现了差错，否则认为数据正确而被接收。而所有的 CRC 计算均采用模2运算来计算。</p>
<p>通常会给定 G，因为 G 是 r+1 位的，所以可以计算出 r。再根据以下公式计算出 R 的值。<br>$$<br>R &#x3D; \text{remainder} \left( \frac{D \cdot 2^r}{G} \right)<br>$$<br>下图是一个例子：</p>
<p>给定 G 为 1001，即 r 为 3。</p>


<p>因为要求 R 是 3位 的，所以要在余数前面补上 0。</p>
<p><strong>每个CRC检测都能检测出最多 r 比特的差错！！</strong></p>
<h3 id="多路访问链路和协议（重点）"><a href="#多路访问链路和协议（重点）" class="headerlink" title="多路访问链路和协议（重点）"></a>多路访问链路和协议（重点）</h3><p>前面提到网络链路有两种类型：<strong>点对点链路</strong>和<strong>广播链路</strong>。</p>
<ul>
<li><strong>点对点链路</strong> 由链路一端的单个发送方和链路另一端的单个接收方组成。点对点协议（point-to-point protocol，PPP）和高级数据链路控制（high-level data link control，HDLC）便是为这种网络链路设计的协议。</li>
<li><strong>广播链路</strong> 能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。这里的广播意味着任何一个节点传输一个帧时，信道都会广播该帧，每个其他节点都会收到一个特定的副本。传统的以太网和无线局域网都是广播链路层技术的例子。</li>
</ul>
<p>在广播链路中应该如何协调多个发送和接收节点对一个共享广播信道的访问，我们将其称为<strong>多路访问问题</strong>。</p>
<p>在广播链路中，当多个节点同时传输帧时，传输的帧会在所有的接收方处<strong>碰撞</strong>。当碰撞发生时，接收节点无法有效地获得任何传输的帧。<strong>多路访问协议</strong> 便是用来解决这种问题的。</p>
<p>多路访问协议划分为三种：<strong>信道划分协议</strong>、<strong>随机接入协议</strong>、<strong>轮流协议</strong>。</p>
<h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><p>可以根据时间（时分多用TDM）和频率（频分多用FDM）来划分信道。</p>
<p>假设一共有N个节点以及信道的传输速率为 R bps。</p>
<ul>
<li><p><strong>时分多用</strong></p>
<p>将时间划分成时间帧，并进一步将每个时间帧划分成N个时隙。</p>
<p>然后平均将每个时隙分配给一个节点。</p>


<p>消除碰撞，并且十分公平。</p>
<p>但问题是假设只有一个节点需要发送帧，可是它的速率被限制成R&#x2F;N。并且还需要等待到自己的时隙才能发送。</p>
</li>
<li><p><strong>频分多用</strong></p>
<p>在信道划分成多个频段（带宽为R&#x2F;N）,并将频段平均分给每个节点。</p>
<p>但问题还是假设只有一个节点需要发送帧，可是它的速率被限制成R&#x2F;N。</p>
</li>
<li><p><strong>码分多址 CDMA</strong></p>
<p>简单来说，就是对每个节点要传输的帧进行不同的编码，然后接收方再解码。</p>
<p>如果精心选择编码的话，可以实现不同的节点同时发送，并且相对应的接收方可以正确接收发送方编码的数据比特。</p>
</li>
</ul>
<h4 id="随机接入协议（重点）"><a href="#随机接入协议（重点）" class="headerlink" title="随机接入协议（重点）"></a>随机接入协议（重点）</h4><p>在随机接入协议中，一个传输节点总是以<strong>信道的最大传输速率（R）</strong>来进行发送。</p>
<p>当发生碰撞之后，<strong>它在重发该帧之前等待一个随机时延</strong>。</p>
<h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a><strong>时隙ALOHA</strong></h5><p>在分析之前，需要进行一些假设：</p>
<ul>
<li>所有数据链路帧是等长的。</li>
<li>时间被划分成相等的时隙，每个时隙刚好可以发送一帧。</li>
<li>每个节点只在时隙开始时发送帧。</li>
<li>节点是<strong>同步</strong>的，每个节点都知道时隙何时开始。</li>
<li>如果一个时隙中有两个及以上帧碰撞，则所有的节点在该时隙结束之前都能检测到碰撞。</li>
</ul>
<p>当碰撞发生后，碰撞的节点不会立即在下一个时隙重传，<strong>而是在每个时隙开始时以概率P重传</strong>，直到成功。</p>
 

<p>以上图为例，1、2、3号节点在第一个时隙同时发送数据，产生碰撞。</p>
<ul>
<li><p>第三个时隙，恰巧1、2号节点同时选择重传，再一次发生碰撞，传送失败。</p>
</li>
<li><p>第四个时隙，只有2号节点选择重传，成功传输。</p>
</li>
<li><p>第六个时隙，1、3号节点同时选择重传，发送碰撞。</p>
</li>
<li><p>第八个时隙，只有1号节点选择重传，成功传输。</p>
</li>
<li><p>第九个时隙，三号节点选择重传，没有碰撞，成功传输。</p>
</li>
</ul>
<p>时隙ALOHA特点：</p>
<ul>
<li>当信道中只有一个活跃节点，表现很好。</li>
<li>但是当信道中有多个活跃节点，容易发生碰撞，“浪费”掉时隙。</li>
<li>并且每个节点需要<strong>同步</strong>。</li>
</ul>
<p>时隙ALOHA效率：</p>
<p>我们用成功传输的时隙占比来计算时隙ALOHA协议的效率，一个节点成功传输的概率为：<br>$$<br>p(1-p)^{N-1}<br>$$<br>因为有N个节点，任意一个节点成功的概率（实际上是时隙ALOHA的效率）为：<br>$$<br>Np(1-p)^{N-1}<br>$$<br>对上式取最大值，可以计算出时隙ALOHA的最大效率为：1&#x2F;e &#x3D; <strong>0.37</strong> 。</p>
<h5 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h5><p>在ALOHA协议下，节点无需在时间上同步，当有帧需要传输时，可以马上传输，如下图所示：</p>
 

<p>为了使时刻 t0 开始传输的帧正确的传输，在[t0 -1 , t0]这个时间间隔内不能有其他节点开始传输。</p>
<p>其他节点在[t0 -1 , t0]这个时间间隔内不传输的概率为：<br>$$<br>(1-p)^{N-1}<br>$$<br>则任意一个节点成功传输的概率（ALOHA的效率）为：<br>$$<br>Np(1-p)^{2(N-1)}<br>$$</p>
<p>对上式取最大值，ALOHA的最大效率为：1&#x2F;2e ，是时隙ALOHA的一半，这个就是去除同步之后付出的代价。</p>
<h5 id="载波侦听多路访问CSMA（重点）"><a href="#载波侦听多路访问CSMA（重点）" class="headerlink" title="载波侦听多路访问CSMA（重点）"></a>载波侦听多路访问CSMA（重点）</h5><p>跟纯ALOHA有点像，但是一个节点在传输前会先<strong>侦听信道</strong>，如果信道空闲，则传输整个帧，否则推迟传送，等到信道空闲再尝试传输。</p>
<p>使用这种方式，信道仍然会有碰撞，主要原因是因为广播信道的端到端信道传播时延。</p>
 

<p>t0时刻，节点B侦听到信道是空闲的，开始沿着广播媒体在两个方向上传播它的比特。</p>
<p>在t1时刻，节点D有一个帧需要发送，虽然此时节点B正在传输，但是B传输的比特还没有到达，导致D误认为信道空闲，选择传输比特，最终发生碰撞，导致两个节点传输失败。</p>
<p>很明显广播信道的端到端传播时延对CSMA影响很大，碰撞概率主要由以下因素影响：</p>
<ul>
<li>节点间距离越大，传播时延越大，碰撞可能越大。</li>
<li>节点越多，碰撞可能越大。</li>
</ul>
<h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h5><p>对比载波侦听多路访问CSMA，增加了碰撞检测，即一发生碰撞就停止传输。</p>
 



<p>CSMA&#x2F;CD协议的整体运行流程如下：</p>
<ol>
<li><p>适配器从网络层获得数据报，准备链路层帧。</p>
</li>
<li><p>在发送帧前，侦听信道，若信道空闲则开始传送帧，信道忙则等到信道空闲再发送。</p>
</li>
<li><p>在传输过程中仍然检测信道，没有检测到冲突则持续发送，直到成功发送完成；检测到冲突则终止传输。</p>
</li>
<li><p>终止传输后，适配器<strong>根据二进制指数</strong>后退等待一个随机时间量，返回步骤2。</p>
</li>
</ol>
<h5 id="二进制指数后退"><a href="#二进制指数后退" class="headerlink" title="二进制指数后退"></a>二进制指数后退</h5><p>假设传输一个给定帧，它一共发生了n次碰撞后，节点随机从{$$0,1,2,…,2^n-1$$}选择一个k值，并且等待 <strong>k * 512 字节在数据链路层的传输时间</strong>。</p>
<ul>
<li>即k的单位是链路层传输512字节的时间。</li>
</ul>
<p>举个例子：</p>
<ul>
<li>首次碰撞，节点从{0, 1}中随机选择k值，若抽到0，则立刻监听信道；若抽到1，则等待（链路层传输512字节时间）后进行监听信道。</li>
<li>第二次碰撞，节点从{0, 1, 2, 3}中随机选择k值…</li>
<li>…</li>
</ul>
<p>二进制指数后退算法是<strong>分布式</strong>的！即每个节点自己算自己的。</p>
<p>CSMA&#x2F;CD的效率为：<br>$$<br>\text{效率} &#x3D; \frac{1}{1 + 5 \frac{d_{\text{prop}}}{d_{\text{trans}}}}<br>$$</p>
<ul>
<li>$$d_{prop}$$是传播的最大时间。</li>
<li>$$d_{trans}$$是传输一个最大长度的以太网帧的时间。</li>
</ul>
<h4 id="轮流协议（了解）"><a href="#轮流协议（了解）" class="headerlink" title="轮流协议（了解）"></a>轮流协议（了解）</h4><p><strong>信道划分协议</strong>在高负载下是有效和公平的，但是低负载下由于节点速率被限制在R&#x2F;N，因此效率较低；</p>
<p><strong>随机访问协议</strong>在低负载时效率高，单个节点可以完全利用信道带宽，但在高负荷情况下冲突概率大，效率低。</p>
<p>而<strong>轮流协议</strong> 集成了两者的优点，在低负载和高负载情况下都能有着较高的效率。</p>
<p>分为<strong>轮询协议</strong>和<strong>令牌传递协议</strong>。</p>
<h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h5><p>设置一个主节点，主节点依次询问每个节点，告诉它能够传输的帧的最多数量。</p>
<p>一个节点传输完成后，主节点就会开始询问下一个节点，轮流执行。</p>
<p>存在单点故障问题，一旦主节点故障，整个信道都会变得不可操作。</p>
<h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h5><p>该协议没有主节点。一个称为<strong>令牌的小的特殊帧</strong>在节点之间以某种固定的次序进行交换。如果某节点持有令牌并有数据要发送，它将占用令牌并发送数据，当发送完成，节点释放令牌并将其传递给下一个节点。</p>
<p>也是一样存在问题，如果令牌传丢了怎么办。</p>
<h3 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h3><h4 id="MAC地址与IP地址"><a href="#MAC地址与IP地址" class="headerlink" title="MAC地址与IP地址"></a>MAC地址与IP地址</h4><ul>
<li><p><strong>IP地址</strong>是网络层地址，32位（IPv6为128位），是<strong>分层</strong>的，能够实现路由聚集。用于完成网络到网络的交付。</p>
<p>分层的意思是IP地址可被分成子网部分和主机部分。</p>
</li>
<li><p><strong>MAC地址</strong>是链路层地址，48比特。是<strong>平面</strong>的，仅用来区分一个网络内的不同网卡，任何两个网卡的MAC地址都不相同。用于完成一个物理网络内部节点到节点的数据交付。</p>
</li>
</ul>
 

<blockquote>
<p>可以注意到链路层交换机是没有MAC地址的接口的，只有主机和路由器的接口有。</p>
</blockquote>
<p>目前可观察到的三种地址：应用层的主机名，网络层的IP地址，链路层的MAC地址。</p>
<h4 id="ARP协议（地址解析协议）重点"><a href="#ARP协议（地址解析协议）重点" class="headerlink" title="ARP协议（地址解析协议）重点"></a>ARP协议（地址解析协议）重点</h4><p>目的在IP地址和MAC地址之间进行转换。</p>
<p>接下来解释ARP在一个子网中的使用流程。</p>
 

<p>如上的一个局域网中每个接口都有一个IP地址和MAC地址，假设主机C想要向主机A发送IP数据报。发送数据报时，主机C除了需要向它的网络适配器提供IP数据报外，还需要提供目的地的MAC地址，然后适配器将构造一个包含目的地的MAC地址的链路层帧，并把该帧发送进局域网。<strong>而目标主机MAC地址的获取就是ARP需要完成的任务。</strong></p>
<p>每个主机或路由器上维护着一个ARP表，而主机C上的ARP表可能如下图所示：</p>
 

<blockquote>
<p>可以发现还存储了时间，可能时间久了，就会将该记录从ARP表中去除。</p>
</blockquote>
<p>可以看到ARP表上并不包含该子网内的所有主机和路由器，需要查询的目标地址A的MAC地址并不在表项中，那么主机C会向它的适配器传递一个ARP查询分组（包括源和目的地的IP地址和MAC地址），该分组的目标地址为<strong>MAC广播地址（即FF-FF-FF-FF-FF-FF）</strong>，子网内的所有地址都会收到该查询分组。</p>
<p>当主机A收到该查询分组后（分组里有主机A的IP地址），会把自己的MAC地址放在ARP响应分组里，通过<strong>标准帧</strong>的形式发送给主机C。然后主机C将得到的映射关系存储更新在自己的ARP表中。</p>
<p>ARP查询是<strong>广播帧</strong>！响应是一个<strong>标准帧</strong>！！</p>
<blockquote>
<p>一般来说，收到一个帧后，网络适配器检查自己的MAC地址是否与目的MAC地址对应，如果不对应则丢弃，对应则接收并处理；但是如果目的MAC地址是广播帧，则所有的网络适配器都会接收并处理。</p>
</blockquote>
<p>DNS和ARP的区别：DNS是<strong>整个因特网都可以使用</strong>，但是<strong>ARP只能在自己的子网内</strong>（即同个广播信道）使用。</p>
<p>ARP是<strong>即插即用</strong>的：ARP表是<strong>自动生成</strong>的，不需要人工配置。</p>
<h4 id="发送数据报到子网之外"><a href="#发送数据报到子网之外" class="headerlink" title="发送数据报到子网之外"></a>发送数据报到子网之外</h4><p>刚刚描述了子网内传报的流程，现在观察如何传输到子网外。</p>
<p>考虑下图是由一台路由器互联两个子网形成的简单网络：</p>


<p>假设IP为<code>111.111.111.111</code>的主机A准备向另一个子网里IP为<code>222.222.222.222</code>的主机B发送数据报。</p>
<ol>
<li><p>主机A将数据报交付给它的适配器时，需要指示一个适当的MAC地址。该地址并不是主机B的MAC地址（因为主机B并不在当前子网内），而是下一跳路由器<code>111.111.111.110</code>的MAC地址。</p>
</li>
<li><p><strong>通过ARP得到该MAC地址后</strong>，封装链路层帧（该帧包含了寻址到主机B的IP数据报），并发送出去。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">IP   src : 111.111.111.111<br>IP  dest : 222.222.222.222<br>MAC  src : <span class="hljs-type">FF</span>-<span class="hljs-number">55</span><br>MAC dest : <span class="hljs-type">BB</span>-<span class="hljs-number">4</span>B<br></code></pre></td></tr></table></figure>
</li>
<li><p>路由器发现该帧是向自己寻址的，于是进行接收，然后解封装。读取到数据报的目标IP后，结合自己的转发表找到转发端口应该为<code>222.222.222.220</code>。</p>
</li>
<li><p>该端口再把这个数据报进行封装，MAC地址为目标主机B的MAC地址（因为此时已经和目标主机位于同一子网，且<strong>依旧使用ARP获得主机222.222.222.222的MAC地址</strong>）。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IP</span>   src : <span class="hljs-number">111.111.111.111</span><br><span class="hljs-attribute">IP</span>  dest : <span class="hljs-number">222.222.222.222</span><br><span class="hljs-attribute">MAC</span>  src : <span class="hljs-number">06</span>-<span class="hljs-number">9</span>B<br><span class="hljs-attribute">MAC</span> dest : <span class="hljs-number">56</span>-<span class="hljs-number">2</span>A<br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>可能你会想主机111.111.111.111一开始是如何获得网关路由器的IP地址的，这是DHCP分配IP地址给主机的时候给的。</p>
</blockquote>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网的拓扑结构分成<strong>总线拓扑</strong>和<strong>星形拓扑</strong>，若以太网是总线拓扑则是一种<strong>广播信道（链路）</strong>。</p>
<p>使用总线拓扑的以太网使用<strong>CSMA&#x2F;CD协议</strong>解决碰撞。（所以CSMA&#x2F;CD很重要）</p>
 

<ul>
<li><strong>目的地址（6字节）</strong>：适配器只会处理自己和广播地址为目的地址的帧。</li>
<li><strong>源地址（6字节）</strong>：传输该帧到局域网上的适配器的MAC地址。</li>
<li><strong>类型字段（2字节）</strong>：类型字段允许以太网复用多种网络层协议。即类似向目的适配器告知使用了哪个网络层协议。</li>
<li><strong>数据字段（46~1500字节）</strong>：该字段承载了IP数据报，以太网的最大传输单元MTU是<strong>1500字节</strong>，超过则需要进行分片。数据字段的最小长度是46字节，不足则需要填充到46字节。</li>
<li><strong>CRC（4字节）</strong>：循环冗余校验码。</li>
</ul>
<p>以太网向网络层提供<strong>无连接服务</strong>和<strong>不可靠服务</strong>（就算它包含了CRC）。</p>
<ul>
<li>因为即使通过校验，接收方也不会发送确认帧；没通过校验，接收方也不会发送否定确认帧，只是直接丢弃该帧。所以发送方并不知道它传输的帧是否成功达到并通过校验。</li>
<li>这有助于降低以太网的复杂度和成本，但可能导致传递到网络层的数据报流存在间隙。UDP会无视这些间隙（导致应用层会看到数据中的间隙），但TCP不会对有间隙的数据报进行确认，从而执行重传。以太网并不知道自己传输的是一个新的数据报还是被重传的数据报。</li>
</ul>
<blockquote>
<p>链路层的东西都有点无脑，只负责做搬运工。</p>
</blockquote>
<h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><h5 id="转发和过滤"><a href="#转发和过滤" class="headerlink" title="转发和过滤"></a>转发和过滤</h5><ul>
<li><p><strong>过滤</strong>：决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p>
</li>
<li><p><strong>转发</strong>：是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。</p>
</li>
</ul>
<p>交换机的过滤和转发必须依靠<strong>交换机表</strong>实现。</p>
<p>交换机表的表项包含：</p>
<ul>
<li>MAC地址</li>
<li>通向该MAC地址的接口</li>
<li>表项放在表内的时间</li>
</ul>
 

<p>当一个目的地址为<code>DD-DD-DD-DD-DD-DD</code>的帧从交换机接口 x 到达，交换机用该MAC地址在它的表里进行索引。有3种可能的情况：</p>
<ol>
<li><strong>表中没有该表项</strong>：交换机会将该帧广播到所有端口（除了接收该帧的端口x），即将帧转发到除入口端口以外的所有接口。</li>
<li><strong>表中有一个表项将该MAC地址与接口 x（即进来时的接口）联系起来</strong>：不会转发，而是直接丢弃该帧（避免环路）。</li>
<li><strong>表中有一个表项将该MAC地址与非 x 的的接口联系起来</strong>：将帧转发到该MAC地址对应的端口，不会进行广播。</li>
</ol>
<h5 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h5><p>交换机是<strong>自学习</strong> 的，即它的表是自动，动态和自治地建立的，不需要来自网络管理员和配置协议的任何干预。实现过程如下：</p>
<ol>
<li>交换机表初始为空。</li>
<li>对于在每个接口收到的帧，交换机会在其表中存储：<ul>
<li><strong>源MAC地址</strong>。</li>
<li><strong>接口信息</strong>：将源MAC地址和对应的接口进行关联并记录，以便在之后需要转发到该地址时知道帧应该从哪个接口发送。</li>
<li><strong>时间</strong>。</li>
</ul>
</li>
<li>如果在老化期内，交换机没有收到以该地址作为源地址的帧，就在表中删除这个地址（以这种方式，如果一台主机更换了网卡，那么旧的MAC地址最终会被从该交换机表中清除掉）。</li>
</ol>
<p>因为交换机不需要网络管理员或用户的干预，因此交换机是<strong>即插即用设备</strong>。</p>
<blockquote>
<p>ARP虽然也是即插即用的，但并不是自学习的。因为ARP的工作依赖于<strong>设备主动发送ARP请求</strong>来获得地址映射信息，而交换机是被动地从流经的帧中学习。</p>
</blockquote>
<h4 id="交换机和路由器的比较"><a href="#交换机和路由器的比较" class="headerlink" title="交换机和路由器的比较"></a>交换机和路由器的比较</h4> 

<p><strong>其实我看网上其他人的复习资料，好像到这里就结束了。</strong></p>
<h4 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h4><p>之前描述的局域网具有以下几个问题：</p>
<ul>
<li>缺乏流量隔离：可以发现经常有广播流量，例如像ARP和刚刚提到的交换机转发功能。为了安全和性能，要尽量减少广播流量。</li>
<li>难管理。</li>
</ul>
<p>这些问题都可以通过支持<strong>虚拟局域网的交换机</strong>来处理。</p>
<blockquote>
<p>简单来说，就是将一个物理局域网划分成多个虚拟局域网。</p>
</blockquote>
<p>在一个基于端口区分的VLAN中，交换机的端口由网络管理员划分为组。每个组形成一个VLAN，来自一个端口的广播流量只能到达该组的其他端口。</p>
 

<p>上图表示端口2-8被分配给了电气工程系，形成电气工程系的虚拟局域网；端口9-15被分配给了计算机科学与技术系，形成计算机科学与技术系的虚拟局域网。端口1和16未被分配，属于一个默认的VLAN。</p>
<p>现在考虑，如何实现来自电气工程系的流量发送给计算机科学系：</p>
 

<p>使用<strong>VLAN 干线连接（VLAN trunking）</strong>实现。</p>
<p>每台交换机的一个特殊端口被配置为 <strong>trunk 端口</strong>（左边的16端口，右边的1端口），以互联这两台交换机。</p>
<p>trunk 端口属于任何一个VLAN，发送到其他VLAN的帧都需要发送到 trunk 端口。</p>
<p>发送到 trunk 端口的帧都需要使用扩展的<strong>以太网帧格式 802.1Q</strong>，增加了<strong>VLAN 标签（tag）</strong>以区分流量属于哪个VLAN。</p>
<p>VLAN 标签由干线发送侧的交换机加进帧中，由干线接收侧的交换机去除。</p>
<p>假设端口2想传送数据包给端口9（上上图）传输流程如下：</p>
<ol>
<li><p><strong>设备发送数据包</strong>：VLAN 1中的设备生成数据帧，并将数据包发送到交换机。</p>
</li>
<li><p><strong>交换机识别VLAN ID</strong>：交换机检查数据包的来源端口（端口2），并识别该端口属于VLAN 1。</p>
</li>
<li><p><strong>数据帧转发到路由器</strong>：由于目标设备在另一个VLAN（VLAN 2），交换机将数据包通过Trunk端口转发到路由器。</p>
</li>
<li><p><strong>路由器进行路由</strong>：路由器检查数据包的目标IP地址，判断数据应转发到VLAN 2；路由器将数据包发送回交换机，同时标记数据帧属于VLAN 2。</p>
</li>
<li><p><strong>交换机转发数据</strong>：交换机接收数据帧后，将其转发到VLAN 2的目标端口（如端口9）。</p>
</li>
</ol>
<h4 id="多协议标签交换-MPLS（了解）"><a href="#多协议标签交换-MPLS（了解）" class="headerlink" title="多协议标签交换 MPLS（了解）"></a>多协议标签交换 MPLS（了解）</h4><p>IP转发需要使用最长前缀匹配，太慢了！</p>
<p>希望能够用一个定长的标签（而不是IP地址）来决定转发的接口。</p>
<p>在以太网首部和IP首部中间增加MPLS标签（首部），因为这个设计，一个MPLS加强的帧只能在两个均为MPLS使能的路由器间传输。</p>
 

<p>具体例子如下图：</p>
<p>假设 R1 到 R4 都是支持MPLS的路由器。</p>
 

<p>实现了不必考虑IP首部来决定转发的端口。</p>
<h3 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h3><p>这个真的会考吗… 但是写了作业哎。</p>
 

<ul>
<li>Border Router（边界路由器）</li>
<li>Access Router（接入路由器）</li>
<li>Load Balancer（负载均衡器）</li>
<li>Tier-1 Switches（第一层交换机）</li>
<li>Tier-2 Switches（第二层交换机）</li>
<li>TOR Switches（Top of Rack 交换机）</li>
<li>Server Racks（服务器机架）</li>
</ul>
<p>数据中心网络中的数据流动可以分为以下两种情况：</p>
<h4 id="从互联网到数据中心内部的服务器"><a href="#从互联网到数据中心内部的服务器" class="headerlink" title="从互联网到数据中心内部的服务器"></a><strong>从互联网到数据中心内部的服务器</strong></h4><ol>
<li>边界路由器（Border Router）：<ul>
<li>接收来自互联网的数据包，判断其目标地址。</li>
</ul>
</li>
<li>接入路由器（Access Router）：<ul>
<li>将数据包转发到合适的 Tier-1 交换机。</li>
</ul>
</li>
<li>Tier-1 交换机：<ul>
<li>将数据包进一步分发到合适的 Tier-2 交换机。</li>
</ul>
</li>
<li>Tier-2 交换机：<ul>
<li>将数据包转发到目标服务器机架（Server Rack）上的 TOR 交换机。</li>
</ul>
</li>
<li>TOR 交换机：<ul>
<li>将数据包转发到目标机架中的具体服务器。</li>
</ul>
</li>
</ol>
<h4 id="从数据中心内部的一台服务器到另一台服务器"><a href="#从数据中心内部的一台服务器到另一台服务器" class="headerlink" title="从数据中心内部的一台服务器到另一台服务器"></a><strong>从数据中心内部的一台服务器到另一台服务器</strong></h4><ol>
<li>数据包从源服务器发出，经过其所属机架的 <strong>TOR 交换机</strong>。</li>
<li>TOR 交换机将数据包转发到 <strong>Tier-2 交换机</strong>。</li>
<li>如果目标服务器与源服务器属于不同的子网，数据包需要经过 <strong>路由器</strong>，然后进入目标 Tier-2 子网。</li>
<li>最终数据包通过目标机架的 <strong>TOR 交换机</strong> 到达目标服务器。</li>
</ol>
<p>可以发现鲁棒性很差，所以：</p>
 

<h3 id="Web页面请求的历程（非常重要-必考必考！！）"><a href="#Web页面请求的历程（非常重要-必考必考！！）" class="headerlink" title="Web页面请求的历程（非常重要 必考必考！！）"></a>Web页面请求的历程（非常重要 必考必考！！）</h3>、

<p><strong>首先先明确一个终端上网需要的四个地址：IP地址、子网掩码、网关IP、DNS服务器IP地址。</strong></p>
<p>整体计划：初始化IP，得到网关MAC，得到网站IP，建立TCP连接，发送HTTP请求报文。</p>
<p>这里我直接复制网上找的别人写的流程了：</p>
<ol>
<li><strong>DHCP请求报文</strong>：连接到网络时，此时这台机子还没有一个IP地址，因此需要得到一个。将该报文段放入<strong>UDP报文段</strong>，报文目的端口为DHCP服务器，源端口为客户。<br>UDP报文段放入IP数据报中，目的地址为广播，IP源地址为0.0.0.0。<br>IP数据报放入以太网帧中，目的地址为广播，源MAC地址为笔记本MAC地址。<br>将该以太网帧发送到以太网交换机。交换机广播该帧。<br>路由器在对应的MAC地址接收到了这个帧。抽取出IP数据报，分析广播得知这不是针对自己的特定通信，而是一个需要<strong>传递给更高层协议</strong>的信息，可能是为了进一步分发到网络上的所有主机，或者是为了执行某些本地处理（如DHCP服务器响应客户端请求）。因此IP数据报继续被分解，得到UDP报文段，得知这是一个DHCP请求。<br>假设路由器是DHCP服务器，那么会响应该DHCP请求。数据内容为：分配的IP地址，DNS服务器的IP地址，默认网关路由器的IP地址，子网块。生成一个如此的DHCP ACK报文发送回，目标MAC是笔记本的MAC地址。<br>交换机收到该帧。由于是<strong>自学习</strong>的，因此转发给笔记本。<br>笔记本收到该帧，得知IP，DNS，网关，子网块。初始化完成。</li>
<li><strong>ARP查询</strong>：Web浏览器需要生成一个<strong>TCP套接字</strong>，向谷歌网址发送<strong>HTTP请求</strong>。为了生成，需要知道网址的IP地址，这需要<strong>DNS服务</strong>。<br>生成一个包含DNS请求报文的数据报、以太网帧，打算发送给网关路由器。但是仍然不知道网关路由器的MAC。这需要<strong>ARP协议</strong>。<br>ARP查询报文的IP和源MAC已设置好，目的MAC为广播。<br>网关路由器在收到后发送ARP回复。笔记本收到网关路由器的MAC地址。</li>
<li><strong>DNS查询</strong>：向网关服务器发送DNS查询，目标MAC为网关MAC。<br>网关服务器收到，根据转发表发送到Comcast网络中最左侧的服务器。<br>对应服务器收到，根据转发表确定出口，向DNS转发数据报。而转发表已根据域内协议（如<strong>RIP</strong>，<strong>OSPF</strong>）以及<strong>因特网域间协议BGP</strong>填写。<br>DNS服务器收到，抽取出DNS查询，查找谷歌网址。如果没找到，则向根服务器发送查询。<br>总之是得到了，然后生成DNS回答报文，放入UDP报文段中，原路返回。<br>笔记本收到谷歌网址的IP地址。</li>
<li><strong>TCP协议</strong>：同谷歌三次握手，建立TCP套接字。<br>生成HTTP GET报文，写入套接字，报文段交给IP数据报，发送给谷歌。<br>谷歌抽取出报文，生成HTTP响应，发送进TCP套接字中。<br>计算机收到。终于显示了网页。</li>
</ol>
<blockquote>
<p><strong>突然想起来 ack 不只是应用在运输层的要记得。</strong></p>
</blockquote>
<h2 id="第七章-无线网络和移动网络"><a href="#第七章-无线网络和移动网络" class="headerlink" title="第七章 无线网络和移动网络"></a>第七章 无线网络和移动网络</h2><p>我觉得整章都不是重点，应该只会出判断或者选择，如果出简答的话就考验我的吹牛逼能力了。</p>
<p>无线网络有以下要素组成：</p>
<ul>
<li>无线主机：例如手机，平板。</li>
<li>无线链路：主机通过<strong>无线通信链路</strong>连接到一个<strong>基站</strong>或者另一台无线主机。</li>
<li>基站：负责协调与之相关联的多个无线主机的传输。例如无线接入点。</li>
</ul>
<p>与基站关联的主机一般称为<strong>基础设施模式</strong>运行，因为所有网络服务（地址分配和路由选择）都通过基站向无线主机提供。</p>
<p>在<strong>自组织网络（ad hoc）</strong>模式中无线主机没有这样子的设备（基站）与之相连。</p>
<h3 id="无线链路和网络特征"><a href="#无线链路和网络特征" class="headerlink" title="无线链路和网络特征"></a>无线链路和网络特征</h3><p>无线链路有一些问题：</p>
<ul>
<li>递减的信号强度</li>
<li>来自其他源的干扰</li>
<li>多路径传播</li>
</ul>
<p>信噪比（SNR）是收到的信号和噪声强度的相对比较，SNR越大使接收方更容易从背景噪声中提取传输的信号。</p>
<p>比特差错率（BER），知道有这个东西就行。通常 SNR 和 BER 成反比。</p>
 

<h3 id="CDMA-码分多址"><a href="#CDMA-码分多址" class="headerlink" title="CDMA 码分多址"></a>CDMA 码分多址</h3><p>这也是多路访问协议的信道划分协议的一种。</p>
<p>通过划分编码空间来划分信道。</p>
 

<p>发送方和接收方先确定一个CDMA编码（code），发送方CDMA编码器的输出就是code乘以Data bits。</p>
<p>解码的时候就是将编码输出乘以code再除以code的长度即可。</p>
<p>就算有其他发送方的比特混在一起也可以分开：</p>
 

<h3 id="802-11-无线局域网（WIFI）"><a href="#802-11-无线局域网（WIFI）" class="headerlink" title="802.11 无线局域网（WIFI）"></a>802.11 无线局域网（WIFI）</h3><p>使用<strong>CSMA&#x2F;CA协议</strong>控制无线链路之间的碰撞。</p>
<p>802.11体系结构的基本模块是<strong>基本服务器（BSS）</strong>。</p>
<p>BSS 包含<strong>无线站点</strong>和<strong>接入点（中央基站）AP</strong>。</p>
<p>每个无线站点都有一个 48 比特的MAC地址。</p>
 

<p>根据之前的定义可以知道，ad hoc是没有基站的。</p>
<p>接下来我们考虑无线站点（手机）如何跟哪个BSS的接入点AP（wifi）相连呢？</p>
<p>首先要知道，当网络管理员配置BSS的时候，会给AP分配一个<strong>服务集标识符（SSID）</strong>。</p>
<blockquote>
<p>例如用手机联网的时候会显示很多wifi供你选择。</p>
</blockquote>
<p>为了获得因特网接入，你的无线站点需要与一个AP相<strong>关联</strong>。关联的意思是这个无线站点只和这个AP发送数据帧，也只有这个AP能够给无线站点发送数据帧。</p>
<p>802.11要求每个AP周期性的<strong>发送信标帧</strong>（包含AP的SSID和MAC）。</p>
<p>可以通过<strong>被动扫描</strong>和<strong>主动扫描</strong>两种方式来建立关联。</p>
<ul>
<li>被动扫描：<ol>
<li>AP周期的发送信标帧</li>
<li>主机向选择的AP发送关联请求帧</li>
<li>被选择的AP发送关联响应帧</li>
</ol>
</li>
<li>主动扫描：<ol>
<li>主机广播探测请求帧</li>
<li>每个AP向主机发送探测响应帧</li>
<li>主机向选择的AP发送关联请求帧</li>
<li>被选择的AP发送关联响应帧</li>
</ol>
</li>
</ul>
 

<h4 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h4><p>带有<strong>碰撞避免</strong>的CSMA（载波侦听多路访问）。</p>
<p>这个是碰撞避免，前面讲的以太网常使用的<strong>CSMA&#x2F;CD是碰撞检测</strong>。</p>
<p>因为不使用碰撞检测，所以802.11一旦开始传输，就会传输整个帧了。</p>
<p><strong>802.11有确认重传机制</strong>。</p>
 

<p>CSMA&#x2F;CA 的核心在于通过一系列机制<strong>尽量避免碰撞</strong>的发生。以下是其基本工作流程：</p>
<ol>
<li><strong>监听信道</strong>：<ul>
<li>设备在发送数据之前，首先监听通信信道。</li>
<li>如果信道忙（正在传输数据），设备会等待信道空闲。</li>
</ul>
</li>
<li><strong>随机等待（Backoff）</strong>：<ul>
<li>如果信道空闲，设备不会立即发送数据，而是等待一个随机时间（称为“退避时间”）。</li>
<li>这一机制可以减少多个设备同时发送数据的概率，从而避免碰撞。</li>
<li>为什么不使用CSMA&#x2F;CD，假设信道空闲从忙到空闲的一个情况：多个终端就会同时传送帧，导致碰撞发生。</li>
</ul>
</li>
<li><strong>数据传输</strong>：<ul>
<li>如果设备等待后发现信道仍然空闲，则开始发送数据。</li>
<li>发送完毕后，接收设备会向发送设备返回一个 <strong>ACK（确认帧）</strong>，表明数据成功到达。</li>
</ul>
</li>
<li><strong>重传机制</strong>：<ul>
<li>如果发送设备在一定时间内未收到 ACK，则认为数据包丢失（可能由于碰撞或信道问题），并重新尝试发送数据。</li>
</ul>
</li>
</ol>
<p>但是802.11还有一个问题是可能会有隐藏的终端，并且随着信号的衰减，两个终端之间互相检测不到对方。</p>
 

<p>CSMA&#x2F;CA可以使用RTS（request to send）控制帧和CTS（clear to send）控制帧来预约信道的使用，避免隐藏终端问题：</p>
 

 

<p>所以如果判断题问：ack机制只有在传输层才使用是错误的，链路层也有使用。</p>
<h4 id="802-11-帧结构"><a href="#802-11-帧结构" class="headerlink" title="802.11 帧结构"></a>802.11 帧结构</h4><p><strong>一共有四个MAC地址段！以太网帧只有两个（源和目的）！！</strong></p>
<p>802.11帧结构的四个MAC地址段：</p>
<ol>
<li><p>无线站点的MAC地址（源）</p>
</li>
<li><p>AP的MAC地址（目的）</p>
</li>
<li><p>与该AP相连的路由器的MAC地址。</p>
<p>因为 BSS 可以想象成是子网的一个部分，这个子网经过路由器和其他子网相连接。</p>
<p>其实就是网关的MAC地址。</p>
</li>
<li><p>ad hoc自组织网络使用的MAC地址（这里不作讨论）</p>
</li>
</ol>
 

<p>802.11帧的类型有：信标帧（SSID、MAC）、关联帧、RTS控制帧（预约信道使用）、CTS控制帧（允许信道使用）、ack、数据帧。</p>
<h4 id="在相同的IP子网中的移动性"><a href="#在相同的IP子网中的移动性" class="headerlink" title="在相同的IP子网中的移动性"></a>在相同的IP子网中的移动性</h4><p>若两个BSS之间是交换机相连的，则它们属于同一个子网；若是路由器相连的，则它们不属于一个子网（并且移动之后必须在新的子网内获得新的IP地址）。</p>
 

<p>现在考虑一台主机从BSS1移动到BSS2，两个BSS子网是相同的。</p>
<ol>
<li>随着主机 H1 从 BSS1 移动到 BSS2 的过程中，来自 AP1 的信号会逐渐减弱，而 AP2 的信号会逐渐增强。</li>
<li>主机 H1 决定断开与 AP1 的连接并尝试连接到 AP2。</li>
<li>H1 与 AP2 关联起来后，<strong>IP地址不变</strong>并且维持正在进行的TCP对话。即移动过程对网络层和传输层的通信透明。</li>
</ol>
<h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>蓝牙网络必须是<strong>自组织网络（ad hoc）</strong>。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络复习</div>
      <div>https://tobytam23.github.io/2025/01/24/复习笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>tanzhuoheng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 24, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/01/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9/" title="数据库复习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据库复习</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/03/%E8%AE%A9%E8%87%AA%E5%B7%B1%E8%AE%B0%E5%BE%97%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87/" title="让自己记得文章如何输出图片">
                        <span class="hidden-mobile">让自己记得文章如何输出图片</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
